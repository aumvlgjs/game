require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"AnimationManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '05d0cX/ID1MBrBkuPmoWa3f', 'AnimationManager');
// scripts\ui\AnimationManager.js

var Utils = require('Utils'),
    AnimationManager;

AnimationManager = {

    /**
     * Fill a node UI by growth circle at any point.
     *
     * @param  {Node}     node                    node
     * @param  {Position} centerPositionNodeSpace position of center of circle (node space)
     * @param  {Number}   duration                duration in seconds
     * @param  {Boolean}  isStopManually          stop animation manually or not
     * @param  {Function} finishCallback          animation finishing callback
     * @return {Function}                         function to stop animation
     */
    fillRadial: (function () {
        var UPDATE_INTERVAL = 10; // 10ms

        function getMaxRadius(node, centerPositionNodeSpace) {
            var w = node.width,
                h = node.height,
                x = centerPositionNodeSpace.x,
                y = centerPositionNodeSpace.y;

            return Math.max(calcHypotenuse(x, y), calcHypotenuse(x, h - y), calcHypotenuse(w - x, y), calcHypotenuse(w - x, h - y));
        }

        function calcHypotenuse(a1, a2) {
            return Math.sqrt(a1 * a1 + a2 * a2);
        }

        return function (node, centerPositionNodeSpace, options) {
            options = options || {};
            if (!node || !centerPositionNodeSpace || options.duration <= 0) {
                return null;
            }

            var radius = getMaxRadius(node, centerPositionNodeSpace),
                diameter = radius * 2,
                rectMaskNode = new cc.Node(),
                rectMask = rectMaskNode.addComponent(cc.Mask),
                circleMaskNode = new cc.Node(),
                circleMask = circleMaskNode.addComponent(cc.Mask),
                spriteNode = new cc.Node(),
                sprite = spriteNode.addComponent(cc.Sprite),
                radiusIncrStep = radius * UPDATE_INTERVAL / (options.duration * 1000),
                diamterIncrStep = 2 * radiusIncrStep,
                intervalId;

            cc.loader.loadRes('textures/SingleColor', cc.SpriteFrame, function (err, spriteFrame) {
                if (!err) {
                    try {
                        sprite.spriteFrame = spriteFrame;
                    } catch (e) {}
                }
            });

            circleMask.type = cc.Mask.Type.ELLIPSE;
            circleMaskNode.parent = rectMaskNode;
            circleMaskNode.setContentSize(0, 0);
            circleMaskNode.setPosition(centerPositionNodeSpace.x - node.width / 2, centerPositionNodeSpace.y - node.height / 2);

            spriteNode.color = options.color || cc.Color.BLACK;
            spriteNode.opacity = options.opacity >= 0 ? options.opacity : 80;
            spriteNode.parent = circleMaskNode;

            rectMask.type = cc.Mask.Type.RECT;
            rectMaskNode.parent = node;
            rectMaskNode.setContentSize(node.getContentSize());
            rectMaskNode.setSiblingIndex(0);

            function stop() {
                if (intervalId) {
                    clearInterval(intervalId);
                    intervalId = null;
                }

                node.removeChild(rectMaskNode);
                if (rectMaskNode && rectMaskNode.isValid) {
                    rectMaskNode.destroy();
                }
            }

            intervalId = setInterval(function () {
                if (!circleMaskNode || !circleMaskNode.isValid || circleMaskNode.width >= diameter) {
                    if (!options.isStopManually) {
                        stop();
                    }
                    if (Utils.Type.isFunction(options.finishCallback)) {
                        options.finishCallback();
                    }
                    return;
                }

                circleMaskNode.setContentSize(circleMaskNode.width + diamterIncrStep, circleMaskNode.height + diamterIncrStep);
                spriteNode.setContentSize(circleMaskNode.getContentSize());
            }, UPDATE_INTERVAL);

            return stop;
        };
    })()

};

module.exports = AnimationManager;

cc._RFpop();
},{"Utils":"Utils"}],"AudioList":[function(require,module,exports){
"use strict";
cc._RFpush(module, '66143+rqKFME6TICos7r1qJ', 'AudioList');
// scripts\components\AudioList.js

cc.Class({
    'extends': cc.Component,

    properties: {
        audioList: {
            'default': [],
            url: cc.AudioClip
        }
    },

    // use this for initialization
    onLoad: function onLoad() {}

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"AudioManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '888082CC+lA4ImHMGQUYgdE', 'AudioManager');
// scripts\lib\AudioManager.js

var Utils = require('Utils'),
    EventDispatcher = require('EventDispatcher'),
    AUDIO_PREFIX = 'res/raw-assets/audio/',
    AUDIO_URLS = {
    BACKGROUND_MUSIC: AUDIO_PREFIX + 'BackgroundMusic.mp3',
    BAI_CHON: AUDIO_PREFIX + 'BaiChon.mp3',
    BAI_BAY: AUDIO_PREFIX + 'BaiBay.mp3',
    BAI_CHIA: AUDIO_PREFIX + 'BaiChia.mp3',
    BALL_RUN: AUDIO_PREFIX + 'BallRun.mp3',
    CHICKEN_WIN: AUDIO_PREFIX + 'ChickenWin.mp3',
    CHIP_BAY: AUDIO_PREFIX + 'ChipBay.mp3',
    COIN_DROP: AUDIO_PREFIX + 'CoinDrop.mp3',
    DANH_BAI: AUDIO_PREFIX + 'DanhBai.mp3',
    LOST: AUDIO_PREFIX + 'Lost.mp3',
    MINIPOKER: AUDIO_PREFIX + 'MiniPoker.mp3',
    CHICKEN_ROW: AUDIO_PREFIX + 'ChickenRow.mp3',
    PHOM_PICK_CARD: AUDIO_PREFIX + 'PhomPickCard.mp3',
    PHOM_TAI_LUOT: AUDIO_PREFIX + 'PhomTaiLuot.mp3',
    PLAYER_JOIN_ROOM: AUDIO_PREFIX + 'PlayerJoinRoom.mp3',
    PLAYER_LEAVE_ROOM: AUDIO_PREFIX + 'PlayerLeaveRoom.mp3',
    READY: AUDIO_PREFIX + 'Ready.mp3',
    THANG_TRANG: AUDIO_PREFIX + 'ThangTrang.mp3',
    TURN_START: AUDIO_PREFIX + 'TurnStart.mp3',
    VONG_QUAY: AUDIO_PREFIX + 'VongQuay.mp3',
    WIN: AUDIO_PREFIX + 'Win.mp3',
    LOSE: AUDIO_PREFIX + 'Lose.mp3',
    XOC: AUDIO_PREFIX + 'Xoc.mp3',
    BALL_DROP: AUDIO_PREFIX + 'BallDrop.mp3',
    BUTTON_CLICK: AUDIO_PREFIX + 'ButtonClick.mp3',
    ERROR: AUDIO_PREFIX + 'Error.mp3'
},
    BG_MUSIC_VOLUME_KEY = '__bg_music_volume__',
    SOUND_EFFECT_VOLUME_KEY = '__effect_volume__',
    MAX_AUDIO_ITEMS = 20,
    MAX_AUDIO_IDENTITY_ITEMS = 3,
    data = {
    eventDispatcher: EventDispatcher.create(),
    isMusicPlaying: false,
    backgroundMusicId: null,
    effectsVolume: 1,
    musicVolume: 1
},
    EVENTS = {
    CHANGE_EFFECTS_VOLUME: 'change_effects_volume'
},
    AudioManager;

cc.audioEngine.setMaxAudioInstance(MAX_AUDIO_IDENTITY_ITEMS);

function playEffectFactoryFn(clip) {
    return function (loop) {
        Utils.Array.trimLeft(this.audioIdList, MAX_AUDIO_ITEMS);

        var audioId = this.playEffect(clip, loop);
        if (audioId) {
            this.audioIdList.push(audioId);
        }
        return audioId;
    };
}

AudioManager = Utils.Class({
    $$constructor: function $$constructor(configs) {
        configs = configs || {};
        if (Utils.Type.isFunction(configs.effectPlayableFn)) {
            this.effectPlayableFn = configs.effectPlayableFn;
        }
        this.audioIdList = [];

        data.eventDispatcher.addEventListener(EVENTS.CHANGE_EFFECTS_VOLUME, this._onChangeEffectsVolume, this);
    },

    destroy: function destroy() {
        var self = this;
        this.audioIdList.forEach(function (audioId) {
            self.stopEffect(audioId);
        });
        this.audioIdList = [];

        data.eventDispatcher.removeEventListener(EVENTS.CHANGE_EFFECTS_VOLUME, this._onChangeEffectsVolume, this);
    },

    playMusic: function playMusic() {
        this.stopMusic();
        data.backgroundMusicId = cc.audioEngine.play(AUDIO_URLS.BACKGROUND_MUSIC, true, data.musicVolume);
        cc.audioEngine.setVolume(data.backgroundMusicId, data.musicVolume);
        data.isMusicPlaying = true;
    },

    pauseMusic: function pauseMusic() {
        cc.audioEngine.pause(data.backgroundMusicId);
        data.isMusicPlaying = false;
    },

    resumeMusic: function resumeMusic() {
        if (data.backgroundMusicId !== null) {
            cc.audioEngine.resume(data.backgroundMusicId);
        }
    },

    stopMusic: function stopMusic() {
        cc.audioEngine.stop(data.backgroundMusicId);
        data.backgroundMusicId = null;
        data.isMusicPlaying = false;
    },

    isMusicPlaying: function isMusicPlaying() {
        return data.isMusicPlaying;
    },

    getMusicVolume: function getMusicVolume() {
        var volume = parseInt(this._getSetting(BG_MUSIC_VOLUME_KEY));
        if (volume >= 0) {
            return volume;
        }
        return 1;
    },

    setMusicVolume: function setMusicVolume(volume) {
        data.musicVolume = volume;
        cc.audioEngine.setVolume(data.backgroundMusicId, data.musicVolume);
        this._saveSetting(BG_MUSIC_VOLUME_KEY, volume);
    },

    getEffectsVolume: function getEffectsVolume() {
        var volume = parseInt(this._getSetting(SOUND_EFFECT_VOLUME_KEY));
        if (volume >= 0) {
            return volume;
        }
        return 1;
    },

    setEffectsVolume: function setEffectsVolume(volume) {
        data.effectsVolume = volume;
        data.eventDispatcher.dispatchEvent(EVENTS.CHANGE_EFFECTS_VOLUME);
        this._saveSetting(SOUND_EFFECT_VOLUME_KEY, volume);
    },

    playEffect: function playEffect(clip, loop) {
        if (this.effectPlayableFn && !this.effectPlayableFn()) {
            return;
        }
        var audioId = cc.audioEngine.play(clip, loop, data.effectsVolume);
        cc.audioEngine.setVolume(audioId, data.effectsVolume);
        return audioId;
    },

    stopEffect: function stopEffect(audioId) {
        if (audioId) {
            cc.audioEngine.stop(audioId);
        }
    },

    playBaiBay: playEffectFactoryFn(AUDIO_URLS.BAI_BAY),
    playBaiChon: playEffectFactoryFn(AUDIO_URLS.BAI_CHON),
    playBaiChia: playEffectFactoryFn(AUDIO_URLS.BAI_CHIA),
    playBallDrop: playEffectFactoryFn(AUDIO_URLS.BALL_DROP),
    playChickenWin: playEffectFactoryFn(AUDIO_URLS.CHICKEN_WIN),
    playChipBay: playEffectFactoryFn(AUDIO_URLS.CHIP_BAY),
    playCoinDrop: playEffectFactoryFn(AUDIO_URLS.COIN_DROP),
    playDanhBai: playEffectFactoryFn(AUDIO_URLS.DANH_BAI),
    playLost: playEffectFactoryFn(AUDIO_URLS.LOST),
    playMiniPoker: playEffectFactoryFn(AUDIO_URLS.MINIPOKER),
    playChickenRow: playEffectFactoryFn(AUDIO_URLS.CHICKEN_ROW),
    playPhomPickCard: playEffectFactoryFn(AUDIO_URLS.PHOM_PICK_CARD),
    playPhomTaiLuot: playEffectFactoryFn(AUDIO_URLS.PHOM_TAI_LUOT),
    playPlayerJoinRoom: playEffectFactoryFn(AUDIO_URLS.PLAYER_JOIN_ROOM),
    playPlayerLeaveRoom: playEffectFactoryFn(AUDIO_URLS.PLAYER_LEAVE_ROOM),
    playReady: playEffectFactoryFn(AUDIO_URLS.READY),
    playThangTrang: playEffectFactoryFn(AUDIO_URLS.THANG_TRANG),
    playTurnStart: playEffectFactoryFn(AUDIO_URLS.TURN_START),
    playVongQuay: playEffectFactoryFn(AUDIO_URLS.VONG_QUAY),
    playWin: playEffectFactoryFn(AUDIO_URLS.WIN),
    playXoc: playEffectFactoryFn(AUDIO_URLS.XOC),
    playBallRun: playEffectFactoryFn(AUDIO_URLS.BALL_RUN),
    playLose: playEffectFactoryFn(AUDIO_URLS.LOSE),
    playButtonClick: playEffectFactoryFn(AUDIO_URLS.BUTTON_CLICK),
    playError: playEffectFactoryFn(AUDIO_URLS.ERROR),

    _saveSetting: function _saveSetting(key, value) {
        cc.sys.localStorage.setItem(key, value);
    },

    _getSetting: function _getSetting(key) {
        return cc.sys.localStorage.getItem(key);
    },

    _onChangeEffectsVolume: function _onChangeEffectsVolume() {
        this.audioIdList.forEach(function (audioId) {
            cc.audioEngine.setVolume(audioId, data.effectsVolume);
        });
    }
});

// resume background music
cc.game.on(cc.game.EVENT_HIDE, function () {
    AudioManager.instance.resumeMusic();
});

// global instance
AudioManager.instance = new AudioManager();
AudioManager.instance.setMusicVolume(AudioManager.instance.getMusicVolume());
AudioManager.instance.setEffectsVolume(AudioManager.instance.getEffectsVolume());

module.exports = AudioManager;

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","Utils":"Utils"}],"AuthUser":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4ed87oXbFtPMZEsuH6c8gT6', 'AuthUser');
// scripts\AuthUser.js

var EventDispatcher = require('EventDispatcher'),
    CommonConstant = require('CommonConstant'),
    EventDispatcherConstant = require('EventDispatcherConstant');

var AuthUser = {
    updateInfo: function updateInfo(userInfo) {
        cc.js.mixin(this, userInfo);
    }
};

EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, function (params) {
    if (params && params.username === AuthUser.username) {
        AuthUser.currencies[params.currency].balance = params.money;
    }
});

EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_EXP, function (params) {
    if (params && params.username === AuthUser.username) {
        AuthUser.experience = AuthUser.experience || 0;
        AuthUser.experience += params.exp;
    }
});

EventDispatcher.addEventListener(CommonConstant.PushMessageType.UPDATE_USER_INFO.EVENT, function (params) {
    if (params && params.content) {
        AuthUser.updateInfo(JSON.parse(params.content));
        EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_UNREAD_MESS_COUNT);
    }
});

module.exports = AuthUser;

cc._RFpop();
},{"CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant"}],"BaseGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2fd10Yzj6FL/6HQIbpYmqVi', 'BaseGameManager');
// scripts\games\BaseGameManager.js

var NetworkManager = require('NetworkManager'),
    EventDispatcher = require('EventDispatcher'),
    SmartFoxConstant = require('SmartFoxConstant'),
    UiManager = require('UiManager'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    GameManagerConstant = require('GameManagerConstant'),
    TinhNangManager = require('TinhNangManager'),
    Player = require('Player'),
    LOCAL_EVENT = {
    UPDATE_USER_MONEY: 'game_manager.private.profile.update_money',
    UPDATE_USER_EXP: 'game_manager.private.profile.update_exp'
},
    BaseGameManager;

/**
 * Base class to manage game logic.
 *
 * Dispatcher types:
 *     - Event:  ~command (such as 'play')
 *     - Action: ~action  (such as 'bet', 'withdraw')
 *
 * Currency types:
 *     - Support single/multiple currencies.
 *
 * Player (sitting and standing):
 *     - username
 *     - avatar
 *     - displayName
 *     - money
 *     - currency
 *
 *     // optional
 *     - slot
 *     - handSize
 *     - isMaster
 *     - isRegisteredToQuitGame
 *     - ...
 *
 *
 * @param {Object} game            game object
 * @param {Number} roomId          id of room which game manager belongs to
 */
BaseGameManager = Utils.Class({

    $$constructor: function $$constructor(game, roomId) {
        this.DELAYED_COMMANDS = [SmartFoxConstant.Command.MESSAGE.ID, SmartFoxConstant.Command.PLAY.ID, SmartFoxConstant.Command.FINISH_GAME.ID, SmartFoxConstant.Command.DEAL_CARD.ID, SmartFoxConstant.Command.TURN.ID, SmartFoxConstant.Command.WAITING_DEAL_CARD.ID];

        this.gameCmd = game.CONFIG.CMD;
        this.roomId = roomId;
        this.logEnabled = game.CONFIG.LOG;
        this.gameId = game.CONFIG.ID;
        this.visibleSlots = game.CONFIG.VISIBLE_SLOTS;
        this.warningMessageDuration = game.CONFIG.WARNING_MESSAGE_DURATION;
        this.fee = 0;
        this._saveMatchId(0);
        this.eventDispatchers = {
            globalCmd: EventDispatcher.create(true),
            // anyCmd: EventDispatcher.create(true),
            anyCmd: EventDispatcher.createStackEventDispatcher(game.CONFIG.MAX_COMMANDS_PER_MATCH || 50),
            playCmd: EventDispatcher.create(true),
            local: EventDispatcher.create(true),
            _private: EventDispatcher.create(true)
        };
        this._reinitPlayersInfo();
        this._reinitBettingInfo();

        if (game.CONFIG.ALONE) {
            this._addCurrentUserToPlayers();
        }

        this._onExtensionHandlerBinding = this._onExtensionHandler.bind(this);
        NetworkManager.SmartFox.addExtensionHandler(this.gameCmd, this._onExtensionHandlerBinding);

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.MESSAGE.ID, this._onMessage, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.KICK_PLAYER.ID, this._onKickPlayer, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAYER_ADDED.ID, this._onPlayerAdded, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAYER_REMOVED.ID, this._onPlayerRemoved, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_PLAYER_ADDED.ID, this._onWaitingPlayerAdded, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_PLAYER_REMOVED.ID, this._onWaitingPlayerRemoved, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REG_QUIT_GAME.ID, this._onRegisterQuitGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.DEREG_QUIT_GAME.ID, this._onDeregisterQuitGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this._onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this._onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_USER_INFO.ID, this._onUpdateUserInfo, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAY.ID, this._onPlay, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.NEW_MATCH.ID, this._onNewMatch, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REQUEST_BANKER.ID, this._onSetBanker, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.BANKER_RESIGN.ID, this._onRemoveBanker, this);

        if (game.CONFIG.BUY_MONEY) {
            this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_PRIVATE_USER_MONEY.ID, this._onUpdateUserPrivateMoney, this);
        } else {
            this.eventDispatchers._private.addEventListener(LOCAL_EVENT.UPDATE_USER_MONEY, this._onUpdateUserMoney, this);
            EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this._onUpdateUserMoney, this);
        }

        this.log('[BaseGameManager] GameCMD: ' + this.gameCmd + ', RoomID: ' + this.roomId);
    },

    startGame: function startGame() {},

    destroy: function destroy() {
        this._clearEventDispatchers();
        this._reinitPlayersInfo();
        this._reinitBettingInfo();

        NetworkManager.SmartFox.removeExtensionHandler(this.gameCmd, this._onExtensionHandlerBinding);
    },

    isCurrentPlayer: function isCurrentPlayer(playerOrPlayerName) {
        var playerName = null;
        if (Utils.Type.isObject(playerOrPlayerName)) {
            playerName = playerOrPlayerName.username || playerOrPlayerName.userName;
        }
        if (!playerName) {
            playerName = playerOrPlayerName;
        }
        if (playerName && this.current.player && this.current.player.data.username === playerName) {
            return true;
        }
        return false;
    },

    disableEventDispatchersCache: function disableEventDispatchersCache() {
        this.eventDispatchers.local.disableCache();
        this.eventDispatchers.globalCmd.disableCache();
        // this.eventDispatchers.anyCmd.disableCache();
        this.eventDispatchers.playCmd.disableCache();
        this.eventDispatchers._private.disableCache();
    },

    isNewMatch: function isNewMatch(matchId) {
        matchId = this._parseMatchId(matchId);
        if (matchId >= 0 && this.matchInfo.matchId >= 0 && this.matchInfo.matchId !== matchId) {
            return true;
        }
        return false;
    },

    /**
     * Fake add player message. It's useful in rare case, so use it carefully.
     *
     * @param {Object} playerData playerData
     */
    addPlayerFromData: function addPlayerFromData(playerData) {
        this._onPlayerAdded({
            player: playerData
        });
    },

    removePlayerByUsername: function removePlayerByUsername(username) {
        if (username) {
            var params = {
                player: {
                    username: username
                }
            };
            if (!this._onPlayerRemoved(params)) {
                this._onWaitingPlayerRemoved(params);
            }
        }
    },

    openHelpModal: function openHelpModal() {
        var self = this;
        cc.loader.loadRes('HelpModal', function (err, prefab) {
            var newNode = cc.instantiate(prefab);
            var modalComp = newNode.getComponent('GameHelpModal'),
                scrollViewComp = newNode.getComponentInChildren(cc.ScrollView);
            if (scrollViewComp) {
                scrollViewComp.scrollToTop();
            }
            modalComp.init(self.gameId);
            cc.director.getScene().addChild(newNode);
        });
    },

    /**
     * Call when player want to rejoin a room without leave-then-join actual room.
     */
    fetchInitialGameData: function fetchInitialGameData() {
        this.requestRefreshGame();
    },

    _clearEventDispatchers: function _clearEventDispatchers() {
        this.eventDispatchers.local.clear();
        this.eventDispatchers.globalCmd.clear();
        this.eventDispatchers.anyCmd.clear();
        this.eventDispatchers.playCmd.clear();
        this.eventDispatchers._private.clear();
    },

    _reinitPlayersInfo: function _reinitPlayersInfo() {
        this.current = {};
        this.players = {};
        this.waitingPlayers = {};
    },

    _reinitBettingInfo: function _reinitBettingInfo() {
        this.bettingInfo = {};
    },

    _addCurrentUserToPlayers: function _addCurrentUserToPlayers() {
        this._onPlayerAdded({
            player: {
                userName: AuthUser.username
            }
        });
    },

    _parseMatchId: function _parseMatchId(matchId) {
        try {
            return parseInt(matchId);
        } catch (e) {}
    },

    _saveMatchId: function _saveMatchId(matchId) {
        this.matchInfo = {
            matchId: matchId,
            time: Date.now()
        };
    },

    // ============================================================
    // Send API
    // ============================================================

    send: function send(params) {
        this.log('[' + this.gameCmd + ', ' + this.roomId + '] [send]', params);
        NetworkManager.SmartFox.sendExtensionRequest(this.gameCmd, params, this.roomId);
    },

    requestRefreshGame: function requestRefreshGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.REFRESH_GAME.ID)
        });
    },

    sendRequestBanker: function sendRequestBanker() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.REQUEST_BANKER.ID)
        });
    },

    registerQuitGame: function registerQuitGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.REG_QUIT_GAME.ID)
        });
    },

    deregisterQuitGame: function deregisterQuitGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.DEREG_QUIT_GAME.ID)
        });
    },

    sendChatMessage: function sendChatMessage(message) {
        NetworkManager.SmartFox.sendPublicMessageRequest(message, this.roomId);
    },

    leaveRoom: function leaveRoom() {
        NetworkManager.SmartFox.leaveRoom(this.roomId);
    },

    // ============================================================
    // Receive API
    // ============================================================

    _onExtensionHandler: function _onExtensionHandler(event) {
        var sourceRoom = event.sourceRoom,
            params = event.params || {},
            cmd = params.command;
        if (Utils.Type.isDefined(cmd)) {
            if (sourceRoom === this.roomId) {
                if ('timeForAnimation' in params) {
                    Utils.Object.replaceProperty(params, 'timeForAnimation', 'time');
                }
                if ('userName' in params) {
                    Utils.Object.replaceProperty(params, 'userName', 'username');
                }

                var players = params.allData && params.allData.players,
                    waitingPlayers = params.allData && params.allData.waitingPlayers;

                if (players) {
                    this._updatePlayersData(players, this.players);
                }
                if (waitingPlayers) {
                    this._updatePlayersData(waitingPlayers, this.waitingPlayers);
                }

                if (this.DELAYED_COMMANDS.indexOf(cmd) === -1) {
                    this.eventDispatchers.anyCmd.dispatchEvent(cmd, params);
                    this.log('[' + this.gameCmd + ', ' + this.roomId + '] [receive] [exec]', params);
                } else {
                    this.eventDispatchers.anyCmd.pushEvent(cmd, params);
                    this.log('[' + this.gameCmd + ', ' + this.roomId + '] [receive] [stack]', params);
                }
            } else if (!sourceRoom) {
                this.eventDispatchers.globalCmd.dispatchEvent(cmd, params);
                this.log('[' + this.gameCmd + ', ' + this.roomId + '] [receive] [global]', params);
            }
        }
    },

    _onNewMatch: function _onNewMatch(params) {
        var matchId = this._parseMatchId(params && params.matchId);
        if (matchId >= 0) {
            this._saveMatchId(matchId);
            if (!Utils.Game.isFocus()) {
                this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.NEW_MATCH_LOST_FOCUS);
            }
        }
    },

    _onPlay: function _onPlay(params) {
        var action = params.action;
        if (Utils.Type.isDefined(action)) {
            this.eventDispatchers.playCmd.dispatchEvent(action, params);
        }
    },

    _onMessage: function _onMessage(params) {
        UiManager.openWarningMessage(params && params.content, this.warningMessageDuration);
    },

    _onKickPlayer: function _onKickPlayer(params) {
        if (this.isCurrentPlayer(params.username)) {
            var reasonId = params.reasonId;
            if (reasonId === SmartFoxConstant.KickReason.NOT_ENOUGH_MONEY && TinhNangManager.choPhep('nt')) {
                UiManager.openConfirmModal(params.msg, {
                    isPersistent: true,
                    oke_fn: function oke_fn() {
                        UiManager.openNapXienModal();
                    }
                });
            } else {
                UiManager.openModal(params.msg);
            }
        }
    },

    _onPlayerAdded: function _onPlayerAdded(params) {
        var player = this._addPlayerToCollection(params.player, this.players);
        if (player) {
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.PLAYER_ADDED, player);
            return true;
        }
        return false;
    },

    _onPlayerRemoved: function _onPlayerRemoved(params) {
        var player = this._removePlayerFromCollection(params.player, this.players);
        if (player) {
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.PLAYER_REMOVED, player);
            return true;
        }
        return false;
    },

    _onWaitingPlayerAdded: function _onWaitingPlayerAdded(params) {
        var player = this._addPlayerToCollection(params.player, this.waitingPlayers);
        if (player) {
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.WAITING_PLAYER_ADDED, player);
            return true;
        }
        return false;
    },

    _onWaitingPlayerRemoved: function _onWaitingPlayerRemoved(params) {
        var player = this._removePlayerFromCollection(params.player, this.waitingPlayers);
        if (player) {
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.WAITING_PLAYER_REMOVED, player);
            return true;
        }
        return false;
    },

    _addPlayerToCollection: function _addPlayerToCollection(playerData, collection) {
        if (collection && playerData) {
            if ('userName' in playerData) {
                Utils.Object.replaceProperty(playerData, 'userName', 'username');
            }
            if ('slotIndex' in playerData) {
                Utils.Object.replaceProperty(playerData, 'slotIndex', 'slot');
            }
            if (cc.sys.isBrowser && location.protocol === 'https:' && playerData.avatar) {
                playerData.avatar = playerData.avatar.replace(/^http:/, 'https:');
            }

            var p = collection[playerData.username];
            if (p) {
                p.update(playerData);
            } else {
                p = new Player(playerData);
                if (playerData.username === AuthUser.username) {
                    this.current.player = p;
                }
                collection[playerData.username] = p;
            }
            return p;
        }
        return null;
    },

    _removePlayerFromCollection: function _removePlayerFromCollection(playerData, collection) {
        if (collection && playerData) {
            if ('userName' in playerData) {
                Utils.Object.replaceProperty(playerData, 'userName', 'username');
            }

            var p = collection[playerData.username];
            delete collection[playerData.username];
            return p;
        }
        return null;
    },

    _onSetBanker: function _onSetBanker(params) {
        if (params && params.bankerInfo) {
            if (this.isCurrentPlayer(params.bankerInfo)) {
                this.isMaster = true;
            }
            if (params.bankerInfo) {
                params.bankerInfo.slot = this.visibleSlots;
                this.addPlayerFromData(params.bankerInfo);
            }
        }
    },

    _onRemoveBanker: function _onRemoveBanker(params) {
        this.removePlayerByUsername(params.player);
    },

    _onRegisterQuitGame: function _onRegisterQuitGame(params) {
        if (this.isCurrentPlayer(params.username)) {
            this.current.player.data.isRegisteredToQuitGame = true;
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.UPDATE_REGISTER_QUIT_GAME_STATUS);
        }
    },

    _onDeregisterQuitGame: function _onDeregisterQuitGame(params) {
        if (this.isCurrentPlayer(params.username)) {
            this.current.player.data.isRegisteredToQuitGame = false;
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.UPDATE_REGISTER_QUIT_GAME_STATUS);
        }
    },

    _onUpdateGame: function _onUpdateGame(params) {
        var players = params.players || params.allData && params.allData.players,
            waitingPlayers = params.waitingPlayers || params.allData && params.allData.waitingPlayers,
            bettingValues = params.bettingValues || params.data && params.data.bettingValues,
            betting,
            currency,
            banker,
            i;
        if (!params.bettingValues || Utils.Type.isArray(bettingValues)) {
            betting = params.betting || params.data && params.data.betting;
            currency = params.currency || params.data && params.data.currency;
            // single currency
            this.bettingInfo = {
                betting: betting,
                bettingValues: bettingValues,
                currency: currency
            };
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.UPDATE_BETTING_VALUES);
        } else if (Utils.Type.isObject(bettingValues)) {
            // multiple currencies
            this.bettingInfo = bettingValues;
            this.eventDispatchers.local.dispatchEvent(GameManagerConstant.Event.UPDATE_BETTING_VALUES);
        }

        if (params.banker && params.banker.userName) {
            params.banker.slot = this.visibleSlots;
            if (AuthUser.username === params.banker.userName) {
                this.isMaster = true;
                this.addPlayerFromData(params.banker);
            } else {
                banker = params.banker;
            }
        }

        if (players) {
            for (i = 0; i < players.length; i += 1) {
                if (AuthUser.username === (players[i].username || players[i].userName)) {
                    this._onPlayerAdded({
                        player: players[i]
                    });
                    break;
                }
            }
            for (i = 0; i < players.length; i += 1) {
                if (AuthUser.username !== (players[i].username || players[i].userName)) {
                    this._onPlayerAdded({
                        player: players[i]
                    });
                }
            }
        }

        if (waitingPlayers) {
            for (i = 0; i < waitingPlayers.length; i += 1) {
                this._onWaitingPlayerAdded({
                    player: waitingPlayers[i]
                });
            }
        }

        if (banker) {
            this.addPlayerFromData(banker);
        }

        this.fee = params.fee || params.data && params.data.fee || 0;
    },

    _onUpdateUserInfo: function _onUpdateUserInfo(params) {
        if (params) {
            var eventDispatcher, updateMoneyEventName, updateExpEventName;
            if (AuthUser.username === params.username) {
                eventDispatcher = EventDispatcher;
                updateMoneyEventName = EventDispatcherConstant.PROFILE.UPDATE_MONEY;
                updateExpEventName = EventDispatcherConstant.PROFILE.UPDATE_EXP;
            } else {
                eventDispatcher = this.eventDispatchers._private;
                updateMoneyEventName = LOCAL_EVENT.UPDATE_USER_MONEY;
                updateExpEventName = LOCAL_EVENT.UPDATE_USER_EXP;
            }

            if (params.field === 'money') {
                eventDispatcher.dispatchEvent(updateMoneyEventName, {
                    username: params.username,
                    currency: params.currency,
                    money: params.value
                });
            } else if (params.field === 'expChange') {
                eventDispatcher.dispatchEvent(updateExpEventName, {
                    username: params.username,
                    exp: params.value
                });
            }
        }
    },

    _onUpdateUserMoney: function _onUpdateUserMoney(params) {
        this._onUpdateUserMoneyByType(params, GameManagerConstant.Event.UPDATE_USER_MONEY);
    },

    _onUpdateUserPrivateMoney: function _onUpdateUserPrivateMoney(params) {
        this._onUpdateUserMoneyByType(params, null);
    },

    _onUpdateUserMoneyByType: function _onUpdateUserMoneyByType(params, dispatchEventName) {
        if (params) {
            if (!this._updateUserMoneyInCollectionByType(params, this.players, dispatchEventName)) {
                this._updateUserMoneyInCollectionByType(params, this.waitingPlayers, dispatchEventName);
            }
        }
    },

    _updateUserMoneyInCollectionByType: function _updateUserMoneyInCollectionByType(params, collection, dispatchEventName) {
        if (collection && params) {
            var player = collection[params.username];
            if (player && player.data && player.data.currency === params.currency) {
                player.setMoney(params.money);
            }
            if (dispatchEventName) {
                this.eventDispatchers.local.dispatchEvent(dispatchEventName, params);
            }
            return true;
        }
        return false;
    },

    _updatePlayersData: function _updatePlayersData(playersData, collection) {
        var isPlayerList = collection === this.players,
            addPlayerFn = isPlayerList ? this._onPlayerAdded.bind(this) : this._onWaitingPlayerAdded.bind(this),
            removePlayerFn = isPlayerList ? this._onPlayerRemoved.bind(this) : this._onWaitingPlayerRemoved.bind(this),
            oldPlayerNameList = Object.getOwnPropertyNames(collection),
            newPlayerNameList = [],
            compareResult,
            playerData,
            player,
            i;

        for (i = 0; i < playersData.length; i += 1) {
            playerData = playersData[i];
            if ('userName' in playerData) {
                Utils.Object.replaceProperty(playerData, 'userName', 'username');
            }
            newPlayerNameList.push(playerData.username);
        }

        compareResult = Utils.Set.compare(oldPlayerNameList, newPlayerNameList);

        for (i = 0; i < compareResult.diff12.length; i += 1) {
            removePlayerFn({
                player: Utils.Object.findObject(playersData, 'username', compareResult.diff12[i])
            });
        }

        for (i = 0; i < compareResult.diff21.length; i += 1) {
            if (AuthUser.username === compareResult.diff21[i]) {
                addPlayerFn({
                    player: Utils.Object.findObject(playersData, 'username', compareResult.diff21[i])
                });
            }
        }
        for (i = 0; i < compareResult.diff21.length; i += 1) {
            if (AuthUser.username !== compareResult.diff21[i]) {
                addPlayerFn({
                    player: Utils.Object.findObject(playersData, 'username', compareResult.diff21[i])
                });
            }
        }

        for (i = 0; i < playersData.length; i += 1) {
            playerData = playersData[i];
            if (compareResult.same.indexOf(playerData.username) > -1) {
                player = collection[playerData.username];
                if (player) {
                    player.update(playerData);
                }
            }
        }
    }

});

['info', 'log', 'warn', 'error'].forEach(function (logLevel) {
    BaseGameManager.prototype[logLevel] = (function (logLevel) {
        return function () {
            if (this.logEnabled) {
                cc[logLevel].apply(cc, ['[' + Utils.Date.currentTime() + ']'].concat(Array.prototype.slice.call(arguments)));
            }
        };
    })(logLevel);
});

module.exports = BaseGameManager;

cc._RFpop();
},{"AuthUser":"AuthUser","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameManagerConstant":"GameManagerConstant","NetworkManager":"NetworkManager","Player":"Player","SmartFoxConstant":"SmartFoxConstant","TinhNangManager":"TinhNangManager","UiManager":"UiManager","Utils":"Utils"}],"BaseGameOptionModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8e9e4hy8edJFbuxkhAlSUXk', 'BaseGameOptionModal');
// scripts\components\games\lobby\option\BaseGameOptionModal.js

var GameManager = require('GameManager'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(gameId, gameConfigs, delayEnterGameFn) {
        this.gameId = gameId;
        this.gameConfigs = gameConfigs;

        // function (gameConfigs, enterGameFn) {}
        this.delayEnterGameFn = delayEnterGameFn;
    },

    enterGame: function enterGame() {
        var self = this;
        if (self.gameId && self.gameConfigs) {
            if (Utils.Type.isFunction(self.delayEnterGameFn)) {
                self.delayEnterGameFn(self.gameConfigs, (function (gameId, gameConfigs) {
                    return function enterGameFn() {
                        GameManager.enterGame(gameId, gameConfigs);
                    };
                })(self.gameId, self.gameConfigs));
            } else {
                GameManager.enterGame(self.gameId, self.gameConfigs);
            }
        }
        self.node.destroy();
    }
});

cc._RFpop();
},{"GameManager":"GameManager","Utils":"Utils"}],"BaseGameplay":[function(require,module,exports){
"use strict";
cc._RFpush(module, '372e5/sReBP/oiaUHqBzNrX', 'BaseGameplay');
// scripts\components\games\BaseGameplay.js

var GameManager = require('GameManager'),
    AudioManager = require('AudioManager'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        if (!this.gameCmd) {
            throw '"gameCmd" must be specified in "properties"';
        }

        this.gameRuntimeConfigs = GameManager.getGameRuntimeConfigs(this.gameCmd);
        if (this.gameRuntimeConfigs) {
            this.gameManager = this.gameRuntimeConfigs.gameManager;
            if (!this.gameManager) {
                throw 'Game manager of game whose gameCmd ' + this.gameCmd + ' could not be found';
            }
        } else {
            throw 'Game runtime configs of game whose gameCmd ' + this.gameCmd + ' could not be found';
        }

        this.audioManager = new AudioManager({
            effectPlayableFn: (function () {
                return this.node.active;
            }).bind(this)
        });

        this._timeoutList = [];
        this._timeoutMap = {};
        this._intervalList = [];
        this._intervalMap = {};

        this.$onLoadScene();

        this.gameManager.disableEventDispatchersCache();

        cc.game.on(cc.game.EVENT_SHOW, this.$onFocus, this);
        cc.game.on(cc.game.EVENT_HIDE, this.$onLostFocus, this);
    },

    onDestroy: function onDestroy() {
        if (this.gameManager) {
            this.gameManager.destroy();
            this.$onDestroyScene();
        }

        if (this.audioManager) {
            this.audioManager.destroy();
        }

        this._timeoutList.forEach(function (id) {
            clearTimeout(id);
        });
        this._intervalList.forEach(function (id) {
            clearInterval(id);
        });

        var key;
        for (key in this._timeoutMap) {
            clearTimeout(this._timeoutMap[key]);
        }
        for (key in this._intervalMap) {
            clearInterval(this._intervalMap[key]);
        }

        cc.game.off(cc.game.EVENT_SHOW, this.$onFocus, this);
        cc.game.off(cc.game.EVENT_HIDE, this.$onLostFocus, this);
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var now = Date.now(),
            gameManager = this.gameManager,
            lastFrameTime = now - dt * 1000,
            newMatchTime = gameManager && gameManager.matchInfo && gameManager.matchInfo.time;
        if (gameManager) {
            gameManager.eventDispatchers.anyCmd.dispatchEvents(function (event) {
                if (event && event.eventName && event.obj && event.time >= 0) {
                    if (!gameManager.isNewMatch(event.obj.matchId) || (lastFrameTime >= newMatchTime ? false : lastFrameTime <= event.time && event.time <= newMatchTime)) {
                        if (Utils.Type.isObject(event.obj)) {
                            event.obj.__execInfo__ = {
                                dt: now - event.time
                            };
                        }
                        return true;
                    }
                    return false;
                }
            });
            this.$onUpdate(dt);
        }
    },

    $onLoadScene: function $onLoadScene() {
        this.$onLoad();
    },

    $onLoad: function $onLoad() {},

    $onDestroyScene: function $onDestroyScene() {
        this.$onDestroy();
    },

    $onDestroy: function $onDestroy() {},

    // $onUpdate: function (dt) {}
    $onUpdate: function $onUpdate() {},

    $onFocus: function $onFocus() {},

    $onLostFocus: function $onLostFocus() {},

    addTimeout: function addTimeout(key, id) {
        if (Utils.Type.isUndefined(id)) {
            this._timeoutList.push(key);
        } else if (key) {
            clearTimeout(this._timeoutMap[key]);
            this._timeoutMap[key] = id;
        } else {
            throw 'Key must be specified';
        }
    },

    addInterval: function addInterval(key, id) {
        if (Utils.Type.isUndefined(id)) {
            this._intervalList.push(key);
        } else if (key) {
            clearInterval(this._intervalMap[key]);
            this._intervalMap[key] = id;
        } else {
            throw 'Key must be specified';
        }
    }
});

cc._RFpop();
},{"AudioManager":"AudioManager","GameManager":"GameManager","Utils":"Utils"}],"BaseMainGameplay":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd6eaewGSaBAHY1VZPN9iOAD', 'BaseMainGameplay');
// scripts\components\games\BaseMainGameplay.js

var PlayerUI = require('PlayerUI'),
    Utils = require('Utils'),
    BaseGameplay = require('BaseGameplay'),
    GameManagerConstant = require('GameManagerConstant'),
    TopPanelInGame = require('TopPanelInGame');

cc.Class({
    'extends': BaseGameplay,

    properties: {
        playerNodeList: {
            'default': [],
            type: PlayerUI
        },
        playerSoloNodeList: {
            'default': [],
            type: PlayerUI
        },
        fixedMainUserPosition: false,
        reservedLastPosition: false
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    $onLoadScene: function $onLoadScene() {
        var game = this.gameRuntimeConfigs.game,
            self = this,
            compareResult,
            i;

        // solo game
        if (game && game.isSolo && this.playerSoloNodeList.length === 2) {
            // keep only two slots
            compareResult = Utils.Set.compare(this.playerNodeList, this.playerSoloNodeList);
            for (i = 0; i < compareResult.diff12.length; i += 1) {
                compareResult.diff12[i].node.active = false;
            }
            this.playerNodeList = this.playerSoloNodeList;
        }

        for (i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].removePlayer();
        }

        this.mainUserPositionIndex = -1;
        this._mainUserPositionIndex = -1;

        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.PLAYER_ADDED, this._onPlayerAdded, this);
        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.PLAYER_REMOVED, this._onPlayerRemoved, this);

        this.topPanelInGameData = {};
        this.$onLoad();

        // Top panel ingame
        this.topPanelInGame = this.node.getComponentInChildren(TopPanelInGame);
        if (this.topPanelInGame) {
            this.topPanelInGame.init(this);
        } else {
            var configs = game && game.CONFIG && game.CONFIG.TOP_PANEL_IN_GAME;
            if (configs && configs.ENABLE) {
                cc.loader.loadRes('games/ui/TopPanelInGame', function (err, prefab) {
                    var newNode = cc.instantiate(prefab);
                    self.node.addChild(newNode);
                    self.topPanelInGame = newNode.getComponent(TopPanelInGame);
                    self.topPanelInGame.init(self);
                });
            }
        }
    },

    $onLoad: function $onLoad() {},

    findPlayerNodeByName: function findPlayerNodeByName(username) {
        var playerNode, player, i;
        for (i = 0; i < this.playerNodeList.length; i += 1) {
            playerNode = this.playerNodeList[i];
            player = playerNode.player;
            if (username && username === (player && player.data && player.data.username)) {
                return playerNode;
            }
        }
        return null;
    },

    findPlayerNodeByIndex: function findPlayerNodeByIndex(index) {
        // fixed position
        if (this.fixedMainUserPosition && this.mainUserPositionIndex >= 0) {
            // not in reserved mode or not reserved position
            if (!this.reservedLastPosition || index !== this.playerNodeList.length - 1) {
                // transition
                if (this.reservedLastPosition && this._mainUserPositionIndex >= 0) {
                    index -= this._mainUserPositionIndex;
                } else {
                    index -= this.mainUserPositionIndex;
                }

                if (index < 0) {
                    index += this.playerNodeList.length;
                    // not count reserved position
                    if (this.reservedLastPosition) {
                        index -= 1;
                    }
                }
            }
        }
        return this.playerNodeList[index];
    },

    _onPlayerAdded: function _onPlayerAdded(player) {
        if (player && player.data) {
            if (this.fixedMainUserPosition) {
                if (player.isMe()) {
                    this.mainUserPositionIndex = player.data.slot;
                    if (this._mainUserPositionIndex < 0) {
                        this._mainUserPositionIndex = this.mainUserPositionIndex;
                    }
                } else if (this.mainUserPositionIndex < 0) {
                    throw 'Must set position for main user first';
                }
            }

            this.audioManager.playPlayerJoinRoom();
            var playerNode = this.findPlayerNodeByIndex(player.data.slot);
            if (playerNode && playerNode.player !== player) {
                this._executeMethod('onPrePlayerAdded', playerNode, player);
                playerNode.setPlayer(player);
                this._executeMethod('onPostPlayerAdded', playerNode);
            }
        }
    },

    _onPlayerRemoved: function _onPlayerRemoved(player) {
        if (player && player.data) {
            var playerNode = this.findPlayerNodeByName(player.data.username);
            if (playerNode && playerNode.player === player) {
                this.audioManager.playPlayerLeaveRoom();
                this._executeMethod('onPrePlayerRemoved', playerNode);
                playerNode.removePlayer();
                this._executeMethod('onPostPlayerRemoved', playerNode, player);
            }
        }
    },

    _executeMethod: function _executeMethod(methodName) {
        var method = this[methodName],
            params;
        if (Utils.Type.isFunction(method)) {
            params = Array.prototype.slice.call(arguments);
            params.shift();
            try {
                method.apply(this, params);
            } catch (e) {
                cc.error(e);
            }
        }
    }
});

cc._RFpop();
},{"BaseGameplay":"BaseGameplay","GameManagerConstant":"GameManagerConstant","PlayerUI":"PlayerUI","TopPanelInGame":"TopPanelInGame","Utils":"Utils"}],"BaseMinigameGameplay":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f7e23bB7jBLq6eEJr2XTQJL', 'BaseMinigameGameplay');
// scripts\components\games\BaseMinigameGameplay.js

var CommonConstant = require('CommonConstant'),
    BaseGameplay = require('BaseGameplay');

cc.Class({
    'extends': BaseGameplay,

    properties: {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    start: function start() {
        this.node.zIndex = CommonConstant.ZINDEX.MINIGAME_PREFAB;
    },

    $onLoadScene: function $onLoadScene() {
        this.$onLoad();
    },

    $onLoad: function $onLoad() {}
});

cc._RFpop();
},{"BaseGameplay":"BaseGameplay","CommonConstant":"CommonConstant"}],"BauCuaBuyPot":[function(require,module,exports){
"use strict";
cc._RFpush(module, '29621TkbvxGOa+Mp2J+IRpW', 'BauCuaBuyPot');
// scripts\components\games\bau_cua\BauCuaBuyPot.js

var BaseMainGameplay = require('BaseMainGameplay');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemSprite: cc.Sprite,
        moneyBuy: cc.Label,
        sceneScript: BaseMainGameplay
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.pot = 0;
    },

    setDataPot: function setDataPot(sprFrame, money, pot) {
        this.itemSprite.spriteFrame = sprFrame;
        this.moneyBuy.string = money;
        this.pot = pot;
    },

    onClickBuyPot: function onClickBuyPot() {
        //this.sceneScript.gameManager.sendBuyPot(this.pot);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"BaseMainGameplay":"BaseMainGameplay"}],"BauCuaConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd7f0bUA5bZFOYS2i1lFbr5I', 'BauCuaConstant');
// scripts\games\bau_cua\BauCuaConstant.js

var Utils = require('Utils');

module.exports = {
    Action: {
        BETTING: 1,
        CANCEL_BET: 2,
        TURN_MASTER: 3,
        MASTER_SELL_POT: 10,
        BUY_POT: 11,
        CHANGE_STATE: 5,
        UPDATE_POTS: 9,
        PING: 10
    },
    GameState: {
        NONE: 0,
        EFFECT: 1,
        PLAYER_BETTING: 2,
        MASTER_CANEL_BET: 3,
        FINISH: 4,
        FINALIZING: 5
    },
    ChipColor: {
        BLUE: {
            ID: 0,
            NAME: 'blue'
        },

        PURPLE: {
            ID: 1,
            NAME: 'purple'
        },

        GREEN: {
            ID: 2,
            NAME: 'green'
        },

        RED: {
            ID: 3,
            NAME: 'red'
        },

        findById: function findById(potId) {
            potId = parseInt(potId, 10);
            return Utils.Object.findObject(this, 'ID', potId);
        }
    },
    Event: {
        CHANGE_STATE: 'in_game.bau_cua.change_state',
        EFFECT_STATE: 'in_game.bau_cua.change_state.effect',
        PLAYER_BETTING_STATE: 'in_game.bau_cua.change_state.player_betting',
        UPDATE_POTS: 'in_game.bau_cua.update_pots',
        BETTING_SUCCESS: 'in_game.bau_cua.betting_success',
        SHAKE_BOW_DICE: 'in_game.bau_cua.shake',
        CANCEL_BET: 'in_game.bau_cua.cancel_bet',
        FINISH: 'in_game.bau_cua.finish',
        SELECT_CHIP: 'in_game.bau_cua.select_chip',
        ADD_LIST_BETTING: 'in_game.bau_cua.add_list_betting',
        ADD_BANKER: 'in_game.bau_cua.add_banker',
        SET_RATIO: 'in_game.bau_cua.set_ratio',
        BETTING_UPDATEGAME: 'in_game.bau_cua.betting_updategame',
        MASTER_CANEL_BET: 'in_game.bau_cua.master_cancel_bet',
        MASTER_SELL_POT: 'in_game.bau_cua.master_sell_pot'
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"BauCuaGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ab5f8us87VN35j7NOLi3gK/', 'BauCuaGameManager');
// scripts\games\bau_cua\BauCuaGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    BauCuaConstant = require('BauCuaConstant'),
    NetworkManager = require('NetworkManager'),
    BauCuaGameManager = require('BauCuaGameManager'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    BauCuaGameManager;

BauCuaGameManager = Utils.Class({
    $$extends: BaseGameManager,
    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this.currentBet = [];
        this.history = [];
        this.isMaster = false;
        this.bettingList = [];

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(BauCuaConstant.Action.BETTING, this.onBettingSuccess, this);
        this.eventDispatchers.playCmd.addEventListener(BauCuaConstant.Action.CHANGE_STATE, this.onChangeState, this);
        this.eventDispatchers.playCmd.addEventListener(BauCuaConstant.Action.CANCEL_BET, this.onCancelBetting, this);
        this.eventDispatchers.playCmd.addEventListener(BauCuaConstant.Action.MASTER_SELL_POT, this.bankerBuyPot, this);
    },

    // Send API
    //
    //
    sellBetCancelBet: function sellBetCancelBet(pot) {
        if (this.isMaster) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(BauCuaConstant.Action.MASTER_SELL_POT),
                pot: NetworkManager.SmartFox.type.byte(pot)
            });
        }
    },

    sendBuyPot: function sendBuyPot(pot) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(BauCuaConstant.Action.BUY_POT),
            pot: NetworkManager.SmartFox.type.byte(pot)
        });
    },

    sendBet: function sendBet(pot, moneyBet) {
        if (!this.isMaster && moneyBet > 0) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(BauCuaConstant.Action.BETTING),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(pot),
                money: NetworkManager.SmartFox.type.long(moneyBet)
            });
        }
    },

    sendReBet: function sendReBet() {
        for (var i = 0; i < this.history.length; i += 2) {
            this.sendBet(this.history[i], this.history[i + 1]);
        }
    },

    sendDoubleBet: function sendDoubleBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.sendBet(this.currentBet[i], this.currentBet[i + 1]);
        }
    },

    sendCancelBet: function sendCancelBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(BauCuaConstant.Action.CANCEL_BET),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(this.currentBet[i])
            });
        }
    },

    // End Send API
    //

    bankerBuyPot: function bankerBuyPot(params) {
        // {money: 200, action: 10, command: 20, pot: 0}
        if (!this.isMaster) {
            this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.MASTER_SELL_POT, params);
        }
    },

    countDowTime: function countDowTime(params) {
        return this._formatTime((params - Date.now()) / 1000);
    },

    onFinishGame: function onFinishGame(params) {
        //{time: 5000, players: Array[2], command: 30, dices: Array[4], potWin: Array[1]…}
        this._setGameState(BauCuaConstant.GameState.FINALIZING);
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.FINISH, params);
        if (this.currentBet.length > 0) {
            this.history = this.currentBet;
            this.currentBet = [];
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        this.bettingList = params.bettingValues;
        this._updateListBetting(params.bettingValues);
        this._updateRatio(params.potInfo);
        this.onChangeState(params);
        if (this.gameState !== BauCuaConstant.GameState.FINISH) {
            this._bettingUpdateGame(params.pots);
        }
    },

    _bettingUpdateGame: function _bettingUpdateGame(params) {
        for (var i = 0; i < params.length; i += 1) {
            this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.BETTING_UPDATEGAME, params[i]);
        }

        // if (this.isCurrentPlayer(params.username)) {
        //     this.currentBet.push(params.pot, params.money);
        // }
    },
    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 5, username: "ngohoangtrung85044"}
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.BETTING_SUCCESS, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet.push(params.pot, params.money);
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.CANCEL_BET, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet = [];
        }
    },
    onChangeState: function onChangeState(params) {
        this.warn('State ' + params.gameState);
        this._setGameState(params.gameState);
        switch (params.gameState) {
            case BauCuaConstant.GameState.EFFECT:
                this.onEfectShake(params);
                break;
            case BauCuaConstant.GameState.PLAYER_BETTING:
                this.onPlayerBetting(params);
                break;
            case BauCuaConstant.GameState.MASTER_CANEL_BET:
                this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.MASTER_CANEL_BET, params);
                break;
            default:
                break;
        }
    },

    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.CHANGE_STATE);
        }
    },

    onPlayerBetting: function onPlayerBetting(params) {
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.PLAYER_BETTING_STATE, params);
    },
    onEfectShake: function onEfectShake(params) {
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.SHAKE_BOW_DICE, params);
    },
    _updateRatio: function _updateRatio(params) {
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.SET_RATIO, params);
    },
    _updateListBetting: function _updateListBetting(params) {
        this.eventDispatchers.local.dispatchEvent(BauCuaConstant.Event.ADD_LIST_BETTING, params);
    },

    _formatTime: function _formatTime(elapsedTime) {
        if (elapsedTime >= 0) {
            elapsedTime = Math.floor(elapsedTime);
            var mins = Math.floor(elapsedTime / 60),
                seconds = elapsedTime % 60;
            return Utils.Number.fillZero(mins, 2) + ':' + Utils.Number.fillZero(seconds, 2);
        }
        return '00:00';
    }
});

module.exports = BauCuaGameManager;

cc._RFpop();
},{"AuthUser":"AuthUser","BaseGameManager":"BaseGameManager","BauCuaConstant":"BauCuaConstant","BauCuaGameManager":"BauCuaGameManager","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"Boot":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2c81brkjrlACYFnwAkW+KVL', 'Boot');
// scripts\components\Boot.js

var Url = require('Url'),
    Utils = require('Utils'),
    SysConfig = require('SysConfig'),
    IplayHttp = require('IplayHttp'),
    CommonConstant = require('CommonConstant'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        cpEditBox: cc.EditBox,
        httpHostEditBox: cc.EditBox,
        httpPortEditBox: cc.EditBox,
        usernameEditBox: cc.EditBox,
        passwordEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.cpEditBox.string = SysConfig.CP;
        this.httpHostEditBox.string = SysConfig.IplayHttp.HOST;
        this.httpPortEditBox.string = SysConfig.IplayHttp.PORT;
        this.usernameEditBox.string = Utils.Cookie.get(SysConfig.CookieName.USERNAME) || 'test1';
        this.passwordEditBox.string = '123456';
    },

    startGame: function startGame() {
        var httpConfig = SysConfig.IplayHttp;
        SysConfig.CP = this.cpEditBox.string;
        httpConfig.HOST = this.httpHostEditBox.string;
        httpConfig.PORT = this.httpPortEditBox.string;
        IplayHttp.init(httpConfig.HOST, httpConfig.PORT, httpConfig.PROTOCOL, httpConfig.AUTH_USER, httpConfig.AUTH_PASS);

        NetworkManager.Http.fetch('POST', Url.Http.USER_LOGIN, {
            username: this.usernameEditBox.string,
            password: this.passwordEditBox.string,
            devtoken: 'devtoken',
            game: SysConfig.GAME,
            platform: SysConfig.PLATFORM
        }).success(function (loginResp) {
            Utils.Cookie.set(SysConfig.CookieName.USERNAME, loginResp.data.username, 365, '/');
            Utils.Cookie.set(SysConfig.CookieName.ACCESSTOKEN, loginResp.data.accesstoken, 365, '/');
            Utils.Director.loadScene(CommonConstant.Scene.SPLASH);
        });
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","IplayHttp":"IplayHttp","NetworkManager":"NetworkManager","SysConfig":"SysConfig","Url":"Url","Utils":"Utils"}],"ButtonMaterial":[function(require,module,exports){
"use strict";
cc._RFpush(module, '28531Td8pdP0p4+dj4uFpr3', 'ButtonMaterial');
// scripts\ui\ButtonMaterial.js

var Utils = require('Utils'),
    AnimationManager = require('AnimationManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        duration: 0.1,
        color: cc.Color.WHITE,
        opacity: 80
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.stopFn = null;
        this.isTouching = false;
        this.isAnimating = false;
        this.onFinishAnimationBinding = this.onFinishAnimation.bind(this);
        if (this.node) {
            this.node.on(cc.Node.EventType.TOUCH_START, function (event) {
                this.stopAnimation();

                var button = this.getComponent(cc.Button);
                if (button && button.interactable) {
                    this.isTouching = true;
                    this.isAnimating = true;

                    var touchLocation = event.currentTarget.convertToNodeSpace(event.getLocation());
                    this.stopFn = AnimationManager.fillRadial(this.node, touchLocation, {
                        duration: this.duration,
                        isStopManually: true,
                        finishCallback: this.onFinishAnimationBinding,
                        color: this.color,
                        opacity: this.opacity
                    });
                }
            }, this);

            this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchUp, this);
            this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchUp, this);
        }
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    stopAnimation: function stopAnimation() {
        if (Utils.Type.isFunction(this.stopFn)) {
            this.stopFn();
            this.stopFn = null;
        }
    },

    onFinishAnimation: function onFinishAnimation() {
        if (!this.isTouching) {
            this.stopAnimation();
        }
        this.isAnimating = true;
    },

    onTouchUp: function onTouchUp() {
        this.isTouching = false;
        if (!this.isAnimating) {
            this.stopAnimation();
        }
    }

});

cc._RFpop();
},{"AnimationManager":"AnimationManager","Utils":"Utils"}],"ButtonScaler":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f14eaDGTDNCIbsb8sAR5Yh+', 'ButtonScaler');
// scripts\ui\ButtonScaler.js

cc.Class({
    "extends": cc.Component,

    properties: {
        pressedScale: 1.1,
        transDuration: 0.1
    },

    // use this for initialization
    onLoad: function onLoad() {
        var self = this;
        self.initScale = this.node.scale;
        self.button = self.getComponent(cc.Button);
        self.scaleDownAction = cc.scaleTo(self.transDuration, self.pressedScale);
        if (self.pressedScale < 1) {
            // add animation to fix bug not trigger button handler
            self.scaleDownAction = cc.sequence([cc.scaleTo(0.02, 1.1), self.scaleDownAction]);
        }
        self.scaleUpAction = cc.scaleTo(self.transDuration, self.initScale);

        function onTouchDown() {
            var button = this.getComponent(cc.Button);
            if (button && button.interactable && self.scaleDownAction) {
                this.stopAllActions();
                this.runAction(self.scaleDownAction);
            }
        }

        function onTouchUp() {
            var button = this.getComponent(cc.Button);
            if (button && button.interactable && self.scaleDownAction) {
                this.stopAllActions();
                this.runAction(self.scaleUpAction);
            }
        }
        this.node.on(cc.Node.EventType.TOUCH_START, onTouchDown, this.node);
        this.node.on(cc.Node.EventType.TOUCH_END, onTouchUp, this.node);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, onTouchUp, this.node);
    }
});

cc._RFpop();
},{}],"CardLayoutMauBinh":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2d0f3ucz2BOZZ8n+/b5peEZ', 'CardLayoutMauBinh');
// scripts\components\games\mau_binh\CardLayoutMauBinh.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        imgThuaSapHam: cc.Node,
        imgThangTrang: cc.Node,
        lblThangTrang: cc.Label,
        layoutCard: cc.Node,
        cardPrefab: cc.Prefab,
        layoutCardList: {
            'default': [],
            type: cc.Node
        }
    },

    onLoad: function onLoad() {
        this._initFirstTime();
    },

    createEffectSwapCard: function createEffectSwapCard() {
        var randomChi1 = Utils.Number.random(0, 2);
        var randomChi2 = Utils.Number.random(0, 2);
        var randomCard1 = Utils.Number.random(0, randomChi1 === 2 ? 2 : 4);
        var randomCard2 = Utils.Number.random(0, randomChi2 === 2 ? 2 : 4);
        if (randomChi1 === randomChi2 && randomCard1 === randomCard2) {
            return;
        }
        var cardLayoutChi1 = this.layoutCardList[randomChi1];
        var cardLayoutChi2 = this.layoutCardList[randomChi2];
        cardLayoutChi1.getComponent(cc.Layout).enabled = false;
        cardLayoutChi2.getComponent(cc.Layout).enabled = false;
        cardLayoutChi1.parent.getComponent(cc.Layout).enabled = false;
        var cardNode1 = cardLayoutChi1.children[randomCard1];
        var cardNode2 = cardLayoutChi2.children[randomCard2];
        var pos1 = cardNode1.position;
        var pos2 = cardNode2.position;
        if (cardNode1 && cardNode2) {
            cardNode1.zIndex = 1;
            cardNode2.zIndex = 1;
            var pos1Change = cardNode1.parent.convertToWorldSpaceAR(pos1);
            var pos2Change = cardNode2.parent.convertToWorldSpaceAR(pos2);
            cardNode1.runAction(cc.moveTo(0.4, cardNode1.parent.convertToNodeSpace(pos2Change)));
            cardNode2.runAction(cc.sequence(cc.moveTo(0.4, cardNode2.parent.convertToNodeSpace(pos1Change)), cc.callFunc(function () {
                cardNode2.zIndex = 0;
                cardNode1.zIndex = 0;
                cardNode2.position = pos2;
                cardNode1.position = pos1;
                cardLayoutChi1.getComponent(cc.Layout).enabled = true;
                cardLayoutChi2.getComponent(cc.Layout).enabled = true;
                cardLayoutChi1.parent.getComponent(cc.Layout).enabled = true;
            })));
        } else {
            cc.log('ERROR');
        }
    },

    resetPosition: function resetPosition() {
        this._initFirstTime();
        this.layoutCard.getComponent(cc.Layout).enabled = true;
        var index = 0;
        for (var i = 0; i < this.layoutCardList.length; i += 1) {
            var layoutCard = this.layoutCardList[i];
            layoutCard.getComponent(cc.Layout).enabled = true;
            for (var j = 0; j < layoutCard.children.length; j += 1) {
                var nodeCard = layoutCard.children[j];
                nodeCard.stopAllActions();
                nodeCard.position = this.cardPositionList2[index];
                index += 1;
            }
        }
    },

    reset: function reset() {
        this.showBinhLung(false);
        this.showAllLayout();
        this.resetPosition();
        this.foldAllCard();
        this.layoutCard.active = false;
        this.imgThuaSapHam.active = false;
        this.imgThangTrang.active = false;
    },

    foldAllCard: function foldAllCard() {
        for (var j = 0; j < this.layoutCardList.length; j += 1) {
            var cardUIList = this.layoutCardList[j].getComponentsInChildren('CardUI');
            for (var i = 0; i < cardUIList.length; i += 1) {
                cardUIList[i].node.stopAllActions();
                cardUIList[i].node.scale = 1;
                cardUIList[i].fold();
            }
        }
    },

    showAllLayout: function showAllLayout() {
        this.resetPosition();
        this.layoutCard.active = true;
        for (var i = 0; i < this.layoutCardList.length; i += 1) {
            this.layoutCardList[i].active = true;
        }
    },

    showBinhLung: function showBinhLung(isBinhLung) {
        this._initFirstTime();
        for (var i = 0; i < this.layoutCardList.length; i += 1) {
            var layoutCard = this.layoutCardList[i];
            for (var j = 0; j < layoutCard.children.length; j += 1) {
                var nodeCard = layoutCard.children[j];
                nodeCard.getComponent('CardUI').showTransparentBlackNode(isBinhLung);
            }
        }
    },

    getCardPositionList: function getCardPositionList() {
        this._initFirstTime();
        return this.cardPositionList;
    },

    _initFirstTime: function _initFirstTime() {
        // Check
        if (this.isInitFirstTime) {
            return;
        }
        this.isInitFirstTime = true;

        // Reset Position Chi 3
        if (this.node.parent.x > 0) {
            this.layoutCardList[2].x = 90;
            this.node.x = -208;
            this.imgThangTrang.x = 13;
        } else {
            this.node.x = 228;
            this.layoutCardList[2].x = 3;
            this.imgThangTrang.x = -51;
        }

        // Get Position Card
        var size = cc.winSize,
            i,
            j,
            index = 0;
        var layoutCard;
        this.cardPositionList = [];
        this.cardPositionList2 = [];
        for (i = 0; i < this.layoutCardList.length; i += 1) {
            layoutCard = this.layoutCardList[i];
            for (j = 0; j < layoutCard.children.length; j += 1) {
                var nodeCard = layoutCard.children[j];
                var pos1 = nodeCard.parent.convertToWorldSpaceAR(nodeCard.position);
                var position = pos1.sub(cc.v2(size.width / 2, size.height / 2));
                this.cardPositionList.push(position);
                this.cardPositionList2.push(nodeCard.position);
            }
        }

        // Remove All Card
        for (i = 0; i < this.layoutCardList.length; i += 1) {
            layoutCard = this.layoutCardList[i];
            layoutCard.removeAllChildren();
        }

        // Re Add Child
        for (i = 0; i < this.layoutCardList.length; i += 1) {
            layoutCard = this.layoutCardList[i];
            var cardCount = i === 2 ? 3 : 5;
            for (j = 0; j < cardCount; j += 1) {
                var cardInstance = cc.instantiate(this.cardPrefab);
                cardInstance.setAnchorPoint(0.5, 0.5);
                cardInstance.position = this.cardPositionList2[i];
                layoutCard.addChild(cardInstance);
                index += 1;
            }
        }

        // Reset
        this.reset();
    }
});

cc._RFpop();
},{"Utils":"Utils"}],"CardRank":[function(require,module,exports){
"use strict";
cc._RFpush(module, '20ca1oZOGNLLYrX5YmOdB6I', 'CardRank');
// scripts\games\common\card\CardRank.js

var Utils = require('Utils');

module.exports = Utils.Class({

    $$static: Utils.Object.toConstant({
        ACE: {
            ID: 0,
            NAME: 'A'
        },
        TWO: {
            ID: 1,
            NAME: '2'
        },
        THREE: {
            ID: 2,
            NAME: '3'
        },
        FOUR: {
            ID: 3,
            NAME: '4'
        },
        FIVE: {
            ID: 4,
            NAME: '5'
        },
        SIX: {
            ID: 5,
            NAME: '6'
        },
        SEVEN: {
            ID: 6,
            NAME: '7'
        },
        EIGHT: {
            ID: 7,
            NAME: '8'
        },
        NINE: {
            ID: 8,
            NAME: '9'
        },
        TEN: {
            ID: 9,
            NAME: '10'
        },
        JACK: {
            ID: 10,
            NAME: 'J'
        },
        QUEEN: {
            ID: 11,
            NAME: 'Q'
        },
        KING: {
            ID: 12,
            NAME: 'K'
        },

        findById: function findById(rankId) {
            return Utils.Object.findObject(this, 'ID', rankId);
        }
    })

});

cc._RFpop();
},{"Utils":"Utils"}],"CardSuit":[function(require,module,exports){
"use strict";
cc._RFpush(module, '65d64rM68RBn7QpNCp5wQu2', 'CardSuit');
// scripts\games\common\card\CardSuit.js

var Utils = require('Utils');

module.exports = Utils.Class({

    $$static: Utils.Object.toConstant({
        SPADE: {
            ID: 0,
            NAME: '♠'
        },
        CLUB: {
            ID: 1,
            NAME: '♣'
        },
        DIAMOND: {
            ID: 2,
            NAME: '♦'
        },
        HEART: {
            ID: 3,
            NAME: '♥'
        },

        findById: function findById(rankId) {
            return Utils.Object.findObject(this, 'ID', rankId);
        }
    })

});

cc._RFpop();
},{"Utils":"Utils"}],"CardUIPhom":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd981cP0mfxNmIJsBFsyrT8V', 'CardUIPhom');
// scripts\components\games\phom\CardUIPhom.js

var CardUI = require('CardUI');

cc.Class({
    'extends': CardUI,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        hoverAnNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        var self = this;
        this.isTouched = false;
        this.posYFirst = self.node.y;
        this.hoverAnNode.active = false;

        this.DELTA_Y_TOUCHED = 70;
        this.TIME_MOVE_TOUCHED = 0.1;
        self.index = self.node.getSiblingIndex();
        this.node.on(cc.Node.EventType.TOUCH_START, function () {
            this.time = Date.now();
        });

        this.interactable = false;
        this.canMove = false;
        this.node.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
            // cc.log(self.canMove);
            if (this.time - Date.now() < -100 && self.interactable && self.canMove) {
                self.isMoved = true;
                self.node.setSiblingIndex(self.node.parent.childrenCount + 1);
                var pos = self.node.parent.convertToNodeSpace(event.getLocation());
                self.node.x = pos.x;
                self.node.parent.getComponent(cc.Layout).enabled = false;
            }
        });

        this.node.on(cc.Node.EventType.TOUCH_END, function () {
            if (self.interactable && !self.isMoved) {
                self.onButtonTouch();
            }
            self.onEndOrCancelTouch();
        });

        this.node.on(cc.Node.EventType.TOUCH_CANCEL, function () {
            self.onEndOrCancelTouch();
        });

        this.node.on('check_chosen_card', function () {});
    },

    onEndOrCancelTouch: function onEndOrCancelTouch() {
        if (this.interactable && this.isMoved) {
            this.node.parent.getComponent(cc.Layout).enabled = true;
            this.index = Math.round(this.node.x / (this.node.parent.width / this.node.parent.childrenCount));
            this.index = this.index >= 0 ? this.index : 0;
            this.node.setSiblingIndex(this.index);
            this.isMoved = false;
            this.time = Date.now();
        }
    },

    onButtonTouch: function onButtonTouch(notEffect) {
        var sequenceAction;
        var self = this;
        var timeEffect = 0;
        if (notEffect) {
            timeEffect = 0;
        } else {
            timeEffect = self.TIME_MOVE_TOUCHED;
        }
        self.node.stopAllActions();
        if (this.isTouched) {
            sequenceAction = cc.sequence(cc.callFunc(function () {
                self.isTouched = true;
                self.interactable = false;
                self.node.setPosition(self.node.x, self.posYFirst + self.DELTA_Y_TOUCHED);
            }), cc.moveTo(timeEffect, 0, self.posYFirst), cc.callFunc(function () {
                self.isTouched = false;
                self.interactable = true;
                self.node.parent.emit('check_chosen_card');
            }));
        } else {
            sequenceAction = cc.sequence(cc.callFunc(function () {
                self.isTouched = false;
                self.node.setPosition(self.node.x, self.posYFirst);
                self.interactable = false;
            }), cc.moveTo(timeEffect, 0, self.posYFirst + self.DELTA_Y_TOUCHED), cc.callFunc(function () {
                self.isTouched = true;
                self.interactable = true;
                self.node.parent.emit('check_chosen_card');
            }));
        }
        self.node.runAction(sequenceAction);
    },

    setMoveCardUpDown: function setMoveCardUpDown(isUp) {
        var self = this;
        self.node.stopAllActions();
        if (isUp) {
            self.node.setPosition(self.node.x, self.posYFirst);
            self.node.runAction(cc.moveTo(self.TIME_MOVE_TOUCHED, 0, self.posYFirst + self.DELTA_Y_TOUCHED));
        } else {
            self.node.setPosition(self.node.x, self.posYFirst + self.DELTA_Y_TOUCHED);
            self.node.runAction(cc.moveTo(self.TIME_MOVE_TOUCHED, 0, self.posYFirst));
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"CardUI":"CardUI"}],"CardUI":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ba14cEhi+RMFo1nKiA0rpMk', 'CardUI');
// scripts\components\games\ui\CardUI.js

var CardRank = require('CardRank'),
    CardSuit = require('CardSuit');

cc.Class({
    'extends': cc.Component,

    properties: {
        foldNode: cc.Node,
        unfoldNode: cc.Node,
        transparentBlackNode: cc.Node,
        // anchors
        rankLabel: cc.Label,
        smallSuitImageSprite: cc.Sprite,
        bigSuitImageSprite: cc.Sprite,
        bigFaceImageSprite: cc.Sprite,

        redColor: cc.Color,
        blackColor: cc.Color,
        smallSuiteSpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        },
        bigSuiteSpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        },
        redFaceSpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        },
        blackFaceSpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        }
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    setCard: function setCard(card) {
        this.card = card;
        if (card) {
            var rank = card.rank,
                suit = card.suit,
                isRedCard = this._isRedCard(card);

            this.foldNode.active = false;
            this.unfoldNode.active = true;

            this.rankLabel.string = rank.NAME;
            this.rankLabel.node.color = isRedCard ? this.redColor : this.blackColor;

            // var rankLabelOutline = this.rankLabel.node.addComponent(cc.LabelOutline);
            // rankLabelOutline.color = isRedCard ? this.redColor : this.blackColor;

            this.smallSuitImageSprite.spriteFrame = this.smallSuiteSpriteFrames[suit.ID];
            if (this._isFaceCard(card)) {
                this.bigSuitImageSprite.node.active = false;
                this.bigFaceImageSprite.node.active = true;
                this.bigFaceImageSprite.spriteFrame = (isRedCard ? this.redFaceSpriteFrames : this.blackFaceSpriteFrames)[rank.ID - CardRank.JACK.ID];
            } else {
                this.bigFaceImageSprite.node.active = false;
                this.bigSuitImageSprite.node.active = true;
                this.bigSuitImageSprite.spriteFrame = this.bigSuiteSpriteFrames[suit.ID];
            }
        } else {
            this.fold();
        }
    },

    fold: function fold() {
        this.card = null;
        this.foldNode.active = true;
        this.unfoldNode.active = false;
    },

    showTransparentBlackNode: function showTransparentBlackNode(isShow) {
        if (this.transparentBlackNode) {
            this.transparentBlackNode.active = isShow;
        }
    },

    _isFaceCard: function _isFaceCard(card) {
        var rank = card.rank;
        return rank === CardRank.JACK || rank === CardRank.QUEEN || rank === CardRank.KING;
    },

    _isRedCard: function _isRedCard(card) {
        var suit = card.suit;
        return suit === CardSuit.DIAMOND || suit === CardSuit.HEART;
    },

    getCard: function getCard() {
        return this.card;
    },

    getCardId: function getCardId() {
        return this.card.getId();
    }

});

cc._RFpop();
},{"CardRank":"CardRank","CardSuit":"CardSuit"}],"Card":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'dfe3bnW6HtCboi8iPv9kwuU', 'Card');
// scripts\games\common\card\Card.js

var Utils = require('Utils'),
    CardRank = require('CardRank'),
    CardSuit = require('CardSuit');

module.exports = Utils.Class({

    $$constructor: function $$constructor(rank, suit) {
        this.rank = rank;
        this.suit = suit;
    },

    $$static: {
        fromId: function fromId(cardId) {
            var rankId = Math.floor(cardId / 4),
                suitId = cardId % 4,
                rank = CardRank.findById(rankId),
                suit = CardSuit.findById(suitId);
            return new this(rank, suit);
        }
    },

    getId: function getId() {
        return 4 * this.rank.ID + this.suit.ID;
    },

    toString: function toString() {
        return this.rank.NAME + this.suit.NAME;
    }

});

cc._RFpop();
},{"CardRank":"CardRank","CardSuit":"CardSuit","Utils":"Utils"}],"Carousel":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8d86ekUO5hHraDfR+oYg6L+', 'Carousel');
// scripts\ui\Carousel.js

cc.Class({
    'extends': cc.Component,

    properties: {
        items: {
            'default': [],
            visible: false
        },
        autoSlideTime: 5,
        selectEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var that = this;
        this.slideTime = 0;
        this.node.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
            var pos = event.getLocation(),
                prevPos = event.getPreviousLocation();
            event.stopPropagation();
            that._slide(Math.sign(prevPos.x - pos.x));
        });
    },

    addItem: function addItem(itemNode, isDefault) {
        var that = this,
            contentsNode = this.node.getChildByName('Contents');
        this.items.push(itemNode);
        itemNode.width = contentsNode.width;
        itemNode.height = contentsNode.height;
        if (isDefault) {
            this.currentItem = itemNode;
            itemNode.x = itemNode.y = 0;
            contentsNode.addChild(itemNode);
        }
        itemNode.on(cc.Node.EventType.TOUCH_END, function (event) {
            if (that.slideTime > 0.3) {
                that.selectEvents.forEach(function (selectEvent) {
                    selectEvent.emit([event.currentTarget]);
                });
            }
        }, itemNode);
    },

    clearAllTimes: function clearAllTimes() {
        this.items = [];
        this.slideTime = 0;
        this.currentItem = null;
    },

    _slide: function _slide(direction) {
        var hidePos,
            that = this,
            animateTime = 0.5,
            currentItem = this.currentItem,
            targetItem = this._getItem(direction),
            contentsNode = this.node.getChildByName('Contents');
        if (this.isSliding) {
            return;
        }
        if (currentItem && targetItem && currentItem !== targetItem) {
            that.slideTime = 0;
            that.isSliding = true;
            currentItem.stopAllActions();
            hidePos = cc.p(-Math.sign(direction) * (contentsNode.width + currentItem.width + 10) / 2, 0);
            currentItem.runAction(cc.sequence([cc.moveTo(animateTime, hidePos).easing(cc.easeOut(3.0)), cc.callFunc(function () {
                currentItem.removeFromParent(false);
            })]));
            setTimeout(function () {
                if (cc.isValid(targetItem)) {
                    targetItem.stopAllActions();
                    that.currentItem = targetItem;
                    contentsNode.addChild(targetItem);
                    targetItem.x = Math.sign(direction) * (contentsNode.width + targetItem.width + 10) / 2;
                    targetItem.y = 0;
                    targetItem.runAction(cc.sequence([cc.moveTo(animateTime, cc.p(0, 0)).easing(cc.easeOut(3.0)), cc.callFunc(function () {
                        that.isSliding = false;
                    })]));
                }
            }, animateTime / 2);
        }
    },

    _getItem: function _getItem(offset) {
        var currentIndex = this.items.indexOf(this.currentItem);
        if (currentIndex + offset >= this.items.length) {
            return this.items[0];
        } else if (currentIndex + offset < 0) {
            return this.items[this.items.length - 1];
        } else {
            return this.items[currentIndex + offset];
        }
    },

    nextSlide: function nextSlide() {
        this._slide(1);
    },

    prevSlide: function prevSlide() {
        this._slide(-1);
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this.slideTime > this.autoSlideTime) {
            this.slideTime = 0;
            this.nextSlide();
        } else {
            this.slideTime += dt;
        }
    }
});

cc._RFpop();
},{}],"ChangeSpriteAnimation":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd0e3aYsMrtLxqREl76H32Eu', 'ChangeSpriteAnimation');
// scripts\ui\ChangeSpriteAnimation.js

cc.Class({
    "extends": cc.Component,

    properties: {
        listSprites: {
            "default": [],
            type: cc.Sprite
        }
    },

    // use this for initialization
    onLoad: function onLoad() {}

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"ChiMauBinh":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e8340j/G3NLr7NWT2Ov8cEe', 'ChiMauBinh');
// scripts\components\games\mau_binh\ChiMauBinh.js

var Utils = require('Utils'),
    MauBinhConstant = require('MauBinhConstant');

module.exports = Utils.Class({

    $$constructor: function $$constructor(cardIds) {
        this.cards = cardIds.slice(0);
        this.chi = MauBinhConstant.Chi.NONE;
        this.cardsChi = [];
        this.cardsInChi = [];
        for (var i = 0; i < 3; i += 1) {
            this.cardsChi.push(this.cards.slice(i * 5, i * 5 + (i >= 2 ? 3 : 5)));
            this.cardsInChi.push(0);
        }
        this.result = [MauBinhConstant.Chi.NONE, MauBinhConstant.Chi.NONE, MauBinhConstant.Chi.NONE];
        this._calculateResult();
    },

    getResult: function getResult() {
        // cc.log(this.cardsInChi);
        return this.result;
    },

    getCardsNotInChi: function getCardsNotInChi() {
        var i, j;
        var cards = [];
        var cardsAll = [],
            cardsInChiAll = [];
        for (i = 0; i < 3; i += 1) {
            for (j = 0; j < this.cardsChi[i].length; j += 1) {
                this._congQuanAt(this.cardsChi[i][j]);
                cardsAll.push(this.cardsChi[i][j]);
            }
        }
        for (i = 0; i < 3; i += 1) {
            for (j = 0; j < this.cardsInChi[i].length; j += 1) {
                this._congQuanAt(this.cardsInChi[i][j]);
                cardsInChiAll.push(this.cardsInChi[i][j]);
            }
        }
        for (i = 0; i < cardsAll.length; i += 1) {
            var isNotInChi = true;
            for (j = 0; j < cardsInChiAll.length; j += 1) {
                if (cardsAll[i] === cardsInChiAll[j]) {
                    isNotInChi = false;
                    break;
                }
            }
            if (isNotInChi) {
                Utils.Array.pushUnique(cards, cardsAll[i]);
            }
        }
        return cards;
    },

    isChiThung: function isChiThung(indexChi) {
        var cardChi = this.cardsChi[indexChi];
        var first = cardChi[0] % 4;
        for (var i = 1; i < cardChi.length; i += 1) {
            if (first !== cardChi[i] % 4) {
                return false;
            }
        }
        this.cardsInChi[indexChi] = cardChi;
        return true;
        // return cardChi.length >= 5;
    },

    isChiSanh: function isChiSanh(indexChi) {
        var cardChi = this.cardsChi[indexChi];
        this.sortCard(cardChi);
        var card1 = cardChi[0];
        for (var i = 1; i < cardChi.length; i += 1) {
            if (this.getSubRank(card1, cardChi[i]) !== i) {
                return false;
            }
        }
        this.cardsInChi[indexChi] = cardChi;
        return true;
        // return cardChi.length >= 5;
    },

    isChiSanhAt: function isChiSanhAt(indexChi) {
        var cardChi = this.cardsChi[indexChi];
        this._congQuanAt(cardChi);
        this.sortCard(cardChi);
        var card1 = cardChi[0];
        for (var i = 1; i < cardChi.length; i += 1) {
            if (this.getSubRank(card1, cardChi[i]) !== i) {
                return false;
            }
        }
        this.cardsInChi[indexChi] = cardChi;
        return true;
        // return cardChi.length >= 5;
    },

    isSanhRong: function isSanhRong() {
        var cardsTmp = this.cards.slice(0);
        this.sortCard(cardsTmp);
        var card1 = cardsTmp[0];
        for (var i = 1; i < cardsTmp.length; i += 1) {
            if (this.getSubRank(card1, cardsTmp[i]) !== i) {
                return false;
            }
        }
        return true;
    },

    isThangTrang: function isThangTrang() {
        return this.result[0] === MauBinhConstant.Chi.LUC_PHE_BON || this.result[0] === MauBinhConstant.Chi.BA_CAI_SANH || this.result[0] === MauBinhConstant.Chi.BA_CAI_THUNG || this.result[0] === MauBinhConstant.Chi.SANH_RONG;
    },

    isBinhLung: function isBinhLung() {
        if (this.isThangTrang()) {
            return false;
        }
        var binhLung = this.result[0].ID < this.result[1].ID || this.result[0].ID < this.result[2].ID || this.result[1].ID < this.result[2].ID;
        if (!binhLung) {
            binhLung = this._tinhBinhLungChiGiongNhau();
        }
        return binhLung;
    },

    _congQuanAt: function _congQuanAt(cards) {
        for (var j = 0; j < cards.length; j += 1) {
            if (cards[j] <= 3) {
                cards[j] += 52;
            }
        }
    },

    _tinhBinhLungChiGiongNhau: function _tinhBinhLungChiGiongNhau() {
        var binhLung = false;
        for (var i = 0; i < 3 - 1; i += 1) {
            for (var j = i + 1; j < 3; j += 1) {
                if (!binhLung && this.result[i].ID === this.result[j].ID) {
                    binhLung = this._tinhBinhLung2ChiGiongNhau(i, j);
                    if (binhLung) {
                        break;
                    }
                }
            }
        }
        return binhLung;
    },

    _tinhBinhLung2ChiGiongNhau: function _tinhBinhLung2ChiGiongNhau(index1, index2) {
        var chi1 = this.cardsInChi[index1];
        var chi2 = this.cardsInChi[index2];
        // cc.log(index1 + ' cardsInChi ' + chi1 + ' --- cardChi1 ' + this.cardsChi[index1]);
        // cc.log(index2 + ' cardsInChi ' + chi2 + ' --- cardChi2 ' + this.cardsChi[index2]);
        // Neu Chi Cu Lu
        if (this.result[index1] === MauBinhConstant.Chi.CU_LU) {
            // Lay Gia Tri Lon Nhat Cua Chi
            var maxChi1, maxChi0;
            maxChi0 = this._getMaxChiCuLu(chi1);
            maxChi1 = this._getMaxChiCuLu(chi2);

            // Lay Rank ID
            maxChi0 = Math.floor(maxChi0 / 4);
            maxChi1 = Math.floor(maxChi1 / 4);
            binhLung = maxChi0 < maxChi1;
            if (binhLung) {
                return binhLung;
            }
        }

        // 2 MAU THAU => Lay Quan Lon Nhat Trong Chi
        if (this.result[index1] === MauBinhConstant.Chi.MAU_THAU) {
            chi1 = this.cardsChi[index1];
            chi2 = this.cardsChi[index2];
        }
        var ingnoreValues1 = [];
        var ingnoreValues2 = [];
        var max1,
            max2,
            count = 0;
        while (true) {
            max1 = this.getMaxOfArray(chi1, ingnoreValues1);
            max2 = this.getMaxOfArray(chi2, ingnoreValues2);
            var round1 = Math.floor(max1 / 4);
            var round2 = Math.floor(max2 / 4);
            if (round1 === round2 && round1 !== -1) {
                // Cho Vao Danh Sach Bo Qua
                ingnoreValues1.push(max1);
                ingnoreValues2.push(max2);

                // Neu Chi Doi Hoac Thu Co Cac Doi Giong Nhau => Lay Tat Ca Quan Cua Chi De Tinh Max
                if ((this.result[index1] === MauBinhConstant.Chi.DOI || this.result[index1] === MauBinhConstant.Chi.THU) && ingnoreValues1.length >= chi1.length) {
                    // cc.log('Truong Hop Dac Biet');
                    chi1 = this.cardsChi[index1];
                    chi2 = this.cardsChi[index2];
                }
            }
            if (round1 !== round2 || ingnoreValues1.length >= chi1.length || ingnoreValues2.length >= chi2.length || count >= 5) {
                break;
            }
            count += 1;
        }
        var binhLung = Math.floor(max1 / 4) < Math.floor(max2 / 4);
        return binhLung;
    },

    getMaxOfArray: function getMaxOfArray(numArray, ingnoreValues) {
        // Lay Phan Tu Thoa Man
        var newList = [];
        var i, j;
        for (i = 0; i < numArray.length; i += 1) {
            var tmp = numArray[i];
            var isOk = true;
            for (j = 0; j < ingnoreValues.length; j += 1) {
                if (tmp === ingnoreValues[j]) {
                    isOk = false;
                    break;
                }
            }
            if (isOk) {
                newList.push(tmp);
            }
        }

        // Tim Max
        var max = -1;
        if (newList.length > 0) {
            max = Math.max.apply(null, newList);
        }
        return max;
    },

    _getMaxChiCuLu: function _getMaxChiCuLu(cardsId) {
        var list1 = [],
            list2 = [];
        list1.push(cardsId[0]);
        for (var i = 1; i < cardsId.length; i += 1) {
            if (this.getSubRank(list1[0], cardsId[i]) === 0) {
                list1.push(cardsId[i]);
            } else {
                list2.push(cardsId[i]);
            }
        }
        var max = list1.length === 3 ? list1[0] : list2[0];
        return max;
    },

    _calculateResult: function _calculateResult() {
        var i, j;
        // Sanh Rong
        var isSanhRong = this.isSanhRong();
        if (isSanhRong) {
            for (i = 0; i < 3; i += 1) {
                this.result[i] = MauBinhConstant.Chi.SANH_RONG;
            }
            return this.result;
        }

        // Thung Pha Sanh - Sanh - Thung - Doi - Cu Lu - Sam
        for (i = 0; i < 3; i += 1) {
            var chi = MauBinhConstant.Chi.NONE;
            var isThung = this.isChiThung(i);
            var isSanh = this.isChiSanh(i);
            if (!isSanh) {
                isSanh = this.isChiSanhAt(i);
            }
            if (isThung && isSanh) {
                chi = MauBinhConstant.Chi.THUNG_PHA_SANH;
            } else if (isThung) {
                chi = MauBinhConstant.Chi.THUNG;
            } else if (isSanh) {
                chi = MauBinhConstant.Chi.SANH;
            } else {
                chi = this._calculateTuQuyCuLuThuDoi(i);
            }
            if (chi === MauBinhConstant.Chi.NONE) {
                chi = MauBinhConstant.Chi.MAU_THAU;
            }
            this.result[i] = chi;
        }

        // Check Chi Dac Biet
        var chiSpecial = MauBinhConstant.Chi.NONE;

        // Luc Phe Bon
        if (this.result[0] === this.result[1] && this.result[0] === MauBinhConstant.Chi.THU && this.result[2] === MauBinhConstant.Chi.DOI) {
            var cardsNotInChi = this.getCardsNotInChi();
            for (i = 0; i < cardsNotInChi.length - 1; i += 1) {
                for (j = i + 1; j < cardsNotInChi.length; j += 1) {
                    if (this.getSubRank(cardsNotInChi[i], cardsNotInChi[j]) === 0) {
                        chiSpecial = MauBinhConstant.Chi.LUC_PHE_BON;
                        break;
                    }
                }
            }
        }

        // Ba Cai Thung
        if (this.result[0] === this.result[1] && this.result[0] === this.result[2] && this.result[0] === MauBinhConstant.Chi.THUNG) {
            chiSpecial = MauBinhConstant.Chi.BA_CAI_THUNG;
        }

        // Ba Cai Sanh
        if (this.result[0] === this.result[1] && this.result[0] === this.result[2] && this.result[0] === MauBinhConstant.Chi.SANH) {
            chiSpecial = MauBinhConstant.Chi.BA_CAI_SANH;
        }

        if (chiSpecial !== MauBinhConstant.Chi.NONE) {
            for (i = 0; i < 3; i += 1) {
                this.result[i] = chiSpecial;
            }
            return this.result;
        }

        // Check Mau Thau Chi 3
        if (this.result[2] === MauBinhConstant.Chi.SANH || this.result[2] === MauBinhConstant.Chi.THUNG || this.result[2] === MauBinhConstant.Chi.THUNG_PHA_SANH) {
            this.result[2] = MauBinhConstant.Chi.MAU_THAU;
            this.cardsInChi[2] = [];
        }
        return this.result;
    },

    _calculateTuQuyCuLuThuDoi: function _calculateTuQuyCuLuThuDoi(indexChi) {
        var countEquals = this.getCountEqualsRank(this.cardsChi[indexChi]);
        var chi = MauBinhConstant.Chi.NONE;
        switch (countEquals.count) {
            case 0:
                break;
            case 1:
                // Doi
                chi = MauBinhConstant.Chi.DOI;
                break;
            case 2:
                // Thu
                chi = MauBinhConstant.Chi.THU;
                break;
            case 3:
                // Sam Co
                chi = MauBinhConstant.Chi.SAM;
                break;
            case 4:
                // Cu Lu
                chi = MauBinhConstant.Chi.CU_LU;
                break;
            case 6:
                // Tu Quy
                chi = MauBinhConstant.Chi.TU_QUY;
                break;
        }
        this.cardsInChi[indexChi] = countEquals.cards;
        return chi;
    },

    getCountEqualsRank: function getCountEqualsRank(cardIds) {
        var count = 0;
        var cards = [];
        for (var i = 0; i < cardIds.length - 1; i += 1) {
            for (var j = i + 1; j < cardIds.length; j += 1) {
                if (this.getSubRank(cardIds[i], cardIds[j]) === 0) {
                    count += 1;
                    Utils.Array.pushUnique(cards, cardIds[i]);
                    Utils.Array.pushUnique(cards, cardIds[j]);
                }
            }
        }
        if (count <= 0) {
            cards = [];
        }
        return {
            count: count,
            cards: cards
        };
    },

    getSubRank: function getSubRank(cardId1, cardId2) {
        var sub = Math.abs(Math.floor(cardId1 / 4) - Math.floor(cardId2 / 4));
        return sub;
    },

    sortCard: function sortCard(cardIds) {
        // Sort Tang Dan
        for (var i = 0; i < cardIds.length - 1; i += 1) {
            for (var j = i + 1; j < cardIds.length; j += 1) {
                if (cardIds[i] > cardIds[j]) {
                    var tmp = cardIds[i];
                    cardIds[i] = cardIds[j];
                    cardIds[j] = tmp;
                }
            }
        }
    }
});

cc._RFpop();
},{"MauBinhConstant":"MauBinhConstant","Utils":"Utils"}],"Chip":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4a4d5MPTJBGaZLnYP27NldE', 'Chip');
// scripts\components\games\ui\Chip.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        money: 0,
        moneyLabel: cc.Label,
        activeSprite: cc.Sprite,
        redChipSpriteFrame: cc.SpriteFrame,
        greenChipSpriteFrame: cc.SpriteFrame,
        blueChipSpriteFrame: cc.SpriteFrame,
        purpleChipSpriteFrame: cc.SpriteFrame
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(money, color) {
        this.money = money;
        this.moneyLabel.string = Utils.Number.abbreviate(money);

        color = color || 'blue';
        var sprite = this.node.getComponent(cc.Sprite);
        sprite.spriteFrame = this[color + 'ChipSpriteFrame'];
    },

    activeSelectChip: function activeSelectChip(isActive) {
        this.activeSprite.node.active = isActive;
        if (isActive) {
            var action = cc.rotateBy(10, 360);
            this.activeSprite.node.runAction(cc.repeatForever(action));
        }
    }
});

cc._RFpop();
},{"Utils":"Utils"}],"Collapse":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1ccc90t7WlCE7AcqK0dpTHT', 'Collapse');
// scripts\ui\Collapse.js

cc.Class({
    'extends': cc.Component,

    properties: {
        isShow: false,
        targetNode: cc.Node,
        toggleOnEvents: {
            'default': [],
            type: cc.Component.EventHandler
        },
        toggleOffEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var that = this;
        this.node.on(cc.Node.EventType.TOUCH_END, function () {
            that.toggle();
        });
    },

    toggle: function toggle() {
        this.isShow = !this.isShow;
        if (this.isShow) {
            this.targetNode.parent.height += this.targetNode.height;
            this.targetNode.runAction(cc.scaleTo(0.2, 1, 1));
        } else {
            this.targetNode.parent.height -= this.targetNode.height;
            this.targetNode.runAction(cc.scaleTo(0.2, 1, 0));
        }
        this.dispatchEvents();
    },

    dispatchEvents: function dispatchEvents() {
        if (this.isShow) {
            this.toggleOnEvents.forEach(function (event) {
                event.emit();
            });
        } else {
            this.toggleOffEvents.forEach(function (event) {
                event.emit();
            });
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{}],"ColumnInfoMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1a9d5yhIz9Lbb7qtMrPqH+i', 'ColumnInfoMiniPoker');
// scripts\components\games\mini_poker\ColumnInfoMiniPoker.js

var CardUI = require('CardUI'),
    Card = require('Card'),
    CardRank = require('CardRank'),
    CardSuit = require('CardSuit');

cc.Class({
    'extends': cc.Component,

    properties: {
        index: 0,
        cardPrefab: {
            'default': null,
            type: cc.Prefab
        },
        cardFinish: {
            'default': [],
            type: cc.Node
        }
    },

    onLoad: function onLoad() {
        this.isReady = false;
        this.count = 20;
        this.cardTemp = [];
        this.cardFirst = 0;
        this.node.y = -94;
        this.isUpdateCardFinish = false;
        this._initFirstCard();
    },

    start: function start() {
        this._initDefaultCard();
    },

    _initFirstCard: function _initFirstCard() {
        this.node.removeAllChildren();
        var rd1 = this.randomFromTo(0, 11);
        var rd2 = this.randomFromTo(0, 3);
        var card = new Card(CardRank.findById(rd1), CardSuit.findById(rd2));
        this._insertCard(card, false, false);
    },

    _initDefaultCard: function _initDefaultCard() {
        this.node.runAction(cc.sequence(cc.delayTime(0.5), cc.callFunc((function () {
            for (var i = 0; i < this.count; i += 1) {
                var rd1 = this.randomFromTo(0, 11);
                var rd2 = this.randomFromTo(0, 3);
                if (i === this.count - 1) {
                    rd1 = this.index * 2;
                }
                var card = new Card(CardRank.findById(rd1), CardSuit.findById(rd2));
                this._insertCard(card, i === this.count - 1, i === 0);
            }
            this.isReady = true;
        }).bind(this))));
    },

    _insertCard: function _insertCard(card, isFinishCard, isFirstCard) {
        var node = cc.instantiate(this.cardPrefab);
        node.scale = 0.73;
        //node.setContentSize(cc.v2(94, 123));
        node.position = cc.v2(0, 0);
        var cardUI = node.getComponent(CardUI);
        cardUI.setCard(card);
        this.node.addChild(node);
        if (isFinishCard) {
            // node.setSiblingIndex(0);
            this.cardFinish.push(node);
        }
        if (isFirstCard) {
            this.cardFirst = node;
        }
    },

    updateCardFirst: function updateCardFirst() {
        if (this.cardFirst && this.cardFinish.length > 0 && this.isUpdateCardFinish) {
            var cardUI = this.cardFinish[this.cardFinish.length - 1].getComponent(CardUI);
            this.cardFirst.getComponent(CardUI).setCard(cardUI.card);
        }
    },

    updateCardFinish: function updateCardFinish(card) {
        for (var i = 0; i < this.cardFinish.length; i += 1) {
            var cardUI = this.cardFinish[i].getComponent(CardUI);
            cardUI.setCard(card);
            // cc.log(card.toString());
        }
        this.isUpdateCardFinish = true;
    },

    randomFromTo: function randomFromTo(from, to) {
        return Math.floor(Math.random() * (to - from + 1));
    }
});

cc._RFpop();
},{"Card":"Card","CardRank":"CardRank","CardSuit":"CardSuit","CardUI":"CardUI"}],"CommonConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '6743e6G6KBPpKG+bVp9W/MM', 'CommonConstant');
// scripts\constant\CommonConstant.js

var Utils = require('Utils');

module.exports = {
    Scene: {
        HALL: 'Hall',
        LOBBY: 'Lobby',
        SPLASH: 'Splash',
        PROFILE: 'Profile'
    },

    CurrencyType: {
        Ip: {
            ID: 0,
            NAME: 'IP',
            DISPLAY_NAME: 'Pi'
        },
        Xu: {
            ID: 1,
            NAME: 'XU',
            DISPLAY_NAME: 'Xu'
        },

        findById: function findById(currencyId) {
            return Utils.Object.findObject(this, 'ID', currencyId);
        },

        findByName: function findByName(currencyName) {
            return Utils.Object.findObject(this, 'NAME', currencyName);
        }
    },

    PushMessageType: {
        MESSAGE: {
            ID: 0,
            EVENT: 'push_message.temporary_message'
        },
        POPUP: {
            ID: 1,
            EVENT: 'push_message.popup'
        },
        RUNNING: {
            ID: 2,
            EVENT: 'push_message.running'
        },
        TAT_TN: {
            ID: 3,
            EVENT: 'push_message.tat_tn'
        },
        UPDATE_USER_INFO: {
            ID: 4,
            EVENT: 'push_message.update_user_info'
        },

        findById: function findById(messageTypeId) {
            return Utils.Object.findObject(this, 'ID', messageTypeId);
        }
    },

    ZINDEX: {
        MINIGAME_QUICK_ICON: 1000000,
        MINIGAME_POPUP: 1000000,
        MINIGAME_PREFAB: 1000000,
        WARNING_MESSAGE: 1000001,
        MODAL: 1000002
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"ConfirmModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, '42b8aQ6oU9FkqttVpwXGoDR', 'ConfirmModal');
// scripts\ui\ConfirmModal.js

cc.Class({
    "extends": cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    okeCallback: function okeCallback() {
        // not implement
    },

    cancelCallback: function cancelCallback() {
        // not implement
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"DaiLy":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd0b19+YHd5LCplPMDgfb0qs', 'DaiLy');
// scripts\components\dai_ly\DaiLy.js

var Url = require('Url'),
    Utils = require('Utils'),
    TabView = require('TabView'),
    AuthUser = require('AuthUser'),
    DropDown = require('DropDown'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        userNameEditBox: cc.EditBox,
        amountEditBox: cc.EditBox,
        noteEditBox: cc.EditBox,
        currencyDropDown: DropDown,

        daiLyTabView: TabView,

        itemDaiLyPrefab: cc.Prefab,
        daiLyContainerNode: cc.Node,

        feeLabel: cc.Label,
        soDuLabel: cc.Label,
        infoRichText: cc.RichText,

        itemLichSuPrefab: cc.Prefab,
        lichSuChuyenPiContainerNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateSoDu: function updateSoDu() {
        var item = this.currencyDropDown.getSelectedItem();
        this.soDuLabel.string = Utils.Number.format(AuthUser.currencies[item.value].balance) + ' ' + item.label;
    },

    loadContentTransfer: function loadContentTransfer() {
        var that = this;
        that.infoRichText.string = '';
        that.feeLabel.string = '0%.';
        that.clearChuyenPiForm();

        NetworkManager.Http.fetch('GET', Url.Http.TRANSFER, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }, {
            cache: 1800
        }).success(function (respDone) {
            var data = respDone.data;
            that.feeLabel.string = data.fee * 100 + '%';
            that.infoRichText.string = data.note;

            that.currencyDropDown.clearAllItems();
            for (var i = 0; i < data.currencies.length; i += 1) {
                that.currencyDropDown.addItem({
                    value: data.currencies[i],
                    label: CommonConstant.CurrencyType.findByName(data.currencies[i]).DISPLAY_NAME
                }, i === 0 ? true : false);
            }
            that.updateSoDu();
        });
    },

    clearChuyenPiForm: function clearChuyenPiForm() {
        this.amountEditBox.string = '';
        this.noteEditBox.string = '';
    },

    chuyenPi: function chuyenPi(event) {
        var that = this,
            amount = parseInt(this.amountEditBox.string),
            currency = this.currencyDropDown.getSelectedItem();
        if (!this.userNameEditBox.string || !this.noteEditBox.string) {
            return UiManager.openModal('Xin vui lòng nhập đầy đủ thông tin.');
        }
        if (!amount) {
            return UiManager.openModal('Xin vui lòng nhập số tiền hợp lệ.');
        }
        if (!currency) {
            return;
        }
        NetworkManager.Http.fetch('POST', Url.Http.TRANSFER, {
            from_user: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            to_user: this.userNameEditBox.string,
            amount: this.amountEditBox.string,
            note: this.noteEditBox.string,
            currency: currency.value
        }).success(function () {
            UiManager.openModal('Xin chúc mừng, bạn đã chuyển tiền thành công.');
            that.daiLyTabView.activeByName('LichSu');
            that.clearChuyenPiForm();
        }).setWaitingButton(event.target);
    },

    getLichSuChuyenPi: function getLichSuChuyenPi() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.TRANSFER_LOG, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }).success(function (respDone) {
            var transferLogNode,
                i,
                col1,
                col2,
                col3,
                col4,
                currency,
                items = respDone.data.items;
            that.lichSuChuyenPiContainerNode.removeAllChildren();
            for (i = 0; i < items.length; i += 1) {
                transferLogNode = cc.instantiate(that.itemLichSuPrefab);
                col1 = items[i].created_time.replace(' ', '\n');
                currency = CommonConstant.CurrencyType.findByName(items[i].currency).DISPLAY_NAME;
                col2 = Utils.Number.format(items[i].amount) + ' ' + currency;
                col3 = items[i].with_acc;
                col4 = items[i].note;
                transferLogNode.getComponent('RowTable').updateData(col1, col2, col3, col4);
                that.lichSuChuyenPiContainerNode.addChild(transferLogNode);
            }
        });
    },

    getDaiLyInfo: function getDaiLyInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.DAILY_LIST, {}, {
            cache: 1800,
            delay: 500
        }).success(function (respDone) {
            var partners = respDone.data;
            that.daiLyContainerNode.removeAllChildren();
            for (var i = 0; i < partners.length; i += 1) {
                that.daiLyContainerNode.addChild(that._initDaiLyNode(partners[i]));
            }
        });
    },

    _initDaiLyNode: function _initDaiLyNode(daiLyData) {
        var that = this,
            componentItemDaily,
            daiLyNode = cc.instantiate(this.itemDaiLyPrefab);
        daiLyNode.getComponent('RowTable').updateData(daiLyData.display_name, daiLyData.username, daiLyData.mobile, daiLyData.address);

        componentItemDaily = daiLyNode.getComponent('ItemDaiLy');
        componentItemDaily.updateData(daiLyData);
        componentItemDaily.chuyenPi = function () {
            that.userNameEditBox.string = daiLyData.username;
            that.daiLyTabView.activeByName('ChuyenPi');
        };

        return daiLyNode;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","DropDown":"DropDown","NetworkManager":"NetworkManager","TabView":"TabView","UiManager":"UiManager","Url":"Url","Utils":"Utils"}],"DoiThe":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3821505thtIJpI/z62uUf8w', 'DoiThe');
// scripts\components\doi_thuong\DoiThe.js

var Url = require('Url'),
    Utils = require('Utils'),
    TabView = require('TabView'),
    AuthUser = require('AuthUser'),
    DropDown = require('DropDown'),
    UiManager = require('UiManager'),
    CommonConstant = require('CommonConstant'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemMenhGiaPrefab: cc.Prefab,
        contentMenhGiaNode: cc.Node,

        doiTheTabView: TabView,
        lichSuDoiTabView: TabView,

        loaiTheDropDown: DropDown,
        menhGiaDropDown: DropDown,
        giaBanLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.getCardsInfo();
    },

    getCardsInfo: function getCardsInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.DOI_THUONG_GET_CARD_INFO, {}, {
            cache: 1800,
            delay: 500
        }).success(function (respDone) {
            that.cards = respDone.data;
            that.loaiTheDropDown.clearAllItems();
            for (var i = 0; i < that.cards.length; i += 1) {
                that.loaiTheDropDown.addItem(that.cards[i].name, i > 0 ? false : true);
            }
            that.updateMenhGia();
        });
    },

    updateMenhGia: function updateMenhGia() {
        var currentCardName = this.loaiTheDropDown.getSelectedItem(),
            menhGiaItemNode,
            card,
            i,
            j,
            amountVnd,
            amountInGame;
        if (!this.cards) {
            return;
        }
        for (i = 0; i < this.cards.length; i += 1) {
            card = this.cards[i];
            if (card.name === currentCardName) {
                this.currentCard = card;
                this.menhGiaDropDown.clearAllItems();
                this.contentMenhGiaNode.removeAllChildren();
                for (j = 0; j < card.amounts.length; j += 1) {
                    amountVnd = card.amounts[j];
                    amountInGame = this.getGiaThe(amountVnd, card);
                    amountVnd = Utils.Number.format(amountVnd) + ' VND';
                    this.menhGiaDropDown.addItem(card.amounts[j], j > 0 ? false : true);
                    menhGiaItemNode = cc.instantiate(this.itemMenhGiaPrefab);
                    menhGiaItemNode.getComponent('RowTable').updateData(amountVnd, amountInGame);
                    this.contentMenhGiaNode.addChild(menhGiaItemNode);
                }
                this.updateGiaDoiThe();
            }
        }
    },

    updateGiaDoiThe: function updateGiaDoiThe() {
        if (this.currentCard) {
            this.giaBanLabel.string = 'Giá bán: ' + this.getGiaThe(this.menhGiaDropDown.getSelectedItem(), this.currentCard);
        }
    },

    getGiaThe: function getGiaThe(amountVnd, cardInfo) {
        var amount = amountVnd * cardInfo.exchange_rate;
        return Utils.Number.format(amount) + ' ' + CommonConstant.CurrencyType.findByName(this.currentCard.currency).DISPLAY_NAME;
    },

    confirmGetCard: function confirmGetCard(event) {
        var that = this;
        if (!this.currentCard) {
            return UiManager.openModal('Xin vui lòng chọn loại thẻ cào để đổi thưởng.');
        }
        NetworkManager.Http.fetch('POST', Url.Http.DOI_THUONG_GET_CARD, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            card_type: this.currentCard.name,
            amount: this.menhGiaDropDown.getSelectedItem()
        }).success(function (respDone) {
            var data = respDone.data;
            UiManager.openModal('Xin chúc mừng, bạn đã rút thành công thẻ ' + data.card_type + ' mệnh giá ' + data.card_amount + '\nPin: ' + data.card_pin + '\nSerial: ' + data.card_serial);
            that.doiTheTabView.activeByName('LichSu');
            that.lichSuDoiTabView.activeByName('LsDoiThe');
        }).setWaitingButton(event.target);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","DropDown":"DropDown","NetworkManager":"NetworkManager","TabView":"TabView","UiManager":"UiManager","Url":"Url","Utils":"Utils"}],"DropDown":[function(require,module,exports){
"use strict";
cc._RFpush(module, '88108TZBmtA2aItSoFka06a', 'DropDown');
// scripts\ui\DropDown.js

cc.Class({
    'extends': cc.Component,

    properties: {
        itemFontSize: 20,
        itemLineHeight: 60,
        selectEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var that = this;
        this.itemContainer = this.node.getChildByName('ContentDrop');
        this.itemContainer.active = false;
        // this.itemContainer.removeAllChildren();

        this.node.on(cc.Node.EventType.TOUCH_START, function () {
            that.openDropDown();
        });
    },

    /**
     * Set item to dropdown
     * @param {Object | String}  item     if item is object, must be {value: ..., label: 'string'}
     * @param {Boolean} isDefault
     */
    addItem: function addItem(item, isDefault) {
        var that = this,
            newItem = new cc.Node(),
            labelComponent = newItem.addComponent(cc.Label),
            itemContainer = this.node.getChildByName('ContentDrop'),
            itemLabel = item.label ? item.label : item;

        labelComponent.string = itemLabel;
        labelComponent.fontSize = this.itemFontSize;
        labelComponent.lineHeight = this.itemLineHeight;
        labelComponent.overflow = cc.Label.Overflow.SHRINK;
        labelComponent.verticalAlign = cc.Label.VerticalAlign.CENTER;
        labelComponent.horizontalAlign = cc.Label.HorizontalAlign.CENTER;
        newItem.width = itemContainer.width;
        newItem.height = this.itemLineHeight;

        if (isDefault) {
            this.getLabel().string = itemLabel;
            this.currentSelected = item;
        }
        newItem.on(cc.Node.EventType.TOUCH_START, function (event) {
            var label = that.getLabel();
            if (label.string === itemLabel) {
                return;
            }
            that.getLabel().string = itemLabel;
            that.currentSelected = item;
            that.selectEvents.forEach(function (selectEvent) {
                selectEvent.emit([item]);
            });
            event.bubbles = false;
        });
        itemContainer.addChild(newItem);
    },

    clearAllItems: function clearAllItems() {
        this.node.getChildByName('ContentDrop').removeAllChildren();
        this.getLabel().string = '';
    },

    closeDropdown: function closeDropdown() {
        var itemContainer = this.itemContainer;
        if (itemContainer.active) {
            itemContainer.runAction(cc.sequence([cc.scaleTo(0.1, 1, 0), cc.callFunc(function () {
                itemContainer.active = false;
            })]));
        }
    },

    openDropDown: function openDropDown() {
        var that = this,
            mouseListener,
            itemContainer = this.itemContainer;
        if (!itemContainer.active) {
            itemContainer.active = true;
            itemContainer.runAction(cc.scaleTo(0.1, 1, 1));
            mouseListener = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                onTouchBegan: function onTouchBegan() {
                    cc.eventManager.removeListener(mouseListener);
                    that.closeDropdown();
                }
            });
            setTimeout(function () {
                // set timeout to cocos doesn't trigger 'mouseListener' immediately
                cc.eventManager.addListener(mouseListener, -9e9);
            });
        }
    },

    getSelectedItem: function getSelectedItem() {
        return this.currentSelected;
    },

    getLabel: function getLabel() {
        return this.node.getChildByName('LblDrop').getComponent(cc.Label);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{}],"EffectAvatar":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8121aNQst5JppDFG1lPUfox', 'EffectAvatar');
// scripts\components\games\ui\EffectAvatar.js

cc.Class({
    "extends": cc.Component,

    properties: {
        radius: 45,
        timeRotate: 3,
        particleNode: cc.Node
    },

    onLoad: function onLoad() {
        this.run = false;
        this.time = 0;
        this.isIncrease = true;
    },

    update: function update(dt) {
        if (this.time >= 0.01) {
            if (!this.run) {
                this.time = 0;
                this.run = true;
                var particleSystem = this.particleNode.getComponent(cc.ParticleSystem);
                if (particleSystem) {
                    particleSystem.resetSystem();
                }
            }
        }
        if (this.isIncrease) {
            this.time += dt / this.timeRotate;
        }
        if (this.time >= 1) {
            this.time = 0;
        }
        var dirY = this.time < 0.5 ? 1 : -1;
        // x di chuyen giao dong dieu hoa => x = Rcos(2πt)
        // Duong tron x2 + y2 = R2 => y =sqrt(R2-x2)
        var x = this.radius * Math.cos(2 * Math.PI * this.time);
        var y = dirY * Math.sqrt(this.radius * this.radius - x * x);
        this.particleNode.position = cc.v2(x, y);
    }
});

cc._RFpop();
},{}],"EffectThangTrang":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0c9a42yfl1CQoqG/sbX7QRt', 'EffectThangTrang');
// scripts\components\games\mau_binh\EffectThangTrang.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        imgLeft: cc.Node,
        imgRight: cc.Node,
        scaleEffect: 1.75,
        timeDelayEffect: 0.3,
        imgEffect: {
            type: cc.Node,
            'default': []
        }
    },

    onLoad: function onLoad() {
        this.time = 0;
        this.direction = false;
        if (this.imgLeft && this.imgRight) {
            this.size = this.node.getContentSize();
            var size2 = this.imgRight.getContentSize();
            var targetPoint = this.size.width / 2 - size2.width / 2;
            this.imgLeft.x = -this.size.width / 2;
            this.imgRight.x = this.size.width / 2;
            this.imgLeft.opacity = 0;
            this.imgLeft.runAction(cc.fadeIn(0.1));
            var repeat1 = cc.repeatForever(cc.sequence(cc.moveTo(4, cc.v2(targetPoint, this.imgLeft.y)), cc.callFunc((function () {
                this.imgLeft.x = -targetPoint;
                this.imgLeft.opacity = 0;
                this.imgLeft.runAction(cc.fadeIn(0.1));
                this.imgLeft.runAction(cc.sequence(cc.delayTime(3), cc.fadeOut(0.8)));
            }).bind(this))));
            this.imgRight.opacity = 0;
            this.imgRight.runAction(cc.fadeIn(0.1));
            var repeat2 = cc.repeatForever(cc.sequence(cc.moveTo(4, cc.v2(-targetPoint, this.imgRight.y)), cc.callFunc((function () {
                this.imgRight.x = targetPoint;
                this.imgRight.opacity = 0;
                this.imgRight.runAction(cc.fadeIn(0.1));
                this.imgRight.runAction(cc.sequence(cc.delayTime(3), cc.fadeOut(0.8)));
            }).bind(this))));
            this.imgLeft.runAction(repeat1);
            this.imgLeft.runAction(cc.sequence(cc.delayTime(3), cc.fadeOut(0.8)));
            this.imgRight.runAction(repeat2);
            this.imgRight.runAction(cc.sequence(cc.delayTime(3), cc.fadeOut(0.8)));

            if (this.imgEffect.length > 0) {
                for (var i = 0; i < this.imgEffect.length; i += 1) {
                    this.imgEffect[i].active = false;
                }
            }
        }

        // Label
        var label = this.node.getComponentInChildren(cc.Label);
        if (label) {
            label.node.runAction(cc.repeatForever(cc.sequence(cc.scaleTo(this.timeDelayEffect / 2, 1.03), cc.scaleTo(this.timeDelayEffect / 2, 1))));
        }
    },

    update: function update(dt) {
        this.time += dt;
        if (this.imgEffect.length > 0 && this.time > this.timeDelayEffect) {
            this.time = 0;
            this.direction = !this.direction;
            this.spawnEffect(true);
            this.spawnEffect(false);
        }
    },

    spawnEffect: function spawnEffect(direction) {
        var randomRotateDirection = Utils.Number.random(0, 1) === 0 ? 1 : -1;
        var randomId = Utils.Number.random(0, this.imgEffect.length - 1);
        var randomNode = this.imgEffect[randomId];
        var node1 = cc.instantiate(randomNode);
        node1.active = true;
        node1.scale = this.scaleEffect;
        node1.position = cc.v2(0, 0);
        node1.runAction(cc.sequence(cc.moveTo(1.8, cc.v2(direction ? -this.size.width / 2 : this.size.width / 2, 0)).easing(cc.easeCircleActionOut()), cc.callFunc((function () {
            node1.destroy();
        }).bind(this))));
        node1.opacity = 0;
        node1.runAction(cc.sequence(cc.fadeTo(0.3, 200), cc.fadeOut(1)));
        node1.runAction(cc.rotateBy(3, randomRotateDirection * 360));
        this.node.addChild(node1);
    }
});

cc._RFpop();
},{"Utils":"Utils"}],"EventDispatcherConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5857djSnRBJPoY5L9abnbQv', 'EventDispatcherConstant');
// scripts\constant\EventDispatcherConstant.js

module.exports = {
    PROFILE: {
        UPDATE_INFO: 'profile.update_info',
        UPDATE_AVATAR: 'profile.update_avatar',
        UPDATE_MONEY: 'profile.update_money',
        UPDATE_EXP: 'profile.update_exp',
        UPDATE_UNREAD_MESS_COUNT: 'profile.update_unread_mess_count'
    },
    AUTH: {
        LOGIN: 'auth.login',
        LOGOUT: 'auth.logout'
    },
    TINH_NANG: {
        NEW: 'tinhnang.new'
    },
    GAME: {
        UPDATE_LIST: 'game.update_list'
    }
};

cc._RFpop();
},{}],"EventDispatcher":[function(require,module,exports){
"use strict";
cc._RFpush(module, '54450XUcsBEDa+4eG9Ot5J2', 'EventDispatcher');
// scripts\lib\EventDispatcher.js

var Utils = require('Utils'),
    BaseEventDispatcher,
    StackEventDispatcher,
    EventDispatcher;

BaseEventDispatcher = Utils.Class({
    $$constructor: function $$constructor() {
        this.clear();
    },

    clear: function clear() {
        this.eventListeners = {};
    },

    addEventListener: function addEventListener(eventName, listener, scope) {
        if (Utils.Type.isUndefined(eventName)) {
            throw 'Event name must be defined';
        }

        if (Utils.Type.isFunction(listener)) {
            var listenerWrapper = {
                listener: listener,
                scope: scope
            };
            this.eventListeners[eventName] = this.eventListeners[eventName] || [];
            this.eventListeners[eventName].push(listenerWrapper);
            return listenerWrapper;
        }
    },

    removeEventListener: function removeEventListener(eventName, listener, scope) {
        if (Utils.Type.isFunction(listener)) {
            this.eventListeners[eventName] = this.eventListeners[eventName] || [];
            Utils.Array.remove(this.eventListeners[eventName], {
                listener: listener,
                scope: scope
            });
        }
    },

    dispatchEvent: function dispatchEvent(eventName, obj) {
        var listeners = this.eventListeners[eventName] || [];
        Utils.Array.forEach(listeners, (function (listenerWrapper) {
            try {
                this._execute(listenerWrapper, obj);
            } catch (e) {
                cc.error(e);
            }
        }).bind(this));
    },

    _execute: function _execute(listenerWrapper, obj) {
        var listener = listenerWrapper.listener,
            scope = listenerWrapper.scope;
        try {
            if (scope) {
                listener.call(scope, obj);
            } else {
                listener(obj);
            }
        } catch (e) {
            cc.error(e);
        }
    }
});

StackEventDispatcher = Utils.Class({
    $$extends: BaseEventDispatcher,

    $$constructor: function $$constructor(limit) {
        this.$super.constructor.call(this);
        this.limit = limit || 0;
    },

    clear: function clear() {
        this.$super.clear.call(this);
        this.events = [];
    },

    pushEvent: function pushEvent(eventName, obj) {
        if (this.limit > 0) {
            Utils.Array.trimLeft(this.events, this.limit);
        }
        this.events.push({
            eventName: eventName,
            obj: obj,
            time: Date.now()
        });
    },

    popEvent: function popEvent() {
        return this.events.shift();
    },

    dispatchEvents: function dispatchEvents(checkFn) {
        var events = this.events.splice(0),
            self = this;
        events.forEach(function (event) {
            if (Utils.Type.isFunction(checkFn) && !checkFn(event)) {
                return;
            }
            self.dispatchEvent(event.eventName, event.obj);
        });
    }
});

/**
 * Register and deregister event system.
 *
 * If 'cache' option is enabled, everywhen dispatching action is ocurred,
 * the event will be stored to allow lately registered handlers to be executed
 * immediately.
 */
EventDispatcher = Utils.Class({
    $$extends: BaseEventDispatcher,

    $$constructor: function $$constructor(cache) {
        this.$super.constructor.call(this);
        this._setCache(cache);
    },

    clear: function clear() {
        this.$super.clear.call(this);
        this.clearCache();
    },

    clearCache: function clearCache() {
        this.cacheEvents = [];
    },

    disableCache: function disableCache() {
        this._setCache(false);
    },

    enableCache: function enableCache() {
        this._setCache(true);
    },

    _setCache: function _setCache(cache) {
        this.cache = cache;
        this.clearCache();
    },

    addEventListener: function addEventListener(eventName, listener, scope) {
        var listenerWrapper = this.$super.addEventListener.call(this, eventName, listener, scope);
        if (listenerWrapper) {
            if (this.cache && this.cacheEvents) {
                Utils.Array.forEach(this.cacheEvents, (function (event) {
                    if (event && event.eventName === eventName) {
                        this._execute(listenerWrapper, event.obj);
                    }
                }).bind(this));
            }
        }
    },

    dispatchEvent: function dispatchEvent(eventName, obj) {
        this.$super.dispatchEvent.call(this, eventName, obj);
        if (this.cache) {
            this.cacheEvents.push({
                eventName: eventName,
                obj: obj
            });
        }
    },

    create: function create(cache) {
        return new EventDispatcher(cache);
    },

    createStackEventDispatcher: function createStackEventDispatcher(limit) {
        return new StackEventDispatcher(limit);
    }
});

/**
 * Global EventDispatcher.
 *
 * @type {EventDispatcher}
 */
module.exports = new EventDispatcher();

cc._RFpop();
},{"Utils":"Utils"}],"Event":[function(require,module,exports){
"use strict";
cc._RFpush(module, '26b2ccmaaVO1aC2Bdb8uzg2', 'Event');
// scripts\components\event\Event.js

var NetworkManager = require('NetworkManager'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemEventDetailPrefab: cc.Prefab,
        eventContainerNode: cc.Node,
        eventItemPrefab: cc.Prefab,
        openEventId: {
            'default': null,
            visible: false
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.fetchEventList();
        this.itemEventDetailNode = cc.instantiate(this.itemEventDetailPrefab);
    },

    fetchEventList: function fetchEventList() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.EVENT_LIST, {}, {
            cache: 900,
            delay: 500
        }).success(function (tnResp) {
            var eventItems = tnResp.data,
                openEventId = Number.parseInt(that.openEventId);
            that.eventContainerNode.removeAllChildren();
            for (var i = 0; i < eventItems.length; i += 1) {
                that._initEventNode(eventItems[i]);
                if (openEventId === eventItems[i].event_id) {
                    that._openEventItem(eventItems[i]);
                }
            }
        });
    },

    _initEventNode: function _initEventNode(eventData) {
        var that = this,
            eventItemNode = cc.instantiate(this.eventItemPrefab);
        eventItemNode.getComponent('ItemEvent').updateData(eventData);
        this.eventContainerNode.addChild(eventItemNode);
        eventItemNode.on(cc.Node.EventType.TOUCH_END, function () {
            that._openEventItem(eventData);
        });
    },

    _openEventItem: function _openEventItem(eventData) {
        var that = this;
        that.eventContainerNode.parent.addChild(that.itemEventDetailNode);
        var itemEventComp = that.itemEventDetailNode.getComponent('ItemEvent');
        itemEventComp.updateData(eventData);
        itemEventComp.closeDetailMessage = function () {
            that.itemEventDetailNode.runAction(cc.sequence([cc.fadeOut(0.1), cc.callFunc(function () {
                that.itemEventDetailNode.removeFromParent(false);
            })]));
        };

        that.itemEventDetailNode.runAction(cc.fadeIn(0.1));
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"NetworkManager":"NetworkManager","Url":"Url"}],"FacebookInteract":[function(require,module,exports){
"use strict";
cc._RFpush(module, '01da0qZlPNJ2ra45COU1rV6', 'FacebookInteract');
// scripts\components\kiem_xu\FacebookInteract.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        shareFacebookNoteLabel: cc.Label,
        inviteFacebookNoteLabel: cc.Label,
        likeFacebookNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.loadFacebookSdk();
    },

    loadFacebookSdk: function loadFacebookSdk() {
        var that = this;
        if (!document.getElementById('fb-root')) {
            var fbRoot = document.createElement('div'),
                script = document.createElement('script');
            fbRoot.id = 'fb-root';
            script.id = 'facebook-jssdk';
            script.src = '//connect.facebook.net/en_US/all.js';
            document.body.appendChild(fbRoot);
            document.body.appendChild(script);

            window.fbAsyncInit = function () {
                that.getShareFacebookInfo();
            };
        } else {
            that.getShareFacebookInfo();
        }
    },

    getShareFacebookInfo: function getShareFacebookInfo() {
        var that = this;
        if (that.shareFacebookInfo) {
            return;
        }
        NetworkManager.Http.fetch('GET', Url.Http.SHARE_FACEBOOK, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }, {
            delay: 500
        }).success(function (respDone) {
            var facebookLikeComp = that.likeFacebookNode.getComponent('FacebookLike');
            window.FB.init({
                appId: respDone.data.app_id,
                status: true,
                cookie: true,
                xfbml: true,
                frictionlessRequests: true
            });
            that.shareFacebookInfo = respDone.data;
            that.shareFacebookNoteLabel.string = respDone.data.note;
            that.inviteFacebookNoteLabel.string = respDone.data.invite_friend.note;
            facebookLikeComp.initLikeButton(respDone.data.like_link);
            facebookLikeComp.onDisable();
        });
    },

    confirmShareFacebook: function confirmShareFacebook(event) {
        if (!this.shareFacebookInfo) {
            return;
        }
        window.FB.ui({
            method: 'feed',
            name: this.shareFacebookInfo.title,
            link: this.shareFacebookInfo.share_link,
            picture: this.shareFacebookInfo.image_link,
            caption: this.shareFacebookInfo.title,
            description: this.shareFacebookInfo.comment,
            message: ''
        }, function (response) {
            if (response && response.post_id) {
                NetworkManager.Http.fetch('POST', Url.Http.SHARE_FACEBOOK, {
                    username: AuthUser.username,
                    accesstoken: AuthUser.accesstoken
                }, {}).setWaitingButton(event.target);
            }
        });
    },

    confirmSendInviteFacebook: function confirmSendInviteFacebook(event) {
        if (!this.shareFacebookInfo) {
            return;
        }
        window.FB.ui({ method: 'apprequests',
            message: this.shareFacebookInfo.invite_friend.msg
        }, function (response) {
            if (response && response.to) {
                NetworkManager.Http.fetch('POST', Url.Http.INVITE_FACEBOOK, {
                    username: AuthUser.username,
                    accesstoken: AuthUser.accesstoken,
                    request_id: response.request,
                    recipient_ids: response.to.join(',')
                }, {}).success(function (resp) {
                    UiManager.openModal(resp.msg);
                }).setWaitingButton(event.target);
            }
        });
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"FacebookLike":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e2781d+6NZJR6WSNpZEofY1', 'FacebookLike');
// scripts\components\kiem_xu\FacebookLike.js

cc.Class({
    'extends': cc.Component,

    properties: {
        btnLike: cc.Node,
        lblInfo: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        var isNative = cc.sys.os === cc.sys.OS_ANDROID || cc.sys.os === cc.sys.OS_IOS;
        this.btnLike.active = isNative;
        this.lblInfo.active = isNative;
    },

    initLikeButton: function initLikeButton(likeLink) {
        var container = document.getElementById('FacebookLikeContainer'),
            likeElement = document.createElement('iframe'),
            gameDiv = document.getElementById('GameDiv'),
            posGameDiv = gameDiv.getBoundingClientRect(),
            likeNodeBox = this.node.getBoundingBoxToWorld(),
            scaleRate = gameDiv.offsetHeight / cc.winSize.height,
            width = 250,
            height = 80,
            yPos,
            likeElementScale;
        if (container) {
            return;
        }
        container = document.createElement('div');
        likeElement.src = 'https://www.facebook.com/plugins/like.php?href=' + encodeURIComponent(likeLink) + '&width=' + width + '&height=' + height + '&layout=standard&action=like&size=large&show_faces=true&share=false';
        likeElement.style.cssText = 'border:none; overflow:hidden;';
        likeElementScale = this.node.height * scaleRate / height * 0.8;
        likeElement.style.cssText += 'transform-origin: center;transform: scale(' + likeElementScale.toFixed(1) + ');';
        likeElement.width = width;
        likeElement.height = height;
        likeElement.scrolling = 'no';
        likeElement.frameborder = 0;
        likeElement.allowTransparency = true;

        yPos = gameDiv.offsetHeight + posGameDiv.top - (likeNodeBox.center.y * scaleRate + height / 2);
        container.style.cssText = 'position: absolute;width: 100%;text-align: center;top: ' + yPos + 'px;';
        container.id = 'FacebookLikeContainer';
        container.appendChild(likeElement);
        document.body.appendChild(container);
    },

    onEnable: function onEnable() {
        var container = document.getElementById('FacebookLikeContainer');
        if (container) {
            container.style.display = 'block';
        }
    },

    onDisable: function onDisable() {
        var container = document.getElementById('FacebookLikeContainer');
        if (container) {
            container.style.display = 'none';
        }
    },

    onLikeClick: function onLikeClick() {}
});

cc._RFpop();
},{}],"GameConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '39c9c/r9+VKkY8+M95js1tS', 'GameConstant');
// scripts\constant\GameConstant.js

var Utils = require('Utils');

var GameConstant = {
    /**
     * GAME: {
     *     ID: <game-id>,
     *     NAME: <game-name>,
     *     CMD: <game-cmd>,
     *     SCENE: <game-scene>,
     *     HAS_LOBBY: <game-lobby-is-used-or-not>,
     *     IS_MINIGAME: <is-minigame-or-not>,
     *     MINIGAME_PREFAB: <minigame-prefab>,
     *     GAME_MANAGER: <game-manager-class>,
     *     LOG: <game-manager-class-log>,
     *     ALONE: <play-alone-or-dont-see-others>,
     *     BUY_MONEY: <buy-money>,
     *     WARNING_MESSAGE_DURATION: <warning-message-duration>,
     *     GAME_OPTION_MODAL_PREFAB: <game-option-modal-prefab>,
     *     VISIBLE_SLOTS: <visible-slots>,
     *     MAX_COMMANDS_PER_MATCH: <max-commands-per-match>,
     *     TOP_PANEL_IN_GAME: {
     *         ENABLE: <is-enabled-or-not>,
     *         REGISTER_QUIT_GAME: <register-quit-game-is-enabled-or-not>,
     *         CHAT: <is-supported-chatting-or-not>,
     *     }
     * }
     */

    // special
    LOBBY: {
        NAME: 'Hall',
        SCENE: 'Lobby'
    },

    BA_CAY: {
        ID: 5,
        NAME: 'Ba Cây',
        CMD: 'BaCay',
        HAS_LOBBY: true,
        SCENE: 'GameplayBaCay',
        // GAME_MANAGER: 'BaCayGameManager',
        ICON: 'IconGameBaCay',
        LOG: false,
        VISIBLE_SLOTS: 7,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    MAU_BINH: {
        ID: 16,
        NAME: 'Mậu Binh',
        CMD: 'MauBinh',
        HAS_LOBBY: true,
        SCENE: 'GameplayMauBinh',
        GAME_MANAGER: 'MauBinhGameManager',
        ICON: 'IconGameMauBinh',
        LOG: false,
        BUY_MONEY: true,
        VISIBLE_SLOTS: 4,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    MINI_POKER: {
        ID: 8,
        NAME: 'MiniPoker',
        CMD: 'MiniPoker',
        HAS_LOBBY: false,
        IS_MINIGAME: true,
        MINIGAME_PREFAB: 'games/mini_poker/MiniGameMiniPoker',
        GAME_MANAGER: 'MiniPokerGameManager',
        ICON: 'IconGameMiniPoker',
        LOG: false,
        ALONE: true,
        VISIBLE_SLOTS: 1,
        MAX_COMMANDS_PER_MATCH: 20,
        WARNING_MESSAGE_DURATION: 1
    },

    VONG_QUAY: {
        ID: 9,
        NAME: 'Vòng quay may mắn',
        CMD: 'Wheel',
        HAS_LOBBY: false,
        IS_MINIGAME: true,
        MINIGAME_PREFAB: 'games/vong_quay/MiniGameVongQuay',
        // GAME_MANAGER: 'VongQuayGameManager',
        ICON: 'IconGameVongQuay',
        LOG: false,
        ALONE: true,
        VISIBLE_SLOTS: 1,
        MAX_COMMANDS_PER_MATCH: 20,
        WARNING_MESSAGE_DURATION: 1
    },

    XO_SO: {
        ID: 12,
        NAME: 'Xổ số',
        HAS_LOBBY: false,
        IS_MINIGAME: true,
        MINIGAME_PREFAB: 'games/xo_so/MiniGameXoSo',
        ICON: 'IconGameXoSo'
    },

    TAI_XIU: {
        ID: 7,
        NAME: 'Tài xỉu',
        CMD: 'TaiXiu',
        HAS_LOBBY: false,
        IS_MINIGAME: true,
        MINIGAME_PREFAB: 'games/tai_xiu/MiniGameTaiXiu',
        GAME_MANAGER: 'TaiXiuGameManager',
        ICON: 'IconGameTaiXiu',
        LOG: false,
        ALONE: true,
        MAX_COMMANDS_PER_MATCH: 10,
        WARNING_MESSAGE_DURATION: 1
    },

    XITO: {
        ID: 23,
        NAME: 'Xì tố',
        CMD: 'XiTo',
        HAS_LOBBY: true,
        GAME_OPTION_MODAL_PREFAB: 'games/xito/XiToOptionModal',
        SCENE: 'GameplayXito',
        GAME_MANAGER: 'XiToGameManager',
        ICON: 'IconGameXiTo',
        LOG: false,
        BUY_MONEY: true,
        VISIBLE_SLOTS: 5,
        MAX_COMMANDS_PER_MATCH: 100,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    XOC_DIA: {
        ID: 2,
        NAME: 'Xóc đĩa',
        CMD: 'XocDia',
        HAS_LOBBY: true,
        SCENE: 'GameplayXocDia',
        GAME_MANAGER: 'XocDiaGameManager',
        ICON: 'IconGameXocDia',
        LOG: false,
        VISIBLE_SLOTS: 8,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    BAU_CUA: {
        ID: 3,
        NAME: 'Bầu cua',
        CMD: 'BauCua',
        HAS_LOBBY: true,
        SCENE: 'GameplayBauCua',
        ICON: 'IconGameBauCua',
        GAME_MANAGER: 'BauCuaGameManager',
        LOG: false,
        VISIBLE_SLOTS: 9,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    SAN_THUONG: {
        ID: 6,
        NAME: 'Săn thưởng',
        CMD: 'ChickenFeed',
        HAS_LOBBY: false,
        SCENE: 'GameplaySanThuong',
        GAME_MANAGER: 'SanThuongGameManager',
        ICON: 'IconGameSanThuong',
        LOG: false,
        VISIBLE_SLOTS: 1,
        MAX_COMMANDS_PER_MATCH: 20,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: false,
            CHAT: false
        }
    },

    ROULTE: {
        ID: 4,
        NAME: 'Roulette',
        CMD: 'Roulette',
        HAS_LOBBY: true,
        SCENE: 'GameplayRoulette',
        GAME_MANAGER: 'RouletteGameManager',
        ICON: 'IconGameRoulette',
        LOG: false,
        VISIBLE_SLOTS: 8,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    PHOM: {
        ID: 19,
        NAME: 'Phỏm',
        CMD: 'Phom',
        HAS_LOBBY: true,
        GAME_OPTION_MODAL_PREFAB: 'games/phom/PhomOptionModal',
        SCENE: 'GameplayPhom',
        ICON: 'IconGamePhom',
        GAME_MANAGER: 'PhomGameManager',
        LOG: false,
        VISIBLE_SLOTS: 4,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    LIENG: {
        ID: 21,
        NAME: 'Liêng',
        CMD: 'Lieng',
        HAS_LOBBY: true,
        SCENE: 'GameplayLieng',
        GAME_MANAGER: 'LiengGameManager',
        ICON: 'IconGameLieng',
        LOG: false,
        BUY_MONEY: true,
        VISIBLE_SLOTS: 7,
        MAX_COMMANDS_PER_MATCH: 100,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    POKER: {
        ID: 18,
        NAME: 'Poker',
        CMD: 'Poker',
        HAS_LOBBY: true,
        SCENE: 'GameplayPoker',
        GAME_MANAGER: 'PokerGameManager',
        ICON: 'IconGamePoker',
        LOG: false,
        BUY_MONEY: true,
        VISIBLE_SLOTS: 7,
        MAX_COMMANDS_PER_MATCH: 100,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    TLMN: {
        ID: 1,
        NAME: 'Tiến lên miền nam',
        CMD: 'TLMN',
        HAS_LOBBY: true,
        SCENE: 'GameplayTLMN',
        ICON: 'IconGameTLMN',
        GAME_MANAGER: 'TLMNGameManager',
        LOG: false,
        VISIBLE_SLOTS: 4,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    TLMNSolo: {
        ID: 15,
        NAME: 'Tiến lên miền nam Solo',
        CMD: 'TLMN',
        HAS_LOBBY: true,
        SCENE: 'GameplayTLMN',
        GAME_MANAGER: 'TLMNGameManager',
        LOG: false,
        VISIBLE_SLOTS: 4,
        IS_SOLO: true,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    SAM: {
        ID: 13,
        NAME: 'Sâm',
        CMD: 'Sam',
        HAS_LOBBY: true,
        SCENE: 'GameplaySam',
        GAME_MANAGER: 'SamGameManager',
        ICON: 'IconGameSam',
        LOG: false,
        VISIBLE_SLOTS: 4,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    SAMSolo: {
        ID: 14,
        NAME: 'Sâm Solo',
        CMD: 'Sam',
        HAS_LOBBY: true,
        SCENE: 'GameplaySam',
        GAME_MANAGER: 'SamGameManager',
        LOG: false,
        VISIBLE_SLOTS: 4,
        IS_SOLO: true,
        TOP_PANEL_IN_GAME: {
            ENABLE: true,
            REGISTER_QUIT_GAME: true,
            CHAT: true
        }
    },

    findById: function findById(gameId) {
        return Utils.Object.findObject(this, 'ID', gameId);
    },

    loadIconsAtlas: function loadIconsAtlas(callback) {
        cc.loader.loadRes('atlats/AtlasIconGame', cc.SpriteAtlas, function (err, atlas) {
            GameConstant.iconsAtlas = atlas;
            if (callback) {
                callback();
            }
        });
    },

    getIconSpriteFrame: function getIconSpriteFrame(iconName) {
        if (this.iconsAtlas) {
            return this.iconsAtlas.getSpriteFrame(iconName);
        }
    },

    updateIconsServer: function updateIconsServer(icons) {
        this.iconsServer = icons;
    },

    getIconServer: function getIconServer(gameId) {
        if (this.iconsServer) {
            return this.iconsServer[gameId];
        }
    },

    updateGamePriorities: function updateGamePriorities(priorities) {
        this.gamePriorities = priorities;
    },

    getGamePriorities: function getGamePriorities() {
        return this.gamePriorities;
    }
};

module.exports = GameConstant;

cc._RFpop();
},{"Utils":"Utils"}],"GameHelpModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a0ddct0HrpLNbKKd6JX9eKZ', 'GameHelpModal');
// scripts\components\games\ui\GameHelpModal.js

var NetworkManager = require('NetworkManager'),
    Modal = require('Modal'),
    Url = require('Url');

cc.Class({
    'extends': Modal,

    properties: {
        content: {
            'default': null,
            type: cc.RichText,
            override: true
        }
    },

    // use this for initialization
    // onLoad: function () {

    // },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(gameId) {
        if (gameId >= 0) {
            var self = this;

            NetworkManager.Http.fetch('GET', Url.Http.GAME_HELP, {
                game_id: gameId
            }, {
                cache: 3600,
                delay: 500
            }).success(function (resp) {
                if (!self.isValid) {
                    return;
                }

                var scrollViewComp = self.node.getComponentInChildren(cc.ScrollView);
                if (scrollViewComp) {
                    scrollViewComp.scrollToTop();
                }

                var msg = 'Chưa có hướng dẫn.';
                if (resp.data) {
                    msg = resp.data.content || msg;
                }
                self.content.string = msg;
            });
        }
    }
});

cc._RFpop();
},{"Modal":"Modal","NetworkManager":"NetworkManager","Url":"Url"}],"GameItemDataWrapper":[function(require,module,exports){
"use strict";
cc._RFpush(module, '62c9fDA7+JNuKePpS1xlKgo', 'GameItemDataWrapper');
// scripts\components\games\ui\game_item\GameItemDataWrapper.js

var GameManager = require('GameManager');

cc.Class({
    'extends': cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(gameGroup) {
        var game, i;
        for (i = 0; i < gameGroup.length; i += 1) {
            game = gameGroup[i];
            if (game) {
                if (game.isSolo) {
                    this.soloGame = game;
                } else {
                    this.normalGame = game;
                }
            }
        }
        this.gameGroup = gameGroup;
    },

    selectSoloGame: function selectSoloGame() {
        GameManager.playGame(this.soloGame);
        this.node.destroy();
    },

    selectNormalGame: function selectNormalGame() {
        GameManager.playGame(this.normalGame);
        this.node.destroy();
    }
});

cc._RFpop();
},{"GameManager":"GameManager"}],"GameItem":[function(require,module,exports){
"use strict";
cc._RFpush(module, '54ea3R8MTlNxLOCTYvT6p0H', 'GameItem');
// scripts\components\games\ui\game_item\GameItem.js

var UrlImage = require('UrlImage'),
    UiManager = require('UiManager'),
    GameManager = require('GameManager'),
    GameConstant = require('GameConstant'),
    GameItemDataWrapper = require('GameItemDataWrapper'),
    EventDispatcher = require('EventDispatcher'),
    GameManagerConstant = require('GameManagerConstant');

cc.Class({
    'extends': GameItemDataWrapper,

    properties: {
        loadingNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        var animation = this.node.getComponent(cc.Animation),
            self = this;

        this.loadingAction = cc.sequence(cc.callFunc(function () {
            self.loadingNode.active = true;
        }), cc.delayTime(GameManager.JOIN_GAME_TIMEOUT / 1000), cc.callFunc(function () {
            self.loadingNode.active = false;
        }));

        function startAnimation() {
            if (animation) {
                animation.play();
            }
        }

        function stopAnimation() {
            if (animation) {
                animation.stop();
            }
        }
        this.node.on(cc.Node.EventType.MOUSE_ENTER, startAnimation);
        this.node.on(cc.Node.EventType.TOUCH_START, startAnimation);

        this.node.on(cc.Node.EventType.MOUSE_LEAVE, stopAnimation);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, stopAnimation);
        this.node.on(cc.Node.EventType.TOUCH_END, stopAnimation);

        EventDispatcher.addEventListener(GameManagerConstant.Event.JOIN_GAME, this.onJoinGame, this);
        EventDispatcher.addEventListener(GameManagerConstant.Event.JOIN_GAME_LOBBY, this.onJoinGame, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(GameManagerConstant.Event.JOIN_GAME, this.onJoinGame, this);
        EventDispatcher.removeEventListener(GameManagerConstant.Event.JOIN_GAME_LOBBY, this.onJoinGame, this);
    },

    init: function init(gameGroup) {
        GameItemDataWrapper.prototype.init.call(this, gameGroup);

        var game = this.normalGame || this.soloGame,
            gameNameLabel = this.node.getComponentInChildren(cc.Label),
            gameIcon = this.node.getComponentInChildren(UrlImage),
            gameIconSprite = this.node.getComponentInChildren(cc.Sprite),
            gameIconSpriteFrame,
            gameIconServer;

        if (gameNameLabel) {
            gameNameLabel.string = game.name;
        }

        gameIconServer = GameConstant.getIconServer(game.gameId);
        if (gameIconServer && gameIcon) {
            gameIcon.loadImage(gameIconServer);
        } else if (game.CONFIG && game.CONFIG.ICON && gameIconSprite) {
            gameIconSpriteFrame = GameConstant.getIconSpriteFrame(game.CONFIG.ICON);
            gameIconSprite.spriteFrame = gameIconSpriteFrame;
        } else if (gameIcon) {
            gameIcon.loadImage(game.logo);
        }
    },

    click: function click() {
        var self = this;
        if (self.normalGame || self.soloGame) {
            if (self.normalGame && self.normalGame.webview_url) {
                this._startLoading();
                UiManager.openWebView(self.normalGame.webview_url, self.normalGame.name, function () {
                    self._stopLoading();
                });
            } else if (self.normalGame && self.normalGame.id < 0) {
                this._startLoading();
                UiManager.openModalByName(self.normalGame.CONFIG.MINIGAME_PREFAB, function () {
                    self._stopLoading();
                });
            } else if (!self.normalGame || !self.soloGame) {
                GameManager.playGame(self.normalGame || self.soloGame);
            } else if (self.normalGame && GameManager.isAvailableGame(self.normalGame.gameId) && self.soloGame && GameManager.isAvailableGame(self.soloGame.gameId)) {
                UiManager.openModalByName('games/ui/play_type/PlayTypeOptionModal', function (newNode) {
                    newNode.getComponent(GameItemDataWrapper).init(self.gameGroup);
                });
            }
        }
    },

    onJoinGame: function onJoinGame(params) {
        var game = this.normalGame || this.soloGame;
        if (game && params && params.gameCmd === game.CONFIG.CMD) {
            if (params.isJoining) {
                this._startLoading();
            } else {
                this._stopLoading();
            }
        }
    },

    _startLoading: function _startLoading() {
        this.node.runAction(this.loadingAction);
    },

    _stopLoading: function _stopLoading() {
        try {
            this.node.stopAction(this.loadingAction);
        } catch (e) {}
        this.loadingNode.active = false;
    }
});

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","GameConstant":"GameConstant","GameItemDataWrapper":"GameItemDataWrapper","GameManager":"GameManager","GameManagerConstant":"GameManagerConstant","UiManager":"UiManager","UrlImage":"UrlImage"}],"GameManagerConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '414b8/R5jZG8r2fpIxZTueN', 'GameManagerConstant');
// scripts\games\GameManagerConstant.js

module.exports = {
    Event: {
        JOIN_ROOM: 'in_game.base.join_room',
        JOIN_ROOM_ERROR: 'in_game.base.join_room_error',
        LEAVE_ROOM: 'in_game.base.leave_room',

        JOIN_GAME: 'in_game.base.join_game',
        JOIN_GAME_LOBBY: 'in_game.base.join_game_lobby',

        UPDATE_REGISTER_QUIT_GAME_STATUS: 'in_game.base.update_register_quit_game_status',
        UPDATE_BETTING_VALUES: 'in_game.base.update_betting_values',
        UPDATE_USER_MONEY: 'in_game.base.update_user_money',
        PLAYER_ADDED: 'in_game.base.player_added',
        PLAYER_REMOVED: 'in_game.base.player_removed',
        WAITING_PLAYER_ADDED: 'in_game.base.waiting_player_added',
        WAITING_PLAYER_REMOVED: 'in_game.base.waiting_player_removed',
        NEW_MATCH_LOST_FOCUS: 'in_game.base.new_match_lost_focus'
    }
};

cc._RFpop();
},{}],"GameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4aca2AXOWlOJa0RO92OwMGg', 'GameManager');
// scripts\GameManager.js

var Utils = require('Utils'),
    GameConstant = require('GameConstant'),
    NetworkManager = require('NetworkManager'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    SmartFoxConstant = require('SmartFoxConstant'),
    GameManagerConstant = require('GameManagerConstant'),
    TinhNangManager = require('TinhNangManager'),
    UiManager = require('UiManager'),
    AudioManager = require('AudioManager'),
    PlatformImplement = require('PlatformImplement'),
    CommonConstant = require('CommonConstant'),
    MINIGAME_QUICK_ICON_PREFAB = 'games/minigame/MinigameQuickIcon',
    GameManager;

GameManager = {
    RAW_GAME_LIST: [],
    GAME_LIST: [],
    GAME_GROUP_LIST: [],
    JOIN_GAME_TIMEOUT: 10000,
    RECHECK_JOINED_ROOMS_INTERVAL: 15000,
    MAX_RECHECK_JOINED_ROOMS_TIMES: 4,

    /**
     * ACTIVE_GAMES: {
     *     MINI_GAMES: {
     *         gameId: {
     *             game: {},
     *             room: {},
     *             gameManager: {},
     *             prefab: {}
     *         }
     *     },
     *     MAIN_GAME: {
     *         game: {},
     *         room: {},
     *         gameManager: {}
     *     }
     * }
     */
    ACTIVE_GAMES: {
        MINI_GAMES: {},
        MAIN_GAME: null
    },

    JOINING_GAMES: {
        MINI_GAMES: {},
        MAIN_GAME: null
    },

    _init: function _init() {
        this.timeouts = [];

        EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.AUTH.LOGIN, this.onLogin, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.AUTH.LOGOUT, this.onLogout, this);

        EventDispatcher.addEventListener(GameManagerConstant.Event.JOIN_ROOM, this.onJoinRoom, this);
        EventDispatcher.addEventListener(GameManagerConstant.Event.JOIN_ROOM_ERROR, this.onJoinRoomError, this);
        EventDispatcher.addEventListener(GameManagerConstant.Event.LEAVE_ROOM, this.onLeaveRoom, this);
    },

    onTinhNangNew: function onTinhNangNew() {
        this._isTinhNangNewCalled = true;
        this.onUpdateGameList();
    },

    onLogin: function onLogin() {
        var self = this;
        self.getGameList(function (gameListData) {
            self.RAW_GAME_LIST = gameListData && gameListData.rooms || [];
            self.onUpdateGameList();

            var currentScene = cc.director.getScene(),
                canvas = currentScene && currentScene.children && currentScene.children[0],
                gameplay = canvas && canvas.getComponent('BaseGameplay');
            if (!gameplay) {
                // go to Hall if user doesn't play any main game
                Utils.Director.loadScene(CommonConstant.Scene.HALL, function () {
                    self._markJoiningMainGame(true, 1000);
                });
            }
        });

        if (!AudioManager.instance.isMusicPlaying()) {
            AudioManager.instance.playMusic();
        }

        this._scheduleRecheckJoinedRoomsTimeoutId = null;
        this._lastRequestPlayGame = 0;
        this._scheduleRecheckJoinedRooms(true);
    },

    onLogout: function onLogout() {
        var gameId, configs, miniGamePrefab;
        for (gameId in this.ACTIVE_GAMES.MINI_GAMES) {
            configs = this.ACTIVE_GAMES.MINI_GAMES[gameId];
            miniGamePrefab = configs && configs.prefab;
            if (miniGamePrefab) {
                if (cc.game.isPersistRootNode(miniGamePrefab)) {
                    miniGamePrefab.destroy();
                    cc.game.removePersistRootNode(miniGamePrefab);
                }
            }
        }
        this.ACTIVE_GAMES = {
            MINI_GAMES: {},
            MAIN_GAME: null
        };
        this.JOINING_GAMES = {
            MINI_GAMES: {},
            MAIN_GAME: null
        };
        this.RAW_GAME_LIST = [];
        this.GAME_LIST = [];
        this.GAME_GROUP_LIST = [];

        this.timeouts.forEach(function (timeoutId) {
            clearTimeout(timeoutId);
        });
        this.timeouts = [];

        this._isTinhNangNewCalled = false;

        UiManager.destroyModalByName(MINIGAME_QUICK_ICON_PREFAB);

        AudioManager.instance.stopMusic();

        PlatformImplement.returnLoginPage();

        this._cancelScheduleRecheckJoinedRooms();
    },

    onJoinRoom: function onJoinRoom(room, options) {
        var self = this,
            game,
            scene;

        options = options || {};

        // lobby
        if (this.isLobby(room)) {
            game = this.findGameLobbyByRoomId(room.id);
            if (game) {
                scene = CommonConstant.Scene.LOBBY;
                if (scene) {
                    this.ACTIVE_GAMES.MAIN_GAME = this._createGameRuntimeConfigs(game, room);
                    Utils.Director.loadScene(scene, function () {
                        self._markJoiningMainGame(false);
                        self._dispatchJoinGameLobby(game.gameId, false);
                    });
                }
            }
        } else {
            var gameId = this._parseGameId(room.groupId);
            game = this.findGameById(gameId);
            game = game || {
                CONFIG: GameConstant.findById(gameId) || {}
            };
            if (game) {
                var gameManagerClass = game.CONFIG && game.CONFIG.GAME_MANAGER && Utils.Module.get(game.CONFIG.GAME_MANAGER),
                    gameManager;
                if (gameManagerClass) {
                    gameManager = new gameManagerClass(game, room.id);
                    if (options.rejoin) {
                        gameManager.fetchInitialGameData();
                    }
                    // main game
                    if (!game.CONFIG.IS_MINIGAME) {
                        scene = game.CONFIG && game.CONFIG.SCENE;
                        if (scene) {
                            this.ACTIVE_GAMES.MAIN_GAME = this._createGameRuntimeConfigs(game, room, gameManager);
                            Utils.Director.loadScene(scene, function () {
                                self.leaveAllGameLobbies();
                                self._markJoiningGame(gameId, false);
                            });
                        }
                    }
                    // minigame
                    else {
                            var oldConfigs = this.ACTIVE_GAMES.MINI_GAMES[gameId],
                                newConfigs = this._createGameRuntimeConfigs(game, room, gameManager),
                                prefab;

                            if (oldConfigs && oldConfigs.autoOpen && !oldConfigs.game) {
                                cc.js.mixin(oldConfigs, newConfigs);
                            } else {
                                this.ACTIVE_GAMES.MINI_GAMES[gameId] = newConfigs;
                            }

                            prefab = game && game.CONFIG && game.CONFIG.MINIGAME_PREFAB;
                            if (prefab) {
                                cc.loader.loadRes(prefab, function (err, prefab) {
                                    var configs = self.ACTIVE_GAMES.MINI_GAMES[gameId],
                                        newNode;
                                    if (!configs.prefab) {
                                        newNode = cc.instantiate(prefab);
                                        newNode.active = false;
                                        cc.game.addPersistRootNode(newNode);
                                        configs.prefab = newNode;
                                        if (configs.autoOpen) {
                                            newNode.active = true;
                                        }
                                        self._markJoiningGame(gameId, false);
                                    }
                                });
                            }
                        }
                }
            }
        }
    },

    onJoinRoomError: function onJoinRoomError() {},

    onLeaveRoom: function onLeaveRoom(room) {
        if (this.isLobby(room)) {
            if (this.ACTIVE_GAMES.MAIN_GAME && this.ACTIVE_GAMES.MAIN_GAME.room && this.ACTIVE_GAMES.MAIN_GAME.room.id === room.id) {
                this.ACTIVE_GAMES.MAIN_GAME = null;
            }
        } else {
            var gameId = this._parseGameId(room.groupId),
                game = this.findGameById(gameId);
            if (game) {
                if (!game.CONFIG.IS_MINIGAME) {
                    if (this.ACTIVE_GAMES.MAIN_GAME && this.ACTIVE_GAMES.MAIN_GAME.room && this.ACTIVE_GAMES.MAIN_GAME.room.id === room.id) {
                        this.ACTIVE_GAMES.MAIN_GAME = null;
                    }

                    if (game.CONFIG && game.CONFIG.HAS_LOBBY) {
                        this.enterGameLobby(gameId);
                    } else {
                        Utils.Director.loadScene(CommonConstant.Scene.HALL);
                    }
                } else {
                    var configs = this.ACTIVE_GAMES.MINI_GAMES[gameId],
                        miniGamePrefab = configs && configs.prefab;
                    if (miniGamePrefab && cc.game.isPersistRootNode(miniGamePrefab)) {
                        miniGamePrefab.destroy();
                        cc.game.removePersistRootNode(miniGamePrefab);
                    }
                    delete this.ACTIVE_GAMES.MINI_GAMES[gameId];
                }
            }
        }
    },

    onUpdateGameList: function onUpdateGameList() {
        if (!this._isTinhNangNewCalled) {
            return;
        }

        var serverGameList = [];
        this.RAW_GAME_LIST.forEach(function (game) {
            if (game && Utils.Type.isDefined(game.gameId) && TinhNangManager.choPhep(game.gameId)) {
                serverGameList.push(game);
            }
        });
        this.filterGameList(serverGameList);

        this.joinDaemonMiniGames();

        if (TinhNangManager.choPhep('cn')) {
            UiManager.openModalByName(MINIGAME_QUICK_ICON_PREFAB, function (newNode) {
                if (!cc.game.isPersistRootNode(newNode)) {
                    cc.game.addPersistRootNode(newNode);
                }
            });
        } else {
            UiManager.destroyModalByName(MINIGAME_QUICK_ICON_PREFAB);
        }

        EventDispatcher.dispatchEvent(EventDispatcherConstant.GAME.UPDATE_LIST);
    },

    _parseGameId: function _parseGameId(gameId) {
        try {
            gameId = parseInt(gameId, 10);
        } catch (e) {}
        return gameId;
    },

    _createGameRuntimeConfigs: function _createGameRuntimeConfigs(game, room, gameManager) {
        return {
            game: game,
            room: room,
            gameManager: gameManager
        };
    },

    getGameRuntimeConfigs: function getGameRuntimeConfigs(cmd) {
        if (!cmd) {
            return;
        }

        var configs = this.ACTIVE_GAMES.MAIN_GAME,
            miniGameConfigs = this.ACTIVE_GAMES.MINI_GAMES,
            gameId;
        if (this._isCorrectGameRuntimeConfigs(configs, cmd)) {
            return configs;
        }
        for (gameId in miniGameConfigs) {
            configs = miniGameConfigs[gameId];
            if (this._isCorrectGameRuntimeConfigs(configs, cmd)) {
                return configs;
            }
        }
        return null;
    },

    _isCorrectGameRuntimeConfigs: function _isCorrectGameRuntimeConfigs(configs, cmd) {
        if (configs && configs.game && configs.game.CONFIG && configs.game.CONFIG.CMD === cmd) {
            return true;
        }
        return false;
    },

    getLobbyGameRuntimeConfigs: function getLobbyGameRuntimeConfigs() {
        var configs = this.ACTIVE_GAMES.MAIN_GAME;
        if (configs && !configs.gameManager) {
            return configs;
        }
        return null;
    },

    markMiniGameAutoOpen: function markMiniGameAutoOpen(gameId) {
        this.ACTIVE_GAMES.MINI_GAMES[gameId] = {
            autoOpen: true
        };
    },

    filterGameList: function filterGameList(serverGameList) {
        var groups = {},
            game,
            gameId,
            gameConfigs,
            gameGroup,
            gameGroupTmp,
            scene,
            i;

        this.GAME_LIST = [];
        for (i = 0; i < serverGameList.length; i += 1) {
            game = serverGameList[i];
            gameId = this._parseGameId(game.gameId);
            gameConfigs = GameConstant.findById(gameId) || {};
            game.CONFIG = gameConfigs;
            if (!('isSolo' in game)) {
                game.isSolo = !!game.gameCode && /.+Solo$/.test(game.gameCode);
            }
            gameConfigs.IS_SOLO = game.isSolo;
            gameConfigs.IS_MINIGAME = game.isMiniGame;
            gameConfigs.NAME = game.name;

            // grouping
            groups[game.scene] = groups[game.scene] || [];
            groups[game.scene].push(game);
        }

        for (scene in groups) {
            gameGroupTmp = [];
            gameGroup = groups[scene];
            gameConfigs = null;
            gameGroup.forEach(function (game) {
                if (!gameConfigs && !Utils.Object.isEmpty(game.CONFIG)) {
                    gameConfigs = game.CONFIG;
                }
            });
            gameGroup.forEach((function (game) {
                if (gameConfigs && Utils.Object.isEmpty(game.CONFIG)) {
                    game.CONFIG = gameConfigs;
                }
                if (this.isAvailableGameToDisplay(game)) {
                    gameGroupTmp.push(game);
                    this.GAME_LIST.push(game);
                }
            }).bind(this));
            groups[scene] = gameGroupTmp;
        }

        groups = Utils.Object.values(groups);
        groups.sort((function (g1, g2) {
            return this._findMaxGamePriorityInGroup(g1) - this._findMaxGamePriorityInGroup(g2);
        }).bind(this));
        this.GAME_GROUP_LIST = groups;
    },

    _findMaxGamePriorityInGroup: function _findMaxGamePriorityInGroup(group) {
        var max = -1,
            i;
        for (i = 0; i < group.length; i += 1) {
            max = Math.max(max, group[i].priority);
        }
        return max;
    },

    findGameById: function findGameById(gameId) {
        return Utils.Object.findObject(this.GAME_LIST, 'gameId', gameId);
    },

    findGameLobbyByRoomId: function findGameLobbyByRoomId(roomId) {
        return Utils.Object.findObject(this.GAME_LIST, 'id', roomId);
    },

    isLobby: function isLobby(room) {
        if (room && room.groupId === GameConstant.LOBBY.NAME) {
            return true;
        }
        return false;
    },

    isAvailableGame: function isAvailableGame(gameId) {
        var game = this.findGameById(gameId);
        return game && game.CONFIG && game.CONFIG.CMD && game.CONFIG.GAME_MANAGER && Utils.Module.get(game.CONFIG.GAME_MANAGER) && TinhNangManager.choPhep(gameId);
    },

    isAvailableGameToDisplay: function isAvailableGameToDisplay(game) {
        return this.isSmartFoxGame(game) || this.isPopupOrWebViewGame(game);
    },

    isSmartFoxGame: function isSmartFoxGame(game) {
        return game && game.CONFIG && game.CONFIG.CMD && game.CONFIG.GAME_MANAGER && Utils.Module.get(game.CONFIG.GAME_MANAGER);
    },

    isPopupOrWebViewGame: function isPopupOrWebViewGame(game) {
        return game && (game.CONFIG && game.CONFIG.ID && !game.CONFIG.CMD || game.webview_url);
    },

    _isJoiningMainGame: function _isJoiningMainGame() {
        var status = this.JOINING_GAMES.MAIN_GAME;
        return status && status.isJoining;
    },

    _isJoiningMiniGame: function _isJoiningMiniGame(gameId) {
        var status = this.JOINING_GAMES.MINI_GAMES[gameId];
        return status && status.isJoining;
    },

    _isJoiningGame: function _isJoiningGame(gameId) {
        var game = this.findGameById(gameId);
        if (game && game.CONFIG) {
            if (game.CONFIG.IS_MINIGAME) {
                return this._isJoiningMiniGame(gameId);
            } else {
                return this._isJoiningMainGame();
            }
        }
        return false;
    },

    _markJoiningMainGame: function _markJoiningMainGame(isJoining, timeoutIfIsJoining) {
        var id = Math.random() + '.' + Date.now(),
            self = this;
        if (isJoining) {
            if (!Utils.Type.isNumber(timeoutIfIsJoining)) {
                timeoutIfIsJoining = self.JOIN_GAME_TIMEOUT;
            }
            self.JOINING_GAMES.MAIN_GAME = {
                isJoining: isJoining,
                id: id
            };
            self.timeouts.push(setTimeout(function () {
                var status = self.JOINING_GAMES.MAIN_GAME;
                if (status && status.id === id) {
                    status.isJoining = false;
                }
            }, timeoutIfIsJoining));
        } else {
            self.timeouts.push(setTimeout(function () {
                self.JOINING_GAMES.MAIN_GAME = {
                    isJoining: isJoining,
                    id: id
                };
            }, 300));
        }
    },

    _markJoiningMiniGame: function _markJoiningMiniGame(gameId, isJoining, timeoutIfIsJoining) {
        var id = Math.random() + '.' + Date.now(),
            self = this;
        if (isJoining) {
            if (!Utils.Type.isNumber(timeoutIfIsJoining)) {
                timeoutIfIsJoining = self.JOIN_GAME_TIMEOUT;
            }
            self.JOINING_GAMES.MINI_GAMES[gameId] = {
                isJoining: isJoining,
                id: id
            };
            self.timeouts.push(setTimeout(function () {
                var status = self.JOINING_GAMES.MINI_GAMES[gameId];
                if (status && status.id === id) {
                    status.isJoining = false;
                }
            }, timeoutIfIsJoining));
        } else {
            self.timeouts.push(setTimeout(function () {
                self.JOINING_GAMES.MINI_GAMES[gameId] = {
                    isJoining: isJoining,
                    id: id
                };
            }, 300));
        }
    },

    _markJoiningGame: function _markJoiningGame(gameId, isJoining, timeoutIfIsJoining) {
        var game = this.findGameById(gameId);
        if (game && game.CONFIG) {
            if (game.CONFIG.IS_MINIGAME) {
                this._markJoiningMiniGame(gameId, isJoining, timeoutIfIsJoining);
            } else {
                this._markJoiningMainGame(isJoining, timeoutIfIsJoining);
            }
            this._dispatchJoinGame(gameId, isJoining);
        }
    },

    _dispatchJoinGameLobby: function _dispatchJoinGameLobby(gameId, isJoining) {
        var game = this.findGameById(gameId);
        if (game && game.CONFIG) {
            EventDispatcher.dispatchEvent(GameManagerConstant.Event.JOIN_GAME_LOBBY, {
                gameId: gameId,
                gameCmd: game.CONFIG.CMD,
                isJoining: isJoining
            });
        }
    },

    _dispatchJoinGame: function _dispatchJoinGame(gameId, isJoining) {
        var game = this.findGameById(gameId);
        if (game && game.CONFIG) {
            EventDispatcher.dispatchEvent(GameManagerConstant.Event.JOIN_GAME, {
                gameId: gameId,
                gameCmd: game.CONFIG.CMD,
                isJoining: isJoining
            });
        }
    },

    _cancelScheduleRecheckJoinedRooms: function _cancelScheduleRecheckJoinedRooms() {
        if (this._scheduleRecheckJoinedRoomsTimeoutId) {
            clearTimeout(this._scheduleRecheckJoinedRoomsTimeoutId);
            this._scheduleRecheckJoinedRoomsTimeoutId = null;
        }
    },

    _scheduleRecheckJoinedRooms: function _scheduleRecheckJoinedRooms(tryToPlay) {
        var self = this;
        if (this._scheduleRecheckJoinedRoomsTimeoutId) {
            return;
        }

        if (tryToPlay) {
            this._lastRequestPlayGame = Date.now();
        }
        this._scheduleRecheckJoinedRoomsTimeoutId = setTimeout(function () {
            self._recheckJoinedRooms();
        }, this.RECHECK_JOINED_ROOMS_INTERVAL);
    },

    _recheckJoinedRooms: function _recheckJoinedRooms() {
        var self = this;
        NetworkManager.SmartFox.getJoinedRooms().forEach(function (room) {
            var r = self.ACTIVE_GAMES.MAIN_GAME && self.ACTIVE_GAMES.MAIN_GAME.room,
                gameId = self._parseGameId(room.groupId);

            // check main game
            if (r) {
                if (r.id === room.id) {
                    return;
                }
            }

            // check minigame
            r = self.ACTIVE_GAMES.MINI_GAMES && self.ACTIVE_GAMES.MINI_GAMES[gameId] && self.ACTIVE_GAMES.MINI_GAMES[gameId].room;
            if (r && r.id === room.id) {
                return;
            }

            // rejoin
            self.onJoinRoom(room, {
                rejoin: true
            });
        });

        this._scheduleRecheckJoinedRoomsTimeoutId = null;
        if (Date.now() - this._lastRequestPlayGame < this.RECHECK_JOINED_ROOMS_INTERVAL * this.MAX_RECHECK_JOINED_ROOMS_TIMES) {
            this._scheduleRecheckJoinedRooms();
        }
    },

    /**
     * Get game list.
     *
     * @param  {Function} callback    callback when get game list success, with argument is event of extension response
     */
    getGameList: function getGameList(callback) {
        NetworkManager.SmartFox.sendGlobalEndpoint({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.GET_GAME_LIST.ID)
        }, callback);
    },

    /**
     * Get betting values by currency of a game.
     *
     * @param  {Number}   gameId      game id
     * @param  {Function} callback    callback when get success, with argument is event of extension response
     */
    getBettingValues: function getBettingValues(gameId, callback) {
        NetworkManager.SmartFox.sendGlobalEndpoint({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.GET_BETTING_VALUES.ID),
            gameId: NetworkManager.SmartFox.type.int(gameId)
        }, callback);
    },

    /**
     * Get all room list of a game. Use this method restrictly.
     *
     * @param  {Number}   gameId      game id
     * @param  {Function} callback    callback when get success, with argument is event of extension response
     */
    getGameRoomList: function getGameRoomList(gameId, callback) {
        NetworkManager.SmartFox.sendGlobalEndpoint({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.GET_GAME_ROOM_LIST.ID),
            gameId: NetworkManager.SmartFox.type.int(gameId)
        }, callback);
    },

    /**
     * Create a game.
     *
     * @param  {Number}   gameId      game id
     * @param  {Function} callback    callback when create game success, with argument is event of extension response
     */
    createGame: function createGame(gameId, callback) {
        if (!this.isAvailableGame(gameId)) {
            return;
        }

        if (this._isJoiningGame(gameId)) {
            return;
        }

        this._markJoiningGame(gameId, true);
        var self = this,
            handler = function handler(event) {
            var params = event && event.params || {};
            if (params.result === 0) {
                self._markJoiningGame(gameId, false);
            }
            if (Utils.Type.isFunction(callback)) {
                callback();
            }
        };

        NetworkManager.SmartFox.sendGlobalEndpoint({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.CREATE_GAME.ID),
            gameId: NetworkManager.SmartFox.type.int(gameId)
        }, handler);

        this._scheduleRecheckJoinedRooms(true);
    },

    /**
     * Enter a game.
     *
     * @param  {Number}   gameId      game id
     * @param  {Object}   gameConfigs game configs, common data: currency, isSolo, betting
     * @param  {Function} callback    callback when enter game success, with argument is event of extension response
     */
    enterGame: function enterGame(gameId, gameConfigs, callback) {
        if (!this.isAvailableGame(gameId)) {
            return;
        }

        if (this._isJoiningGame(gameId)) {
            return;
        }

        this._markJoiningGame(gameId, true);
        var self = this,
            handler = function handler(event) {
            if (event && event.result === 0) {
                self._markJoiningGame(gameId, false);
            }
            if (Utils.Type.isFunction(callback)) {
                callback();
            }
        };

        NetworkManager.SmartFox.sendGlobalEndpoint({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.ENTER_GAME.ID),
            gameId: NetworkManager.SmartFox.type.int(gameId),
            gameConfigs: NetworkManager.SmartFox.type.sfsObject(gameConfigs)
        }, handler);

        this._scheduleRecheckJoinedRooms(true);
    },

    /**
     * Try to play a game with corresponding action based on its config.
     * - Mini game:
     *   + Daemon game: join room
     *   + Normal game: create game
     * - Main game:
     *   + Has lobby: join lobby room
     *   + Has no lobby: create game
     *
     * @param  {Object} game game object
     */
    playGame: function playGame(game) {
        if (game && game.CONFIG) {
            var gameId = game.CONFIG.ID;

            if (this._isJoiningGame(gameId)) {
                return;
            }

            // minigame
            if (game.CONFIG.IS_MINIGAME && game.CONFIG && game.CONFIG.CMD) {
                var miniGameData = this.getGameRuntimeConfigs(game.CONFIG.CMD),
                    prefab = miniGameData && miniGameData.prefab,
                    scene = cc.director.getScene();
                // minigame is created
                if (prefab) {
                    if (!prefab.isChildOf(scene)) {
                        scene.addChild(prefab);
                    }
                    prefab.active = true;
                } else {
                    this.markMiniGameAutoOpen(gameId);

                    // create new one
                    if (!game.isDaemonRoom) {
                        this.createGame(gameId);
                    }
                    // join daemon room
                    else {
                            this.joinDaemonMiniGame(gameId);
                        }
                }
            }
            // main game
            else if (game.CONFIG) {
                    // enter lobby
                    if (game.CONFIG.HAS_LOBBY) {
                        this.enterGameLobby(gameId);
                    }
                    // create game directly
                    else {
                            this.createGame(gameId);
                        }
                }
        }
    },

    joinDaemonMiniGames: function joinDaemonMiniGames() {
        var game, i;
        for (i = 0; i < this.GAME_LIST.length; i += 1) {
            game = this.GAME_LIST[i];
            this.joinDaemonMiniGame(game.gameId);
        }
    },

    joinDaemonMiniGame: function joinDaemonMiniGame(gameId) {
        if (!this.isAvailableGame(gameId)) {
            return;
        }

        if (this._isJoiningGame(gameId)) {
            return;
        }

        var game = this.findGameById(gameId),
            self = this;
        if (game.isDaemonRoom && game.id > 0) {
            this.getGameRoomList(game.gameId, function (gameRoomListData) {
                var rooms = gameRoomListData.rooms || [],
                    roomId;
                if (rooms.length > 0) {
                    roomId = rooms[0].id;
                    if (roomId > 0 && !NetworkManager.SmartFox.isJoinedInRoom(roomId)) {
                        self._markJoiningGame(gameId, true);
                        NetworkManager.SmartFox.joinRoom(roomId);
                        self._scheduleRecheckJoinedRooms(true);
                    }
                }
            });
        }
    },

    enterGameLobby: function enterGameLobby(gameId) {
        if (!this.isAvailableGame(gameId)) {
            return;
        }

        if (this._isJoiningMainGame()) {
            return;
        }

        this._markJoiningMainGame(true);
        this._dispatchJoinGameLobby(gameId, true);

        var game = this.findGameById(gameId);
        if (game) {
            NetworkManager.SmartFox.joinRoom(game.id);
            this._scheduleRecheckJoinedRooms(true);
        }
    },

    leaveAllGameLobbies: function leaveAllGameLobbies() {
        var self = this;
        NetworkManager.SmartFox.getJoinedRooms().forEach(function (room) {
            if (self.isLobby(room)) {
                NetworkManager.SmartFox.leaveRoom(room.id);
            }
        });
    }
};

GameManager._init();

module.exports = GameManager;

cc._RFpop();
},{"AudioManager":"AudioManager","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","GameManagerConstant":"GameManagerConstant","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","SmartFoxConstant":"SmartFoxConstant","TinhNangManager":"TinhNangManager","UiManager":"UiManager","Utils":"Utils"}],"GameplayBauCua":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'b39495VJyZFVZ8ZApY57ySN', 'GameplayBauCua');
// scripts\components\games\bau_cua\GameplayBauCua.js

var GameConstant = require('GameConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    BaseMainGameplay = require('BaseMainGameplay'),
    BauCuaConstant = require('BauCuaConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        slotInfor: {
            'default': [],
            type: cc.Node

        },
        banker: cc.Node,
        chipPrefab: cc.Prefab,
        bowDice: cc.Node,
        parentChipBetting: cc.Node,
        nhiKetQuaList: {
            'default': [],
            type: cc.Sprite
        },
        spriteFrameKetQua: {
            'default': [],
            type: cc.SpriteFrame
        },
        timeLabel: cc.Label,
        timeCountDow: cc.Sprite,
        resultList: {
            'default': [],
            type: cc.Label
        },
        bow: cc.Node,
        stateGameLabel: cc.Label,
        gridBuyPot: cc.Node,
        panelBuyPot: cc.Node,
        itemBuyPot: cc.Prefab,
        btnX2: cc.Button,
        btnCancelBet: cc.Button,
        btnRebet: cc.Button,
        gameCmd: {
            'default': GameConstant.BAU_CUA.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {

        this.listChipBetting = [];
        //this.bow = this.bowDice.getChildByName('ImgBat');

        this.moneyBetSelect = 0;
        this.time = 0;

        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.BETTING_SUCCESS, this.onBettingSuccess, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.SHAKE_BOW_DICE, this.onShakeBow, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.ADD_LIST_BETTING, this._addChipBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.PLAYER_BETTING_STATE, this._playerBettingState, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.FINISH, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.CANCEL_BET, this.onCancelBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.BETTING_UPDATEGAME, this.onBettingUpdate, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.MASTER_CANEL_BET, this.onMasterCencelBet, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.CHANGE_STATE, this.onChangeState, this);
        this.gameManager.eventDispatchers.local.addEventListener(BauCuaConstant.Event.MASTER_SELL_POT, this.onMasterSellPot, this);

        this._disableAllButton();
    },

    $onUpdate: function $onUpdate() {
        this._checkOnFocus();
        if (this.gameManager.gameState === BauCuaConstant.GameState.PLAYER_BETTING || this.gameManager.gameState === BauCuaConstant.GameState.MASTER_CANEL_BET) {
            var count = Math.floor((this.time - Date.now()) / 1000);
            count = count >= 0 ? count : 0;
            this.timeLabel.string = count;
            if (count <= 0) {
                this.timeLabel.node.active = false;
                this.timeCountDow.node.active = false;
            }
        }
    },

    $onDestroy: function $onDestroy() {
        if (this.xocAudioId) {
            this.audioManager.stopEffect(this.xocAudioId);
        }
    },

    $onFocus: function $onFocus() {
        if (this.gameManager.gameState !== BauCuaConstant.GameState.FINISH) {
            this.bow.position = cc.v2(0, 0);
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.showEfectWin(false);
            }
        }
        if (this.gameManager.gameState !== BauCuaConstant.GameState.EFFECT) {
            var anim = this.bowDice.getComponent(cc.Animation);
            anim.stop('Shake');
            if (this.xocAudioId) {
                this.audioManager.stopEffect(this.xocAudioId);
            }
        }
        if (this.gameManager.gameState === BauCuaConstant.GameState.EFFECT) {
            this.bowDice.position = cc.v2(0, 0);
        }
    },

    onClickCloseBuyPot: function onClickCloseBuyPot() {
        this.panelBuyPot.active = false;
    },

    onMasterSellPot: function onMasterSellPot(params) {
        //{money: 200, action: 10, command: 20, pot: 0}
        var self = this;
        if (!this.panelBuyPot.active) {
            this.panelBuyPot.active = true;
            this.gridBuyPot.removeAllChildren();
        }
        var pot = cc.instantiate(this.itemBuyPot);
        var potComponent = pot.getComponent('BauCuaBuyPot');
        potComponent.setDataPot(this.spriteFrameKetQua[params.pot], params.money, params.pot);
        pot.on(cc.Node.EventType.TOUCH_START, function () {
            self._selectBuyPot(this.node);
        }, potComponent);
        this.gridBuyPot.addChild(pot);
    },

    _selectBuyPot: function _selectBuyPot(potNode) {
        var pot = potNode.getComponent('BauCuaBuyPot');
        this.gameManager.sendBuyPot(pot.pot);
    },

    openBuyPot: function openBuyPot() {
        this.panelBuyPot.active = true;
    },

    onChangeState: function onChangeState() {
        switch (this.gameManager.gameState) {
            case BauCuaConstant.GameState.EFFECT:
                this.stateGameLabel.string = 'Nhà cái bắt đầu xóc!';
                this._disableAllButton();
                break;
            case BauCuaConstant.GameState.PLAYER_BETTING:
                this.stateGameLabel.string = 'Hãy chọn cửa để đặt!';
                if (this.gameManager.history.length > 0 && !this.gameManager.isMaster) {
                    this.btnRebet.interactable = true;
                }
                this.audioManager.playTurnStart();
                break;
            case BauCuaConstant.GameState.MASTER_CANEL_BET:
                this.stateGameLabel.string = 'Nhà cái bán cược!';
                this._disableAllButton();
                break;
            case BauCuaConstant.GameState.FINALIZING:
                this.stateGameLabel.string = 'Kết quả!';
                this._disableAllButton();
                break;
        }
    },

    _disableAllButton: function _disableAllButton() {
        this.btnRebet.interactable = false;
        this.btnX2.interactable = false;
        this.btnCancelBet.interactable = false;
    },

    _checkOnFocus: function _checkOnFocus() {
        if (this.gameManager.gameState !== BauCuaConstant.GameState.FINALIZING) {
            this.bow.position = cc.v2(0, 0);
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.showEfectWin(false);
            }
        }
        if (this.gameManager.gameState !== BauCuaConstant.GameState.EFFECT) {
            var anim = this.bowDice.getComponent(cc.Animation);
            anim.stop('Shake');
            if (this.xocAudioId) {
                this.audioManager.stopEffect(this.xocAudioId);
            }
        } else {
            this.bowDice.position = cc.v2(0, 0);
        }
    },

    _enableNodeWhenLoad: function _enableNodeWhenLoad(isEnable) {
        this.timeCountDow.node.active = isEnable;
        this.timeLabel.node.active = isEnable;
    },

    _showTimeState: function _showTimeState(time) {
        var anim = this.bowDice.getComponent(cc.Animation);
        anim.stop('Shake', 5);
        if (this.xocAudioId) {
            this.audioManager.stopEffect(this.xocAudioId);
        }
        this.bowDice.position = cc.v2(0, 0);
        this._enableNodeWhenLoad(true);
        var action = cc.rotateBy(5, 360);
        this.timeCountDow.node.runAction(cc.repeatForever(action));
        this.time = Date.now() + time;
    },

    onMasterCencelBet: function onMasterCencelBet(params) {
        this._showTimeState(params.time);
        this._activeSellCancelPot(true);
    },

    _activeSellCancelPot: function _activeSellCancelPot(isActive) {
        if (this.gameManager.isMaster && isActive) {
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.activeSellPotBauCua(isActive);
            }
        } else {
            for (var j = 0; j < this.slotInfor.length; j += 1) {
                var potComponent1 = this.slotInfor[j].getComponent('SlotInfor');
                potComponent1.activeSellPotBauCua(false);
            }
        }
    },

    onBettingUpdate: function onBettingUpdate(params) {
        this.audioManager.playChipBay();
        for (var i = 0; i < params.info.length; i += 1) {
            var chip,
                playerParent = this.findPlayerNodeByName(params.info[i].userName),
                chipComponent,
                slotComponent,
                myMoney = 0;
            chip = cc.instantiate(this.chipPrefab);
            if (playerParent) {
                chip.parent = playerParent.node.parent;
                chip.position = playerParent.node;
            }
            chipComponent = chip.getComponent('Chip');
            chipComponent.activeSelectChip(false);
            chipComponent.moneyLabel.node.active = false;
            chip.scale = cc.v2(0.5, 0.5);
            chipComponent.init(params.info[i].money);
            chipComponent = chip.getComponent(cc.Button);
            chipComponent.enabled = false;
            // chipComponent =
            chip.removeComponent('ButtonScaler');
            // chipComponent.removeComponent();
            slotComponent = this.slotInfor[params.id].getComponent('SlotInfor');
            slotComponent.init();
            if (params.info[i].username === AuthUser.username) {
                myMoney = params.info[i].money;
            }
            slotComponent.setMoneyPot(myMoney, params.info[i].money);
            slotComponent.addPlayerBetToPot(params.info[i].userName, params.info[i].money);
            var moveChip = cc.moveTo(0.5, cc.v2(this.slotInfor[params.id].x, this.slotInfor[params.id].y)).easing(cc.easeOut(2.0));
            chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
                this.destroy();
            }, chip)));
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}
        var potComponent = this.slotInfor[params.pot].getComponent('SlotInfor');
        this._moveChipToPlayer(params.username, this.slotInfor[params.pot]);
        if (params.username === AuthUser.username) {
            this.btnX2.interactable = false;
            this.btnCancelBet.interactable = false;
        }
        potComponent.removeMoneyPot(params.username);
    },
    _bankerPayChip: function _bankerPayChip(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            if (Object.keys(this.slotInfor[pots[i]].getComponent('SlotInfor').playerBetList).length > 0) {
                this._moveChipToPlayer(this.slotInfor[pots[i]], this.banker);
            }
        }
    },

    onFinishGame: function onFinishGame(params) {
        var self = this;
        this.onClickCloseBuyPot();
        var action = cc.sequence(cc.callFunc(function () {
            self._activeSellCancelPot(false);
        }), cc.callFunc(function () {
            self._setKetQua(params.dices);
        }), cc.callFunc(function () {
            self._openBow();
        }), cc.delayTime(2), cc.callFunc(function () {
            self._showSlostWin(params.potWin);
        }), cc.callFunc(function () {
            self._bankerPayChip(params.potWin);
        }), cc.delayTime(1), cc.callFunc(function () {
            self._payChipToPlayer(params.potWin);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._showMoneyFinish(params.players);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._moveChipToBanker();
        }), cc.callFunc(function () {
            self._showBankerMoneyFinish(params.banker);
        }), cc.callFunc(function () {
            self._addResult(params.dices);
        }), cc.callFunc(function () {
            self._clearPlayerInPot();
        }), cc.delayTime(2), cc.callFunc(function () {
            self._clearEfectFinish();
        }));
        this.node.runAction(action);
    },
    _payChipToPlayer: function _payChipToPlayer(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            var slot = this.slotInfor[pots[i]].getComponent('SlotInfor');
            this._findPlayerWinInSlost(slot.playerBetList, pots[i]);
        }
    },
    _addResult: function _addResult(params) {
        for (var i = 0; i < params.length; i += 1) {
            if (this.resultList[params[i]] === 99) {
                for (var j = 0; j < this.resultList.length; j += 1) {
                    this.resultList[j].string = 0;
                }
            }
            this.resultList[params[i]].string = parseInt(this.resultList[params[i]].string) + 1;
        }
    },

    _clearEfectFinish: function _clearEfectFinish() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].clearEffects();
        }
    },

    _moveChipToPlayer: function _moveChipToPlayer(player, createPosition, money) {
        var chip, playerParent, chipComponent;
        this.audioManager.playChipBay();
        for (var i = 0; i < 3; i += 1) {

            if (Utils.Type.isString(player)) {
                playerParent = this.findPlayerNodeByName(player);
                if (playerParent) {
                    playerParent = playerParent.node;
                }
            } else {
                playerParent = player;
            }
            if (playerParent) {
                chip = cc.instantiate(this.chipPrefab);
                chip.parent = playerParent.parent;
                chip.position = createPosition;
                chipComponent = chip.getComponent('Chip');
                chipComponent.activeSelectChip(false);
                chipComponent.moneyLabel.node.active = false;
                chip.removeComponent('ButtonScaler');
                chip.removeComponent(cc.Button);
                chip.scale = cc.v2(0.5, 0.5);
                chipComponent.init(money);
                var action = cc.moveTo(0.5, cc.v2(playerParent.x, playerParent.y)).easing(cc.easeOut(2.0));

                chip.runAction(cc.sequence(cc.delayTime(i * 0.05), action, cc.callFunc(function () {
                    this.destroy();
                }, chip)));
            }
        }
    },

    _moveChipToBanker: function _moveChipToBanker() {
        var self = this;
        for (var i = 0; i < self.slotInfor.length; i += 1) {
            var slotComponent = this.slotInfor[i].getComponent('SlotInfor');
            if (!slotComponent.isWin) {
                if (slotComponent.chipFackeList.length > 0) {
                    this._moveChipToPlayer(self.banker, self.slotInfor[i]);
                }
            }
        }
    },

    _findPlayerWinInSlost: function _findPlayerWinInSlost(player, pot) {
        var self = this;
        var slotComponent = self.slotInfor[pot].getComponent('SlotInfor');
        slotComponent.destroyChipFacke();
        var arr = Object.keys(player);
        for (var i = 0; i < arr.length; i += 1) {
            self._moveChipToPlayer(arr[i], self.slotInfor[pot]);
        }
    },

    _setKetQua: function _setKetQua(params) {
        for (var i = 0; i < params.length; i += 1) {
            this.nhiKetQuaList[i].spriteFrame = this.spriteFrameKetQua[params[i]];
        }
    },

    _showSlostWin: function _showSlostWin(params) {
        //var self = this;
        for (var j = 0; j < this.slotInfor.length; j += 1) {
            var slotDisable = this.slotInfor[j].getComponent('SlotInfor');
            slotDisable.disablePotEfect();
        }
        for (var i = 0; i < params.length; i += 1) {
            var slot = this.slotInfor[params[i]].getComponent('SlotInfor');
            slot.showEfectWin(true);
            //self._findPlayerWinInSlost(slot.playerBetList, params[i]);
            slot.isWin = true;
        }
    },

    _disableEfectSlostWin: function _disableEfectSlostWin() {
        for (var i = 0; i < this.slotInfor.length; i += 1) {
            var slot = this.slotInfor[i].getComponent('SlotInfor');
            slot.showEfectWin(false);
            slot.isWin = false;
        }
    },

    _showMoneyFinish: function _showMoneyFinish(params) {
        for (var i = 0; i < params.length; i += 1) {
            var player = this.findPlayerNodeByName(params[i].userName);
            if (player) {
                player.setFinishEffect(params[i].moneyExchange);
                if (params[i].userName === AuthUser.username) {
                    if (params[i].moneyExchange > 0) {
                        this.audioManager.playWin();
                    } else {
                        this.audioManager.playLose();
                    }
                }
            }
        }
    },

    _showBankerMoneyFinish: function _showBankerMoneyFinish(params) {
        if (params.userName !== undefined) {
            var banker = this.findPlayerNodeByName(params.userName);
            if (banker) {
                banker = banker.getComponent('PlayerUI');
                banker.setFinishEffect(params.moneyExchange);
            }
        }
    },

    _clearPlayerInPot: function _clearPlayerInPot() {
        var self = this;
        for (var i = 0; i < self.slotInfor.length; i += 1) {
            var slotComponent = self.slotInfor[i].getComponent('SlotInfor');
            slotComponent.playerBetList = {};
            slotComponent.totallMoneyLong = 0;
            slotComponent.myMoneyLong = 0;
            slotComponent.potX = 0;
            slotComponent.setMoneyPot(0, 0);
            slotComponent.destroyChipFacke();
        }
    },

    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 3, username: "phamvanthien25554"}
        var chip,
            playerParent = this.findPlayerNodeByName(params.username),
            chipComponent,
            slotComponent,
            isInit = false,
            myMoney = 0;
        chip = cc.instantiate(this.chipPrefab);
        if (playerParent) {
            chip.parent = playerParent.node.parent;
            chip.position = playerParent.node;
        }
        chipComponent = chip.getComponent('Chip');
        chipComponent.activeSelectChip(false);
        chip.scale = cc.v2(0.5, 0.5);
        for (var i = 0; i < this.gameManager.bettingList.length; i++) {
            if (this.gameManager.bettingList[i] == params.money) {
                chipComponent.init(params.money, BauCuaConstant.ChipColor.findById(i).NAME);
                isInit = true;
                break;
            }
        }
        if (!isInit) {
            chipComponent.moneyLabel.node.active = false;
            chipComponent.init(params.money);
        }
        chipComponent = chip.getComponent(cc.Button);
        chipComponent.enabled = false;
        chip.removeComponent('ButtonScaler');
        slotComponent = this.slotInfor[params.pot].getComponent('SlotInfor');
        slotComponent.init();
        if (params.username === AuthUser.username) {
            myMoney = params.money;
            this.btnX2.interactable = true;
            this.btnCancelBet.interactable = true;
        }
        slotComponent.setMoneyPot(myMoney, params.money);
        slotComponent.addPlayerBetToPot(params.username, params.money);
        for (var j = 0; j < this.gameManager.bettingList.length; j++) {
            if (this.gameManager.bettingList[j] == params.money) {
                var newVec1 = this.slotInfor[params.pot].getChildByName(j.toString()).convertToWorldSpace(cc.v2(0, 0));
                var newVec2 = this.node.convertToNodeSpaceAR(newVec1);
                var moveChip = cc.moveTo(0.3, newVec2).easing(cc.easeOut(2.0));
                chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
                    this.destroy();
                    slotComponent.caculateChip();
                }, chip)));
            }
        }
        this.audioManager.playChipBay();
    },

    onShakeBow: function onShakeBow() {
        this._disableEfectSlostWin();
        var self = this;
        var anim = this.bowDice.getComponent(cc.Animation);
        var action = cc.sequence(cc.callFunc(self._closeBow()), cc.delayTime(1.5), cc.callFunc(function () {
            anim.play('Shake');
            self.xocAudioId = self.audioManager.playXoc(true);
        }, this));
        this.bow.runAction(action);
    },

    clickReBet: function clickReBet() {
        this.gameManager.sendReBet();
    },

    clickDoubleBet: function clickDoubleBet() {
        this.gameManager.sendDoubleBet();
    },

    clickCancelBet: function clickCancelBet() {
        this.gameManager.sendCancelBet();
    },

    clickRequestBanker: function clickRequestBanker() {
        this.gameManager.sendRequestBanker();
    },

    _openBow: function _openBow() {
        var self = this;
        self.timeLabel.node.active = false;
        self.timeCountDow.node.active = false;
        var actionBowDice = cc.sequence(
        //cc.moveTo(1, cc.p(0, 0)),
        cc.scaleTo(0.5, 2.5, 2.5), cc.delayTime(0.5), cc.callFunc(function () {
            var action = cc.moveTo(1, cc.p(-90, 0)).easing(cc.easeOut(2.0));
            self.bow.runAction(action);
        }));

        this.bowDice.runAction(actionBowDice);
    },

    _closeBow: function _closeBow() {
        var self = this;
        var actionBowDice = cc.sequence(
        //cc.moveTo(1, cc.p(0, 0)),
        cc.scaleTo(0.5, 1.28, 1.28), cc.delayTime(0.5), cc.callFunc(function () {
            var action = cc.moveTo(1, cc.p(0, 0)).easing(cc.easeOut(2.0));
            self.bow.runAction(action);
        }));

        this.bowDice.runAction(actionBowDice);
        // var action = cc.moveTo(1, cc.p(0, 0));
        // this.bow.runAction(action);
    },

    _playerBettingState: function _playerBettingState(params) {
        this._showTimeState(params.time);
    },

    _showTimeCountDow: function _showTimeCountDow(params) {
        this.timeLabel.string = params;
    },

    _addChipBetting: function _addChipBetting(params) {
        var chipSelect,
            self = this,
            chipComponent;
        this.parentChipBetting.removeAllChildren();
        for (var i = 0; i < params.length; i += 1) {
            chipSelect = cc.instantiate(this.chipPrefab);
            this.listChipBetting.push(chipSelect);
            chipComponent = chipSelect.getComponent('Chip');
            chipComponent.init(params[i], BauCuaConstant.ChipColor.findById(i).NAME);
            chipSelect.on(cc.Node.EventType.TOUCH_START, function () {
                this.activeSelectChip(true);
                self._selectChip(this.node);
            }, chipComponent);
            this.parentChipBetting.addChild(chipSelect);
        }
        this._selectChip(this.listChipBetting[0]);
    },

    _removeSelectChip: function _removeSelectChip() {
        for (var i = 0; i < this.listChipBetting.length; i += 1) {
            var chip = this.listChipBetting[i].getComponent('Chip');
            chip.activeSelectChip(false);
        }
    },

    _selectChip: function _selectChip(chipSelect) {
        this._removeSelectChip();
        var chip = chipSelect.getComponent('Chip');
        chip.activeSelectChip(true);
        this.moneyBetSelect = chip.money;
    }
});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","BauCuaConstant":"BauCuaConstant","GameConstant":"GameConstant","Utils":"Utils"}],"GameplayLieng":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'fa970BMRsFESp03nM/3N81w', 'GameplayLieng');
// scripts\components\games\lieng\GameplayLieng.js

var LiengConstant = require('LiengConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    Card = require('Card'),
    Slider = require('Slider'),
    GameConstant = require('GameConstant'),
    BaseMainGameplay = require('BaseMainGameplay'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        cardPrefab: cc.Prefab,
        chipPrefab: cc.Prefab,
        dealer: cc.Node,
        totalMoneyCallLabel: cc.Label,
        countDownTimeLabel: cc.Label,
        gameStateLabel: cc.Label,
        bettingSlider: Slider,
        chipContainer: cc.Node,
        currencyPiImage: {
            'default': [],
            type: cc.Node
        },
        bettingButtonsList: {
            'default': [],
            type: cc.Button
        },
        chipTemplateList: {
            'default': [],
            type: cc.Node
        },
        gameCmd: {
            'default': GameConstant.LIENG.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.START_TIME, this.onShowStartTime, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.USER_BET, this.onBettingSuccess, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.CHANGE_STATE, this.onChangeStateGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.CHANGE_TURN, this.onChangeTurn, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.DRAW_CARD, this.onDrawCard, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.FINISH_GAME, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.UPDATE_GAME, this.updateInfoGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(LiengConstant.Event.REFRESH_GAME, this.restartGameWhenNewMatch, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_INFO, this.onUpdateUserInfo, this);
        this.playerNodeList[0].node.parent.zIndex = 1;
    },

    // called every frame, uncomment this function to activate update callback
    $onUpdate: function $onUpdate() {
        if (this.gameManager) {
            if (this.gameManager.gameState === LiengConstant.GameState.WAITING_FOR_NEW_GAME || this.gameManager.gameState === LiengConstant.GameState.FINISH || this.gameManager.gameState === LiengConstant.GameState.FINALIZING) {
                var count = Math.floor((this.countDownTime - Date.now()) / 1000);
                count = count >= 0 ? count : 0;
                this.countDownTimeLabel.string = count;
                if (count === 0) {
                    this.countDownTimeLabel.node.active = false;
                    this.gameStateLabel.node.active = false;
                    if (this.gameManager.gameState === LiengConstant.GameState.FINISH || this.gameManager.gameState === LiengConstant.GameState.FINALIZING) {
                        this.restartGame();
                        this.gameStateLabel.string = 'Ván mới sẽ được bắt đầu trong giây lát.';
                        this.gameStateLabel.node.active = true;
                        this.gameManager.gameState = LiengConstant.GameState.NONE;
                    }
                }
            }
        }
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================
    bettingCall: function bettingCall() {
        this.gameManager.bet(LiengConstant.Action.CALL);
        this.bettingSlider.node.active = false;
        this.audioManager.playButtonClick();
    },
    bettingCheck: function bettingCheck() {
        this.gameManager.bet(LiengConstant.Action.CHECK);
        this.bettingSlider.node.active = false;
        this.audioManager.playButtonClick();
    },
    bettingFold: function bettingFold() {
        this.gameManager.bet(LiengConstant.Action.FOLD);
        this.bettingSlider.node.active = false;
        this.audioManager.playButtonClick();
    },
    bettingNormal: function bettingNormal() {
        if (this.bettingSlider.node.active) {
            this.gameManager.bet(LiengConstant.Action.BET, this.bettingSlider.currentValue);
            this.bettingSlider.node.active = false;
        } else {
            this.bettingSlider.node.active = true;
        }
        this.audioManager.playButtonClick();
    },
    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onShowStartTime: function onShowStartTime(time) {
        this.restartGame();
        this.gameStateLabel.string = 'Chuẩn bị ván mới';
        this.gameStateLabel.node.active = true;
        this.countDownTime = Date.now() + time;
        this.countDownTimeLabel.string = Math.floor(time / 1000);
        this.countDownTimeLabel.node.active = true;
    },

    onBettingSuccess: function onBettingSuccess(params) {
        var playerUI = this.findPlayerNodeByName(params.data.userName);
        if (playerUI && playerUI.player) {
            playerUI.clearCountDown();
            if (playerUI.player.data.money === 0) {
                playerUI.setEffect(this.convertTypeBetting(LiengConstant.Action.ALL_HAND));
            } else {
                playerUI.setEffect(this.convertTypeBetting(params.action));
            }
            if (params.action === LiengConstant.Action.FOLD) {
                if (AuthUser.username === params.data.userName) {
                    playerUI.getComponent('PlayerUIXiTo').currentPlayerFold();
                } else {
                    playerUI.getComponent('PlayerUIXiTo').fold();
                }
            }
            this.onShowBetting(params, playerUI);
        }
    },

    onChangeTurn: function onChangeTurn(params) {
        var i = 0;
        var player;
        if (this.bettingSlider) {
            this.bettingSlider.node.active = false;
        }
        this.audioManager.playTurnStart();
        //update state player
        for (i = 0; i < this.playerNodeList.length; i += 1) {
            var playerUI = this.playerNodeList[i];
            player = playerUI.player;
            if (player) {
                if (player.data.username === params.data.userName) {
                    var dt = 0;
                    if (params.__execInfo__) {
                        dt = params.__execInfo__.dt;
                    }
                    playerUI.setCountDown(params.data.time - dt);
                    playerUI.clearEffects();

                    if (this.playerNodeList[0].player.data.username === params.data.userName) {
                        this.setCurrentPlayerInTurn(params.data.allowedActions, params.data.minBetting, params.data.maxBetting);
                    } else {
                        this.disableBettingButtons(true);
                    }
                } else {
                    if (player.data.state === LiengConstant.PlayerState.ALL_IN) {
                        playerUI.setEffect(this.convertTypeBetting(LiengConstant.Action.ALL_HAND));
                    }

                    if (player.data.state === LiengConstant.PlayerState.FOLDED) {
                        if (AuthUser.username === player.data.username) {
                            playerUI.getComponent('PlayerUIXiTo').currentPlayerFold();
                        } else {
                            playerUI.getComponent('PlayerUIXiTo').fold();
                        }
                    }
                }
            }
        }
        this.onReDrawCard();
    },

    onDrawCard: function onDrawCard() {
        var card,
            count = 0,
            time = 0.3,
            timeDelay = 0.06,
            rotation = 0,
            indexZ = 20,
            i = 0,
            j = 0;
        this.hideStartTime();

        for (i = 0; i < this.playerNodeList.length; i += 1) {
            if (this.playerNodeList[i].player && this.playerNodeList[i].player.data.handSize > 0 && this.playerNodeList[i].player.data.state !== LiengConstant.PlayerState.OFF_MONEY) {
                var playerUIXiTo = this.playerNodeList[i].node.getComponent('PlayerUIXiTo');
                var player = this.playerNodeList[i].player.data;

                for (j = playerUIXiTo.getNumberActiveChildren(); j < player.handSize; j += 1) {
                    this.playerNodeList[i].node.zIndex = indexZ;
                    card = cc.instantiate(this.cardPrefab);
                    card.setScale(0.5, 0.5);
                    card.zIndex = indexZ;
                    card.parent = this.dealer;

                    indexZ -= 1;
                    count += 1;
                    var cardId;
                    if (i === 0 && this.playerNodeList[i].player.data.state !== LiengConstant.PlayerState.FOLD) {
                        cardId = player.cards[j];
                    } else {
                        if (this.gameCmd === GameConstant.XITO.CMD && player.handSize < this.gameManager.gameType) {
                            cardId = player.publicCards[j - (player.handSize - player.publicCards.length)];
                        } else {
                            cardId = null;
                        }
                    }
                    this.drawCardEffect(card, this.playerNodeList[i], time, timeDelay * count, rotation, cardId);
                }
            }
        }
    },

    onFinishGame: function onFinishGame(params) {
        var dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.onShowFinishTime(params.data.time - dt);
        this.disableBettingButtons(true);
        if (this.gameCmd === GameConstant.XITO.CMD) {
            this.bettingPanel.active = false;
        } else {
            this.bettingSlider.node.active = false;
        }
        for (var i = 0; i < params.data.players.length; i += 1) {
            var playerUI = this.findPlayerNodeByName(params.data.players[i].userName);
            if (playerUI) {
                this.setCallMoneyPlayer(playerUI, false, 0);
                if (params.data.players[i].cards) {
                    if (this.gameCmd === GameConstant.XITO.CMD) {
                        playerUI.node.getComponent('PlayerUIXiTo').showAllCards(params.data.players[i].cards, params.data.players[i].bestCards, params.data.players[i].bestCardsType, this.gameCmd, params.data.time / 1000);
                    } else {
                        var bestCardsType = '';
                        if ('Điểm' === params.data.players[i].typeCards) {
                            bestCardsType = params.data.players[i].point + ' ' + params.data.players[i].typeCards;
                        } else {
                            bestCardsType = params.data.players[i].typeCards;
                        }
                        playerUI.node.getComponent('PlayerUIXiTo').showAllCards(params.data.players[i].cards, params.data.players[i].cards, bestCardsType, this.gameCmd, params.data.time / 1000);
                    }
                }

                if (playerUI.player.data.state !== LiengConstant.PlayerState.FOLD) {
                    playerUI.setFinishEffect(params.data.players[i].moneyExchange);
                    if (params.data.players[i].moneyExchange > 0) {
                        Utils.Node.destroyAllChildrenInNode(this.chipContainer);
                        // this.chipContainer.removeAllChildren();
                        var container = this.calculateNumberChipType(params.data.players[i].moneyExchange, this.chipContainer);
                        var pos2InWorld = container.parent.convertToWorldSpace(container.position);
                        container.parent = playerUI.node;
                        if (playerUI.player.data.username !== AuthUser.username) {
                            container.setScale(0.7);
                        }
                        var p = playerUI.node.convertToNodeSpace(pos2InWorld);
                        container.position = p;
                        var containerAction = cc.sequence(cc.delayTime(1.5), cc.moveTo(0.3, cc.p(0, 0)), cc.removeSelf());
                        containerAction.easing(cc.easeQuadraticActionOut());
                        container.runAction(containerAction);
                        this.audioManager.playChipBay();
                    }
                    if (params.data.players[i].userName === AuthUser.username) {
                        if (params.data.players[i].moneyExchange > 0) {
                            this.audioManager.playWin();
                        } else {
                            this.audioManager.playLose();
                        }
                    }
                }
            }
        }
        // this.dealer.removeAllChildren();
        // Utils.Node.destroyAllChildrenInNode(this.dealer);
    },

    // update info game
    updateInfoGame: function updateInfoGame(params) {
        this.coutUpdateGame = 1;
        var i = 0;
        if (params.allData.totalBetting) {
            this.calculateNumberChipType(params.allData.totalBetting, this.chipContainer);
            this.totalMoneyCallLabel.string = Utils.Number.format(params.allData.totalBetting);
        }
        if (this.gameManager.currency === 'XU') {
            for (i = 0; i < this.currencyPiImage.length; i += 1) {
                this.currencyPiImage[i].active = false;
            }
        }
        //update state player
        this.initAllBettingButtons();
        var player, dt;
        if (params.data.gameState === LiengConstant.GameState.FINISH || params.data.gameState === LiengConstant.GameState.FINALIZING) {
            dt = 0;
            if (params.__execInfo__) {
                dt = params.__execInfo__.dt;
            }
            this.onShowFinishTime(params.data.time - dt);
        }
        for (i = 0; i < this.playerNodeList.length; i += 1) {
            var playerUI = this.playerNodeList[i];
            player = playerUI.player;
            if (player) {
                if (params.data.gameState >= LiengConstant.GameState.ROUND) {
                    switch (player.data.state) {
                        case LiengConstant.PlayerState.FOLDED:
                            playerUI.setEffect(this.convertTypeBetting(LiengConstant.Action.FOLD));
                            if (AuthUser.username === player.data.username) {
                                playerUI.getComponent('PlayerUIXiTo').currentPlayerFold();
                            } else {
                                playerUI.getComponent('PlayerUIXiTo').fold();
                            }
                            break;
                        case LiengConstant.PlayerState.IN_TURN:
                            dt = 0;
                            if (params.__execInfo__) {
                                dt = params.__execInfo__.dt;
                            }
                            playerUI.setCountDown(params.data.time - dt);
                            break;
                        case LiengConstant.PlayerState.ALL_IN:
                            playerUI.setEffect(this.convertTypeBetting(LiengConstant.Action.ALL_HAND));
                            break;
                    }
                }
                if (i === 0) {
                    if (this.gameCmd === GameConstant.XITO.CMD) {
                        this.setCurrentPlayerInTurn(player.data.allowedActions, player.data.actionMoneyList);
                    } else {
                        this.setCurrentPlayerInTurn(player.data.allowedActions, player.data.minBetting, player.data.maxBetting);
                    }
                }
            }
        }
    },
    // ============================================================
    // Other
    // ============================================================

    initAllBettingButtons: function initAllBettingButtons() {
        this.allButtonBettings = {};
        this.allButtonBettings[LiengConstant.Action.BET] = this.bettingButtonsList[0];
        this.allButtonBettings[LiengConstant.Action.RAISE] = this.bettingButtonsList[0];
        // this.allButtonBettings[LiengConstant.Action.ALL_IN] = this.bettingButtonsList[0];
        this.allButtonBettings[LiengConstant.Action.CALL] = this.bettingButtonsList[1];
        this.allButtonBettings[LiengConstant.Action.CHECK] = this.bettingButtonsList[2];
        this.allButtonBettings[LiengConstant.Action.FOLD] = this.bettingButtonsList[3];

        this.disableBettingButtons(true);
    },

    disableBettingButtons: function disableBettingButtons(interactable) {
        for (var i = 0; i < this.bettingButtonsList.length; i += 1) {
            this.bettingButtonsList[i].interactable = !interactable;
            this.bettingButtonsList[i].node.setScale(1);
        }
    },

    onShowBetting: function onShowBetting(params, playerUI) {
        if (params.data.money > 0) {
            this.chipEffect(params.data.money, params.allData.totalBetting, playerUI);
            this.setCallMoneyPlayer(playerUI, true, params.data.currentBetting);
            this.audioManager.playCoinDrop();
        }

        this.totalMoneyCallLabel.string = Utils.Number.format(params.allData.totalBetting);
    },

    chipEffect: function chipEffect(money, totalBetting, playerUI) {
        this.audioManager.playChipBay();
        var self = this;
        var container = this.calculateNumberChipType(money, playerUI.node);
        var pos2InWorld = container.parent.convertToWorldSpace(container.position);
        container.parent = self.chipContainer;
        self.chipContainer.zIndex = 2;
        var p = self.chipContainer.convertToNodeSpace(pos2InWorld);
        container.position = p;
        var containerAction = cc.sequence(cc.delayTime(0.5), cc.moveTo(0.3, cc.p(0, 0)), cc.removeSelf(), cc.callFunc(function () {
            Utils.Node.destroyAllChildrenInNode(self.chipContainer);
            // self.chipContainer.removeAllChildren();
            self.calculateNumberChipType(totalBetting, self.chipContainer);
            self.chipContainer.zIndex = 0;
        }));
        containerAction.easing(cc.easeOut(3));
        container.runAction(containerAction);
    },

    onShowFinishTime: function onShowFinishTime(time) {
        this.countDownTime = Date.now() + time;
        this.countDownTimeLabel.string = Math.floor(time / 1000);
        this.countDownTimeLabel.node.active = true;
    },

    hideStartTime: function hideStartTime() {
        this.gameStateLabel.node.active = false;
        this.countDownTimeLabel.node.active = false;
    },

    setCurrentPlayerInTurn: function setCurrentPlayerInTurn(allowedActionsList, minBetting, maxBetting) {
        var j = 0;
        if (allowedActionsList) {
            this.disableBettingButtons(true);
            for (j = 0; j < allowedActionsList.length; j += 1) {
                if (this.allButtonBettings[allowedActionsList[j]]) {
                    this.allButtonBettings[allowedActionsList[j]].interactable = true;
                }
            }
            // if (this.bettingButtonsList[0].interactable) {
            //     this.bettingSlider.node.active = true;
            // }
        }

        if (minBetting) {
            this.minBetting = minBetting;
            this.maxBetting = maxBetting;
            this.bettingSlider.setDefaultValue(minBetting, maxBetting, 0, this.gameManager.bettingInfo.betting);
        }
    },

    drawCardEffect: function drawCardEffect(card, player, time, timeDelay, rotation, cardId) {
        // this.audioManager.playBaiChia();
        var playerUIXiTo = player.node.getComponent('PlayerUIXiTo');

        var chiaBaiAction = cc.sequence(cc.delayTime(timeDelay), cc.spawn(cc.moveTo(time, cc.p(player.node.x, player.node.y + 20)), cc.rotateTo(time, rotation)), cc.callFunc(function () {
            if (player.player && playerUIXiTo.getNumberActiveChildren() < player.player.data.handSize) {
                if (player.player.data.username === AuthUser.username) {
                    var foundCard = playerUIXiTo.findCard(cardId);
                    if (foundCard) {
                        foundCard.node.position = cc.p(0, 0);
                        card.destroy();
                        return;
                    }
                }
                var index = playerUIXiTo.getNumberActiveChildren();
                var cardPlayer = playerUIXiTo.cardsHold[index];
                if (cardPlayer) {
                    card.zIndex = cardPlayer.node.zIndex;
                    card.rotation = cardPlayer.node.rotation;
                    card.position = cardPlayer.node.position;
                    card.parent = cardPlayer.node.parent;
                    card.setSiblingIndex(cardPlayer.node.getSiblingIndex());
                    if (this.gameCmd === GameConstant.XITO.CMD) {
                        var button = cardPlayer.getComponent(cc.Button);
                        if (button) {
                            var b1 = card.addComponent(cc.Button);
                            b1.clickEvents = button.clickEvents;
                        }
                    }
                    if (card) {
                        var cardUI = card.getComponent('CardUI');
                        playerUIXiTo.cardsHold[index] = cardUI;
                        cardPlayer.node.destroy();
                        cardUI.node.active = true;
                        if (player.player.data.cards) {
                            cardId = player.player.data.cards[index];
                        }
                        // cardUI.fold();
                        if (Utils.Type.isNumber(cardId) && cardId >= 0) {
                            cardUI.setCard(Card.fromId(cardId));
                            cardUI.showTransparentBlackNode(false);
                        }
                        this.finishDrawCard(cardUI, player);
                    }
                }
            } else {
                card.destroy();
            }
        }, this));
        chiaBaiAction.easing(cc.easeQuadraticActionOut());
        card.runAction(chiaBaiAction);
    },

    finishDrawCard: function finishDrawCard(cardUI, player) {
        cardUI.node.setScale(0.5, 0.5);
        cardUI.node.runAction(cc.scaleTo(0.3, 1));
        if (player) {
            this.onReDrawCard();
        }
    },

    onReDrawCard: function onReDrawCard() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (this.playerNodeList[i].player) {
                var playerUIXiTo = this.playerNodeList[i].node.getComponent('PlayerUIXiTo');
                var player = this.playerNodeList[i].player.data;
                this.reDrawCard(player, playerUIXiTo, i);
                // var func = cc.callFunc(this.reDrawCard(player, playerUIXiTo, i), this);
                // this.playerNodeList[i].node.runAction(cc.sequence(cc.delayTime(0), func));
            }
        }
    },

    reDrawCard: function reDrawCard(player, playerXiTo, index) {
        var k = 0,
            cardUI;

        if (index === 0) {
            for (k = 0; k < player.handSize; k += 1) {
                cardUI = playerXiTo.cardsHold[k].getComponent('CardUI');
                if (cardUI.card && cardUI.card.getId() !== player.cards[k]) {
                    cardUI.setCard(Card.fromId(player.cards[k]));
                    cardUI.showTransparentBlackNode(false);
                }
            }
        } else {
            for (k = 0; k < player.handSize; k += 1) {
                cardUI = playerXiTo.cardsHold[k].getComponent('CardUI');
                // cardUI.node.active = true;
                cardUI.fold();
                if (player.cards && player.cards[k] > 0) {
                    cardUI.setCard(Card.fromId(player.cards[k]));
                }
            }
        }
        if (player.state === LiengConstant.PlayerState.FOLDED) {
            if (index !== 0) {
                playerXiTo.fold();
            } else {
                playerXiTo.currentPlayerFold();
            }
        }
    },

    setCallMoneyPlayer: function setCallMoneyPlayer(playerUI, active, money) {
        var playerUIXiTo = playerUI.getComponent('PlayerUIXiTo');
        if (playerUIXiTo && playerUIXiTo.callMoneyNode && playerUIXiTo.callMoneyLabel) {
            playerUIXiTo.callMoneyNode.active = active;
            playerUIXiTo.callMoneyLabel.string = Utils.Number.format(money);
        }
    },

    convertTypeBetting: function convertTypeBetting(typeBetting) {
        switch (typeBetting) {
            case LiengConstant.Action.BET:
            case LiengConstant.Action.RAISE:
                return LiengConstant.Effect.TO;
            case LiengConstant.Action.CALL:
                return LiengConstant.Effect.THEO;
            case LiengConstant.Action.CHECK:
                return LiengConstant.Effect.NHUONG_TO;
            case LiengConstant.Action.FOLD:
                return LiengConstant.Effect.UP_BO;
            case LiengConstant.Action.ALL_HAND:
                return LiengConstant.Effect.CHOI_TAT_TAY;

            //xito
            case LiengConstant.Action.BET_1_2:
                return LiengConstant.Effect.TO_12;
            case LiengConstant.Action.BET_1_4:
                return LiengConstant.Effect.TO_14;
            case LiengConstant.Action.BET_X2:
                return LiengConstant.Effect.TO_X2;
            case LiengConstant.Action.ALL_IN:
                return LiengConstant.Effect.TO_TAT_CA;
        }
    },

    restartGameWhenNewMatch: function restartGameWhenNewMatch() {
        if (this.coutUpdateGame === 1) {
            this.coutUpdateGame -= 1;
            return;
        }
        Utils.Node.destroyAllChildrenInNode(this.dealer);
        this.dealer.removeAllChildren();
        this.restartGame();
    },

    restartGame: function restartGame() {
        Utils.Node.destroyAllChildrenInNode(this.chipContainer);
        // this.chipContainer.removeAllChildren();
        this.totalMoneyCallLabel.string = '0';

        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].node.getComponent('PlayerUIXiTo').deactiveAllCards();
            this.playerNodeList[i].clearEffects();
            this.setCallMoneyPlayer(this.playerNodeList[i], false, 0);
        }
        this.hideStartTime();
    },

    onPrePlayerRemoved: function onPrePlayerRemoved(playerNode) {
        playerNode.node.getComponent('PlayerUIXiTo').deactiveAllCards();
        playerNode.clearEffects();
        this.setCallMoneyPlayer(playerNode, false, 0);
    },

    onPostPlayerAdded: function onPostPlayerAdded(playerNode) {
        if (playerNode.player) {
            if (playerNode.player.data.state === LiengConstant.PlayerState.NONE || playerNode.player.data.state === LiengConstant.PlayerState.OFF_MONEY) {
                playerNode.addEffect(LiengConstant.Effect.DANG_DOI);
            }
        }
    },

    calculateNumberChipType: function calculateNumberChipType(money, sourceNode) {
        var check = money.toString().split('').reverse().join('');
        var container = new cc.Node();
        var count = 0,
            x = 0,
            y = 0,
            index = 50;
        container.parent = sourceNode;
        container.setScale(0.6);
        container.position = cc.p(0, 0);
        container.zIndex = 15;

        for (var i = 0; i < check.length; i += 1) {
            var number = parseInt(check[i]);
            if (number > 0) {
                var chip;
                for (var j = 0; j < number; j += 1) {
                    chip = cc.instantiate(this.chipTemplateList[i]);
                    chip.parent = container;
                    chip.position = cc.p(x + count * chip.width * 0.4, y + count * chip.height * 0.8 + 10 * j);
                    chip.zIndex = index;
                    chip.rotaion = Math.random() * 360;
                    var chipAction = cc.rotateBy(0.1, -350);
                    chipAction.easing(cc.easeQuadraticActionOut());
                    chip.runAction(chipAction);
                }
                count += 1;
                index -= 1;
                if (count % 2 === 0) {
                    y -= chip.height * 0.4;
                    x += chip.width * 0.8;
                    count = 0;
                    index = 50;
                }
            }
        }
        return container;
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","Card":"Card","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","LiengConstant":"LiengConstant","Slider":"Slider","Utils":"Utils"}],"GameplayMauBinh":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'c8cackL/ntIJr3V+PXZGSBC', 'GameplayMauBinh');
// scripts\components\games\mau_binh\GameplayMauBinh.js

var GameConstant = require('GameConstant'),
    BaseMainGameplay = require('BaseMainGameplay'),
    MauBinhConstant = require('MauBinhConstant'),
    SortCardLayoutMauBinh = require('SortCardLayoutMauBinh'),
    AuthUser = require('AuthUser');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        effectCardNode: cc.Node,
        lblThongBao: cc.Label,
        lblKetQua: cc.Label,
        txtThoigian: cc.Label,
        btnXepXong: cc.Button,
        btnSwapChi: cc.Button,
        btnStartGame: cc.Button,
        bottomPanel: cc.Node,
        bgHelp: cc.Node,
        cardPrefab: cc.Prefab,
        sortCardLayout: SortCardLayoutMauBinh,
        gameCmd: {
            'default': GameConstant.MAU_BINH.CMD,
            visible: false
        }
    },

    $onLoad: function $onLoad() {
        // Data
        this.time = 0;
        this.startTime = new Date().getTime();
        this.btnXepXong.node.active = false;
        this.btnSwapChi.node.active = false;
        this.btnStartGame.node.active = false;
        this.lblKetQua.node.active = false;
        this.lblThongBao.node.active = false;
        this.sortCardLayout.setGameParam(this, this.gameManager);
        this.cardEffectList = [];
        this.cardEffectMainPlayerList = [];

        // Event
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_UPDATE_HAND, this.onUpdateHand, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_WATING_PLAYER, this.onGameWatingPlayer, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_PREPARE, this.onGamePrepare, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_ORDER_CARD, this.onGameOrderCard, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_UPDATE, this.onGameUpdate, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_FINISH, this.onGameFinish, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_COMPARE_CHI, this.onCompareChi, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_USER_FINISH_ORDER, this.onUserFinishOrder, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_NOTIFY_THANG_TRANG, this.onNotifyThangTrang, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_NOTIFY_BINH_LUNG, this.onNotifyBinhLung, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_PLAYER_REMOVE, this.onPlayerRemove, this);
        this.gameManager.eventDispatchers.local.addEventListener(MauBinhConstant.Event.GAME_PLAYER_ADD, this.onPlayerAdd, this);
    },

    $onFocus: function $onFocus() {
        if (!this.gameManager) {
            return;
        }
        switch (this.gameManager.gameState) {
            case MauBinhConstant.GameState.DEALING:
                break;
            case MauBinhConstant.GameState.ORDER_CARDS:
                break;
            case MauBinhConstant.GameState.FINISH:
                break;
            case MauBinhConstant.GameState.COMPARE_1:
                break;
            case MauBinhConstant.GameState.COMPARE_2:
                break;
            case MauBinhConstant.GameState.COMPARE_3:
                break;
        }
    },

    $onLostFocus: function $onLostFocus() {},

    onPostPlayerAdded: function onPostPlayerAdded(playerUI) {
        if (!playerUI) {
            return;
        }
        if (playerUI.player.data.username === AuthUser.username) {
            playerUI.node.getComponent('PlayerUIMauBinh').setGamePlay(this);
        }
    },

    reset: function reset() {
        this.bottomPanel.zIndex = 0;
        this.lblThongBao.string = '';
        this.lblKetQua.string = '';
        this.txtThoigian.string = '';
        this.btnXepXong.node.active = false;
        this.btnSwapChi.node.active = false;
        this.btnStartGame.node.active = false;
        this.lblKetQua.node.active = false;
        this.bgHelp.active = false;
        this.cardEffectList = [];
        this.effectCardNode.removeAllChildren();
        this.sortCardLayout.reset();

        // Reset Player
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].node.getComponent('PlayerUIMauBinh').reset();
        }
    },

    onGameWatingPlayer: function onGameWatingPlayer() {
        this.lblThongBao.string = 'Đang đợi người chơi khác:';
        this.txtThoigian.string = '';
        this.lblThongBao.node.active = true;
    },

    onGamePrepare: function onGamePrepare(params) {
        // cc.log('onGamePrepare');
        // cc.log(params);
        var i,
            dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.reset();
        this.time = params.allData.time - dt;
        if (this.time <= 0) {
            return;
        }
        this.startTime = new Date().getTime();
        this.lblThongBao.node.active = true;
        this.lblThongBao.string = 'Ván bài mới sẽ bắt đầu sau:';

        // Show Button Start Game
        var players = params.allData.players;
        for (i = 0; i < players.length; i += 1) {
            if (players[i].username === AuthUser.username && players[i].isMaster) {
                this.btnStartGame.node.active = true;
                break;
            }
        }
    },

    onUpdateHand: function onUpdateHand(params) {
        // cc.log('onUpdateHand');
        this.mainPlayerCards = params.hand;
        this.lblThongBao.node.active = false;
        var players = params.players;

        // Effect Chia Bai
        this.createEffectChiaBai(players);

        // Hide BtnStart
        this.btnStartGame.node.active = false;
    },

    onGameOrderCard: function onGameOrderCard(params) {
        // cc.log('onGameOrderCard');
        this.lblThongBao.node.active = true;
        this.txtThoigian.string = '';
        this.lblThongBao.string = 'Trận đấu đang diễn ra.';
        this.btnStartGame.node.active = false;
        var players = params.allData.players;
        var i,
            playerUiMaubinh,
            isSortCardActive = false,
            player;
        for (i = 0; i < players.length; i += 1) {
            player = this.getPlayerByUserName(players[i].username);
            if (player) {
                playerUiMaubinh = player.getComponent('PlayerUIMauBinh');
                if (playerUiMaubinh && players[i].isActive) {
                    var dt = 0;
                    if (params.__execInfo__) {
                        dt = params.__execInfo__.dt;
                    }
                    var time = params.allData.time - dt;
                    if (time <= 0) {
                        return;
                    }
                    playerUiMaubinh.setState(MauBinhConstant.PlayerState.IN_TURN, time, players[i].isFinish);
                    if (players[i].username === AuthUser.username) {
                        this.lblThongBao.node.active = false;
                        this.btnSwapChi.node.active = true;
                        this.btnXepXong.node.active = true;
                        if (!this.sortCardLayout.node.active) {
                            this.sortCardLayout.node.active = true;
                            this.sortCardLayout.setCards(players[i].cards);
                        }
                        if (playerUiMaubinh.isThangTrang || players[i].isFinish) {
                            this.onClickFinishOrder();
                        }
                    }
                    isSortCardActive = this.sortCardLayout.node.active;
                } else if (!players[i].isActive) {
                    playerUiMaubinh.setState(MauBinhConstant.PlayerState.WAITING, 0);
                }
            }
        }
        for (i = 0; i < players.length; i += 1) {
            player = this.getPlayerByUserName(players[i].username);
            if (player) {
                playerUiMaubinh = player.getComponent('PlayerUIMauBinh');
                if (playerUiMaubinh && players[i].isActive && AuthUser.username !== players[i].username) {
                    playerUiMaubinh.showCardLayout(players[i].isActive, isSortCardActive);
                }
            }
        }

        // Remove Card Effect
        this._removeCardEffect();
    },

    onCompareChi: function onCompareChi(params, isInForcus) {
        // cc.log('onCompareChi');
        // Check Main User In Turn
        this.lblThongBao.node.active = false;
        this.btnStartGame.node.active = false;
        var players = params.allData.players,
            isUserInTurn = false;
        for (var j = 0; j < players.length; j += 1) {
            if (players[j].username === AuthUser.username && players[j].isActive) {
                isUserInTurn = true;
                break;
            }
        }

        // Notify Show Chi
        this.lblKetQua.node.active = true;
        this.lblKetQua.node.scale = 0;
        this.lblKetQua.node.stopAllActions();
        this.lblKetQua.node.runAction(cc.scaleTo(0.5, 1));
        this.txtThoigian.string = '';
        this.lblThongBao.node.active = false;
        if (params.action === MauBinhConstant.Action.COMPARE_CHI_MOT) {
            // Hide Sort Card
            if (isUserInTurn) {
                this.btnSwapChi.node.active = false;
                if (this.btnXepXong.node.active) {
                    this.btnXepXong.node.active = false;
                    this.hideSortCardLayout();
                }
            }
            this.lblKetQua.string = 'Chi 1';
        } else if (params.action === MauBinhConstant.Action.COMPARE_CHI_HAI) {
            this.lblKetQua.string = 'Chi 2';
        } else if (params.action === MauBinhConstant.Action.COMPARE_CHI_BA) {
            this.lblKetQua.string = 'Chi 3';
        }

        // Show Thong Bao Cho
        if (!isUserInTurn) {
            this.lblThongBao.string = 'Trận đấu đang diễn ra.';
        }

        // Compare Card
        for (var i = 0; i < players.length; i += 1) {
            var playerNode = this.getPlayerByUserName(players[i].username);
            if (players[i].isActive && playerNode) {
                playerNode.getComponent('PlayerUIMauBinh').compareChi(params.action, params.gameState, players[i], params.actions, isInForcus);
            }
        }
    },

    onGameFinish: function onGameFinish(params) {
        // cc.log('onGameFinish');
        // cc.log(params);
        this.lblKetQua.node.active = true;
        this.lblKetQua.string = 'Kết quả';
        this.lblKetQua.node.scale = 0;
        this.lblKetQua.node.stopAllActions();
        this.lblKetQua.node.runAction(cc.scaleTo(0.5, 1));
        this.lblThongBao.node.active = false;
        this.txtThoigian.string = '';
        this.lblThongBao.string = '';
        this.btnStartGame.node.active = false;
        var players = params.allData.players;
        for (var i = 0; i < players.length; i += 1) {
            // Find Money Exchange In Result
            var moneyExchange = 0;
            var summary = params.result.summary;
            for (var j = 0; j < summary.length; j += 1) {
                if (players[i].username === summary[j].userName) {
                    moneyExchange = summary[j].moneyExchange;
                    break;
                }
            }

            // Set Result
            var playerNode = this.getPlayerByUserName(players[i].username);
            if (playerNode) {
                playerNode.getComponent('PlayerUIMauBinh').setResult(players[i], moneyExchange);
            }
        }

        // Hide Sortcard
        this.btnSwapChi.node.active = false;
        this.btnXepXong.node.active = false;
        this.hideSortCardLayout();
    },

    onPlayerRemove: function onPlayerRemove() {
        // cc.log('onPlayerRemove');
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (!this.playerNodeList[i].player) {
                this.playerNodeList[i].node.getComponent('PlayerUIMauBinh').reset();
            }
        }
    },

    onPlayerAdd: function onPlayerAdd(params) {
        // cc.log('onPlayerAdd');
        // cc.log(params);
        if (this.gameManager.gameState !== MauBinhConstant.GameState.WAITING_DEALING) {
            var playerNode = this.getPlayerByUserName(params.player.username);
            var playerUiMaubinh = playerNode.getComponent('PlayerUIMauBinh');
            if (playerUiMaubinh && !params.player.isActive) {
                playerUiMaubinh.setState(MauBinhConstant.PlayerState.WAITING);
            }
        }
    },

    onUserFinishOrder: function onUserFinishOrder(params) {
        // cc.log('onUserFinishOrder');
        // cc.log(params);
        var playerNode = this.getPlayerByUserName(params.username);
        if (playerNode) {
            playerNode.getComponent('PlayerUIMauBinh').setState(MauBinhConstant.PlayerState.FINISH);
        }
    },

    onNotifyThangTrang: function onNotifyThangTrang(params) {
        // cc.log('################onNotifyThangTrang ');
        // cc.log(params);
        var playerNode = this.getPlayerByUserName(params.username);
        if (playerNode) {
            playerNode.getComponent('PlayerUIMauBinh').setThangTrang(params);
            playerNode.getComponent('PlayerUIMauBinh').setState(MauBinhConstant.PlayerState.FINISH);
            this.audioManager.playThangTrang();
        }
    },

    onNotifyBinhLung: function onNotifyBinhLung() {},

    getPlayerByUserName: function getPlayerByUserName(username) {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (!this.playerNodeList[i].player) {
                continue;
            }
            if (this.playerNodeList[i].player.data.username === username) {
                return this.playerNodeList[i].node;
            }
        }
        return null;
    },

    $onUpdate: function $onUpdate() {
        var currentTime = new Date().getTime();
        var remainTime = Math.floor((this.time - (currentTime - this.startTime)) / 1000);
        if (remainTime < 0) {
            remainTime = 0;
        }
        if (this.gameManager.gameState === MauBinhConstant.GameState.WAITING_DEALING) {
            this.txtThoigian.string = Math.floor(remainTime + 1) + ' giây';
        }
    },

    hideSortCardLayout: function hideSortCardLayout() {
        this.sortCardLayout.setFinishOrder();
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (this.playerNodeList[i].player) {
                var userName = this.playerNodeList[i].player.data.username;
                var playerUiMaubinh = this.getPlayerByUserName(userName).getComponent('PlayerUIMauBinh');
                if (playerUiMaubinh.isActive) {
                    playerUiMaubinh.showCardLayout(true, false);
                    if (userName === AuthUser.username) {
                        playerUiMaubinh.setOpenAllCards(this.sortCardLayout.getCards());
                    }
                }
            }
        }
    },

    createEffectChiaBai: function createEffectChiaBai(players) {
        this.audioManager.playBaiChia();
        this.countCardEffectFinish = 0;
        this.cardEffectMainPlayerList = [];
        var length = players.length,
            index = 0,
            index2 = 12,
            cardLength = length * 13,
            pos = [];
        for (i = 0; i < length; i += 1) {
            var playerNode = this.getPlayerByUserName(players[i].userName);
            if (players[i].isActive && playerNode) {
                pos.push(playerNode.getComponent('PlayerUIMauBinh').cardLayout.getCardPositionList());
            }
        }
        for (var i = 0; i < cardLength; i += 1) {
            // Add
            var position = pos[index][index2];
            var cardNode = cc.instantiate(this.cardPrefab);
            cardNode.scale = 0.4;
            cardNode.x = 0;
            cardNode.y = 0;
            this.effectCardNode.addChild(cardNode);
            this.cardEffectList.push(cardNode);

            // Push Effect Main Player
            if (index === 0) {
                this.cardEffectMainPlayerList.push(cardNode);
            }

            // Action
            cardNode.runAction(cc.sequence(cc.delayTime((cardLength - i) * 0.03), cc.moveTo(0.2, position).easing(cc.easeCubicActionIn()), cc.callFunc((function () {
                this.countCardEffectFinish += 1;
                var playerUiMaubinh,
                    isMainUserInTurn = false;
                if (this.countCardEffectFinish >= cardLength) {
                    for (i = 0; i < players.length; i += 1) {
                        var playerNode = this.getPlayerByUserName(players[i].userName);
                        if (players[i].isActive && players[i].userName === AuthUser.username && playerNode) {
                            playerUiMaubinh = playerNode.getComponent('PlayerUIMauBinh');
                            this.sortCardLayout.setCards(this.mainPlayerCards);
                            this.sortCardLayout.node.active = true;
                            playerUiMaubinh.showCardLayout(false, true);
                            isMainUserInTurn = true;
                        }
                    }
                    for (i = 0; i < players.length; i += 1) {
                        var playerNode1 = this.getPlayerByUserName(players[i].userName);
                        if (players[i].isActive && players[i].userName !== AuthUser.username && playerNode1) {
                            playerUiMaubinh = playerNode1.getComponent('PlayerUIMauBinh');
                            playerUiMaubinh.showCardLayout(true, isMainUserInTurn);
                        }
                    }
                    this._removeCardEffect();
                }
            }).bind(this))));

            // Increase Index
            index += 1;
            if (index >= pos.length) {
                index = 0;
                index2 -= 1;
            }
        }
    },

    onClickFinishOrder: function onClickFinishOrder() {
        this.audioManager.playButtonClick();
        // cc.log('onClickFinishOrder');
        if (this.gameManager.gameState === MauBinhConstant.GameState.ORDER_CARDS) {
            this.gameManager.sendRequestOrderCard(this.sortCardLayout.getCards(), true);
            this.btnSwapChi.node.active = false;
            this.btnXepXong.node.active = false;
            this.hideSortCardLayout();

            // Send State Finish User
            var player = this.getPlayerByUserName(AuthUser.username);
            if (player) {
                player.getComponent('PlayerUIMauBinh').setState(MauBinhConstant.PlayerState.FINISH);
            }
        }
    },

    onClickStartGame: function onClickStartGame() {
        this.audioManager.playButtonClick();
        this.btnStartGame.node.active = false;
        if (this.gameManager.gameState === MauBinhConstant.GameState.WAITING_DEALING) {
            this.gameManager.sendRequestStartGame();
        }
    },

    onClickHelp: function onClickHelp() {
        this.audioManager.playButtonClick();
        this.bgHelp.active = !this.bgHelp.active;
        this.bottomPanel.zIndex = this.bgHelp.active ? 10 : 0;
        this.topPanelInGame.node.zIndex = this.bgHelp.active ? 0 : 10;
    },

    onCloseHelp: function onCloseHelp() {
        this.audioManager.playButtonClick();
        this.bgHelp.active = false;
        this.bottomPanel.zIndex = 0;
        this.topPanelInGame.node.zIndex = 10;
    },

    onSwapChiClick: function onSwapChiClick() {
        this.audioManager.playButtonClick();
        this.sortCardLayout.swapChi();
    },

    _removeCardEffect: function _removeCardEffect() {
        for (var i = 0; i < this.cardEffectList.length; i += 1) {
            this.cardEffectList[i].destroy();
        }
        this.cardEffectList = [];
        this.cardEffectMainPlayerList = [];
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","GameConstant":"GameConstant","MauBinhConstant":"MauBinhConstant","SortCardLayoutMauBinh":"SortCardLayoutMauBinh"}],"GameplayMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e7533lHLQFFN6DYsIko7b0U', 'GameplayMiniPoker');
// scripts\components\games\mini_poker\GameplayMiniPoker.js

var Card = require('Card'),
    Utils = require('Utils'),
    UiManager = require('UiManager'),
    BaseMinigameGameplay = require('BaseMinigameGameplay'),
    GameConstant = require('GameConstant'),
    CommonConstant = require('CommonConstant'),
    ToggleCurrency = require('ToggleCurrency'),
    ItemTextMiniPoker = require('ItemTextMiniPoker'),
    MiniPokerConstant = require('MiniPokerConstant'),
    ColumnInfoMiniPoker = require('ColumnInfoMiniPoker');

cc.Class({
    'extends': BaseMinigameGameplay,

    properties: {
        btnMucCuocList: {
            'default': [],
            type: cc.Node
        },
        layoutCardList: {
            'default': [],
            type: ColumnInfoMiniPoker
        },
        btnCanGat: cc.Node,
        thanhCanGat: cc.Node,
        btnCurrency: cc.Node,
        lblQuy: cc.Label,
        textFlyPrefab: cc.Prefab,
        tblHistoryPrefab: cc.Prefab,
        tblTopUser: cc.Prefab,
        tblHelp: cc.Prefab,
        btnAutoPlay: cc.Node,
        imgDen1: cc.Node,
        imgDen2: cc.Node,

        gameCmd: {
            'default': GameConstant.MINI_POKER.CMD,
            visible: false
        }
    },

    $onLoad: function $onLoad() {
        this.isLostFocus = false;
        this.isTextShowing = false;
        this.countEventFinish = 0;
        this.potWin = 0;
        this.autoPlay = false;
        this.autoPlayTmp = false;
        this.currencyIndex = this.btnCurrency.getComponent(ToggleCurrency).index;
        this.moneyBetList = [100, 1000, 10000];
        this.quyXuList = [];
        this.quyPiList = [];
        this.paramsFinish = 0;
        this.resetButtonMucCuoc();

        // Event
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.TURN_PREPARE, this.onPrepareGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.TURN_START, this.onStartGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.TURN_UPDATE, this.onUpdateGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.TURN_FINISH, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.GET_JAR_SUCCESS, this.onGetMoneyJar, this);
        this.gameManager.eventDispatchers.local.addEventListener(MiniPokerConstant.Event.UPDATE_JAR, this.onUpdateMoneyJar, this);
    },

    onEnable: function onEnable() {
        this.reset();
    },

    $onFocus: function $onFocus() {
        this.isLostFocus = false;
        this.countEventFinish = -5;

        // Reset Card
        this.reset();

        // Auto Play
        if (this.autoPlay && this.gameManager.gameState === MiniPokerConstant.GameState.NONE) {
            this.onPlayClick();
        }
    },

    $onLostFocus: function $onLostFocus() {
        this.isLostFocus = true;
    },

    resetButtonMucCuoc: function resetButtonMucCuoc() {
        // Reset Label
        var i;
        for (i = 0; i < this.btnMucCuocList.length; i += 1) {
            var label = this.btnMucCuocList[i].getComponentInChildren(cc.Label);
            label.string = Utils.Number.abbreviate(this.moneyBetList[i], 3);
        }

        // Reset Sprite
        for (i = 0; i < this.btnMucCuocList.length; i += 1) {
            var s = this.btnMucCuocList[i].getComponent(cc.Sprite);
            s.enabled = i === 0;
        }
    },

    onUpdateMoneyJar: function onUpdateMoneyJar(params) {
        var money = params.money;
        var isPI = params.currency === CommonConstant.CurrencyType.Ip.NAME;
        for (var i = 0; i < this.moneyBetList.length; i += 1) {
            var cur = isPI ? this.moneyBetList[i] : this.moneyBetList[i];
            if (cur === params.betting) {
                if (isPI) {
                    this.quyPiList[i] = money;
                } else {
                    this.quyXuList[i] = money;
                }
            }
        }
        this._updateMoneyQuy();
    },

    onGetMoneyJar: function onGetMoneyJar(results) {
        var QuyPi = results.data[CommonConstant.CurrencyType.Ip.NAME];
        var QuyXu = results.data[CommonConstant.CurrencyType.Xu.NAME];
        for (var i = 0; i < this.moneyBetList.length; i += 1) {
            this.quyPiList.push(QuyPi[this.moneyBetList[i]].balance);
            this.quyXuList.push(QuyXu[this.moneyBetList[i]].balance);
            this._updateMoneyQuy();
        }
    },

    onPrepareGame: function onPrepareGame() {
        // cc.log('onPrepareGame');
        if (this.autoPlay) {
            this.onPlayClick();
        }
    },

    onStartGame: function onStartGame(params) {
        // cc.log('onStartGame game state ' + this.gameManager.gameState);
        // Change Card First => Card Finish Old
        this.audioId = this.audioManager.playVongQuay();
        this.potWin = params.potWin;
        var self = this;
        for (var i = 0; i < self.layoutCardList.length; i += 1) {
            var layoutCard = self.layoutCardList[i];
            layoutCard.updateCardFirst();
        }

        // Action
        var maxTime = 3.6;
        var action = cc.sequence(cc.callFunc(function () {
            for (var i = 0; i < self.layoutCardList.length; i += 1) {
                var layoutCard = self.layoutCardList[i];
                if (layoutCard) {
                    layoutCard.node.stopAllActions();
                    layoutCard.node.y = -92;
                    var action = cc.moveTo(maxTime - (self.layoutCardList.length - i) * 0.6, cc.v2(layoutCard.node.x, -(layoutCard.node.height - 92)));
                    layoutCard.node.runAction(action);
                }
            }
        }), cc.delayTime(0.3), cc.callFunc(function () {
            self._updateCardFinish(params);
        }), cc.delayTime(maxTime), cc.callFunc(function () {
            self._showTextFinishGame();
        }));
        this.node.runAction(action);
        this.node.runAction(cc.sequence(cc.delayTime(maxTime - 0.4), cc.callFunc(function () {
            self.audioManager.stopEffect(self.audioId);
            self.audioId = 0;
        })));
    },

    onUpdateGame: function onUpdateGame() {},

    onFinishGame: function onFinishGame(params) {
        // cc.log('onFinishGame');
        this.paramsFinish = params;
        this._showTextFinishGame();
    },

    onClickMucCuoc: function onClickMucCuoc(param) {
        this.audioManager.playButtonClick();
        if (this.gameManager.gameState !== MiniPokerConstant.GameState.ROTATE) {
            var sprite = param.target.getComponent(cc.Sprite);
            for (var i = 0; i < this.btnMucCuocList.length; i += 1) {
                var s = this.btnMucCuocList[i].getComponent(cc.Sprite);
                s.enabled = s === sprite;
            }
            this._updateMoneyQuy();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi mức cược!', 1);
        }
    },

    onPlayClick: function onPlayClick() {
        // Check Ready Init Card Default
        var initFinish = true;
        for (var i = 0; i < this.layoutCardList.length; i += 1) {
            var layoutCard = this.layoutCardList[i];
            if (!layoutCard.isReady) {
                initFinish = false;
                break;
            }
        }
        if (!initFinish) {
            UiManager.openWarningMessage('Xin vui lòng đợi trong giây lát!', 1);
            return;
        }

        // Start Game
        if (this.gameManager.gameState === MiniPokerConstant.GameState.NONE) {
            // Play
            this.countEventFinish = 0;
            this._resetCanGat();
            var pos = cc.v2(0, 70);
            var pos2 = cc.v2(0, 0);
            this.btnCanGat.runAction(cc.sequence(cc.moveTo(0.4, cc.v2(pos.x, pos.y - 30)).easing(cc.easeCubicActionOut()), cc.delayTime(0.2), cc.moveTo(0.4, pos).easing(cc.easeCubicActionIn())));
            this.thanhCanGat.runAction(cc.sequence(cc.moveTo(0.4, cc.v2(pos2.x, pos2.y - 10)).easing(cc.easeCubicActionOut()), cc.delayTime(0.2), cc.moveTo(0.4, pos2).easing(cc.easeCubicActionIn()), cc.callFunc((function () {
                this._resetCanGat();
            }).bind(this))));

            // Effect Light
            this.imgDen1.opacity = 255;
            this.imgDen2.opacity = 0;
            this.imgDen1.stopAllActions();
            this.imgDen2.stopAllActions();
            var action = cc.repeatForever(cc.sequence(cc.fadeIn(0), cc.delayTime(0.2), cc.fadeOut(0), cc.delayTime(0.2)));
            var action1 = cc.repeatForever(cc.sequence(cc.fadeOut(0), cc.delayTime(0.2), cc.fadeIn(0), cc.delayTime(0.2)));
            this.imgDen1.runAction(action1);
            this.imgDen2.runAction(action);

            // Send
            var mucCuocIndex = this._getMoneySelectIndex();
            var isPI = this.currencyIndex === 0 || this.currencyIndex === undefined;
            var currency = isPI ? CommonConstant.CurrencyType.Ip.NAME : CommonConstant.CurrencyType.Xu.NAME;
            var money = this.moneyBetList[mucCuocIndex];
            this.gameManager.sendStartGame(currency, money);
        } else {
            UiManager.openWarningMessage('Trò chơi đang diễn ra. Xin vui lòng đợi trong giây lát!', 1);
        }
    },

    onRankClick: function onRankClick() {
        this.audioManager.playButtonClick();
        var topUserTable = cc.instantiate(this.tblTopUser);
        cc.director.getScene().addChild(topUserTable);
    },

    onHistoryClick: function onHistoryClick() {
        this.audioManager.playButtonClick();
        var historyTable = cc.instantiate(this.tblHistoryPrefab);
        historyTable.getComponent('HistoryTableMiniPoker').init(this.gameManager.historyList);
        cc.director.getScene().addChild(historyTable);
    },

    onHelpClick: function onHelpClick() {
        this.audioManager.playButtonClick();
        var help = cc.instantiate(this.tblHelp);
        cc.director.getScene().addChild(help);
    },

    onAutoPlayClick: function onAutoPlayClick(param) {
        this.audioManager.playButtonClick();
        this.autoPlay = !this.autoPlay;
        param.target.getComponentInChildren(cc.Sprite).enabled = this.autoPlay;
    },

    onCurrencyClick: function onCurrencyClick() {
        this.audioManager.playButtonClick();
        if (this.gameManager.gameState !== MiniPokerConstant.GameState.ROTATE) {
            this.btnCurrency.getComponent('ToggleCurrency').click();
            this.currencyIndex = this.btnCurrency.getComponent(ToggleCurrency).index;
            this.resetButtonMucCuoc();
            this._updateMoneyQuy();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi loại cược!', 1);
        }
    },

    onCloseClick: function onCloseClick() {
        this.audioManager.playButtonClick();
        this.node.active = false;
        if (this.audioId) {
            this.audioManager.stopEffect(this.audioId);
        }
    },

    reset: function reset() {
        // Reset Card
        for (var i = 0; i < this.layoutCardList.length; i += 1) {
            var layoutCard = this.layoutCardList[i];
            if (layoutCard) {
                layoutCard.node.stopAllActions();
                layoutCard.node.y = -(layoutCard.node.height - 92);
            }
        }

        // Reset Light
        this.imgDen2.stopAllActions();
        this.imgDen1.stopAllActions();
        this.imgDen1.opacity = 255;
        this.imgDen2.opacity = 0;

        // Reset Can Gat
        this._resetCanGat();
    },

    _resetCanGat: function _resetCanGat() {
        this.btnCanGat.stopAllActions();
        this.thanhCanGat.stopAllActions();
        this.btnCanGat.position = cc.v2(0, 70);
        this.thanhCanGat.position = cc.v2(0, 0);
    },

    _getMoneySelectIndex: function _getMoneySelectIndex() {
        var index = 0;
        for (var i = 0; i < this.btnMucCuocList.length; i += 1) {
            var s = this.btnMucCuocList[i].getComponent(cc.Sprite);
            if (s.enabled) {
                index = i;
                break;
            }
        }
        return i;
    },

    _updateMoneyQuy: function _updateMoneyQuy() {
        if (this.currencyIndex === undefined) {
            this.currencyIndex = 0;
        }
        var isPI = this.currencyIndex === 0;
        this.lblQuy.string = Utils.Number.format(isPI ? this.quyPiList[this._getMoneySelectIndex()] : this.quyXuList[this._getMoneySelectIndex()]);
    },

    _updateCardFinish: function _updateCardFinish(params) {
        for (var i = 0; i < params.result.length; i += 1) {
            var card = Card.fromId(params.result[i]);
            this.layoutCardList[i].updateCardFinish(card);
        }
    },

    _showTextFinishGame: function _showTextFinishGame() {
        // Check State
        // cc.log('######show text');
        this.countEventFinish += 1;
        if (this.countEventFinish < 2 || this.isLostFocus || this.isTextShowing) {
            return;
        }
        this.isTextShowing = true;
        this.countEventFinish = 0;
        // cc.log('_showTextFinishGame game state ' + this.gameManager.gameState);

        // Stop Den
        this.imgDen2.stopAllActions();
        this.imgDen1.stopAllActions();
        this.imgDen1.opacity = 255;
        this.imgDen2.opacity = 0;

        // Pot Win
        var self = this;
        if (self.potWin > 0) {
            var textFly = cc.instantiate(self.textFlyPrefab);
            self.node.addChild(textFly);
            var textFlyComponent = textFly.getComponent(ItemTextMiniPoker);
            textFlyComponent.setColor(cc.Color.YELLOW);
            textFlyComponent.setText(MiniPokerConstant.getPotName(self.potWin));
            var action = cc.sequence(cc.moveBy(2, cc.v2(0, 180)).easing(cc.easeQuinticActionOut()), cc.delayTime(1), cc.callFunc(function () {
                textFlyComponent.node.destroy();
            }));
            textFlyComponent.node.runAction(action);
            // self.audioManager.playWin();
        } else {}
            // self.audioManager.playLose();

            // Money Text
        var currencyName = self.gameManager.lastCurrency === CommonConstant.CurrencyType.Ip.NAME ? CommonConstant.CurrencyType.Ip.DISPLAY_NAME : CommonConstant.CurrencyType.Xu.DISPLAY_NAME;
        self.node.runAction(cc.sequence(cc.delayTime(self.potWin > 0 ? 0.4 : 0), cc.callFunc(function () {
            var player = self.paramsFinish.player;
            var textFly = cc.instantiate(self.textFlyPrefab);
            self.node.addChild(textFly);
            var textFlyComponent = textFly.getComponent(ItemTextMiniPoker);
            textFlyComponent.setColor(cc.Color.GREEN);
            textFlyComponent.setText((player.moneyExchange > 0 ? '+' : '') + Utils.Number.format(player.moneyExchange) + ' ' + currencyName);
            var action = cc.sequence(cc.moveBy(1.5, cc.v2(0, 140)).easing(cc.easeQuinticActionOut()), cc.delayTime(1), cc.callFunc(function () {
                textFlyComponent.node.destroy();
                self.isTextShowing = false;
            }));
            textFlyComponent.node.runAction(action);
        })));
    }
});

cc._RFpop();
},{"BaseMinigameGameplay":"BaseMinigameGameplay","Card":"Card","ColumnInfoMiniPoker":"ColumnInfoMiniPoker","CommonConstant":"CommonConstant","GameConstant":"GameConstant","ItemTextMiniPoker":"ItemTextMiniPoker","MiniPokerConstant":"MiniPokerConstant","ToggleCurrency":"ToggleCurrency","UiManager":"UiManager","Utils":"Utils"}],"GameplayPhom":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ff1c7uZmm1Ax6Pr327oKOTX', 'GameplayPhom');
// scripts\components\games\phom\GameplayPhom.js

var BaseMainGameplay = require('BaseMainGameplay'),
    PhomConstant = require('PhomConstant'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    GameConstant = require('GameConstant'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        numNocCardLabel: cc.Label,
        gameStateLabel: cc.Label,
        countDownTimeLabel: cc.Label,
        nocCardNode: cc.Node,
        arrowNocNode: cc.Node,
        anBaiButton: cc.Button,
        bocBaiButton: cc.Button,
        danhBaiButton: cc.Button,
        xepBaiButton: cc.Button,
        haBaiButton: cc.Button,
        guiBaiButton: cc.Button,
        uButton: cc.Button,
        startButton: cc.Button,

        gameCmd: {
            'default': GameConstant.PHOM.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.UPDATE_HAND, this.onUpdateHand, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.WAITING_DEAL_CARD, this.onWaitingDealCard, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.UPDATE_GAME, this.onUpdateGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.FINISH_GAME, this.onFinishGame, this);

        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.CHANGE_TURN, this.onChangeTurn, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.DISCARD, this.onDiscardResponse, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.PICK_CARD, this.onPickCardResponse, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.TAKE_CARD, this.onTakeCardResponse, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.SHOW_OFF, this.onShowOffResponse, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.AUTO_SHOW_OFF, this.onAutoShowOffResponse, this);
        this.gameManager.eventDispatchers.local.addEventListener(PhomConstant.Event.SENT_CARD, this.onSentCardResponse, this);

        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_INFO, this.onUpdateUserInfo, this);
        var self = this;
        self.myCards = [];

        if (!this.updatedGame) {
            this.clearStateGame();
            this.clearBeforeChangeTurn();
        }
        this.isLoaded = true;

        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].node.on('refresh_game', this.refreshPlayer, this);
        }
    },

    $onUpdate: function $onUpdate() {
        if (this.gameManager) {
            var count;
            if (this.gameManager.gameState === PhomConstant.GameState.WAITING_FOR_NEW_GAME || this.gameManager.gameState === PhomConstant.GameState.FINISH || this.gameManager.gameState === PhomConstant.GameState.FINALIZING) {
                count = Math.floor((this.countDownTime - Date.now()) / 1000);
                count = count >= 0 ? count : 0;
                this.countDownTimeLabel.string = count;
                if (count === 0) {
                    this.countDownTimeLabel.node.active = false;
                    this.gameStateLabel.node.active = false;
                    if (this.gameManager.gameState === PhomConstant.GameState.FINISH) {
                        this.clearStateGame();
                        this.gameStateLabel.string = 'Ván mới sẽ được bắt đầu trong giây lát.';
                        this.gameStateLabel.node.active = true;
                        this.gameManager.gameState = PhomConstant.GameState.NONE;
                    }
                }
            } else {
                this.startButton.node.active = false;
                this.countDownTimeLabel.node.active = false;
                this.gameStateLabel.node.active = false;
            }
        }
    },

    $onFocus: function $onFocus() {
        this.isLostFocus = true;
    },

    $onLostFocus: function $onLostFocus() {
        this.isLostFocus = true;
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================
    onButtonXepBai: function onButtonXepBai() {
        this.audioManager.playButtonClick();
        this.curPlayerUI()._isSanhFirst = !this.curPlayerUI()._isSanhFirst;
        this.curPlayerUI().onXepLaiBai(true);
    },

    onButtonBocBai: function onButtonBocBai() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().action === PhomConstant.Action.PICK_CARD) {
            this.gameManager.requestPickCard();
        }
    },

    onButtonDanhBai: function onButtonDanhBai() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().action === PhomConstant.Action.DISCARD) {
            var cardDiscard = this.curPlayerUI().getCardTouched();
            if (cardDiscard.length === 1) {
                this.gameManager.requestDicard(cardDiscard[0].card);
            } else if (cardDiscard.length === 0) {
                UiManager.openWarningMessage('Bạn cần chọn quân bài để đánh.', 1);
            } else {
                UiManager.openWarningMessage('Chỉ được chọn 1 quân bài để đánh.', 1);
            }
        }
    },

    onButtonAnBai: function onButtonAnBai() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().action === PhomConstant.Action.PICK_CARD) {
            this.gameManager.requestTakeCard();
        }
    },

    onButtonHaBai: function onButtonHaBai() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().action === PhomConstant.Action.SHOW_OFF) {
            var cards = this.curPlayerUI().getCardTouched();
            var cardIds = [];
            for (var i = 0; i < cards.length; i += 1) {
                cardIds.push(cards[i].card.getId());
            }
            this.gameManager.requestShowOff(cardIds);
        }
    },

    onButtonGuiBai: function onButtonGuiBai() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().action === PhomConstant.Action.SENT_CARD) {
            var curPlayer = this.curPlayerUI();
            var sendablePhomList = curPlayer.player.data.inTurnData.sendablePhomList;
            this.gameManager.requestSentCard(sendablePhomList[0].card, sendablePhomList[0].cards);
        }
    },

    onButtonU: function onButtonU() {
        this.audioManager.playButtonClick();
        this.gameManager.requestUPhom();
    },

    onButtonStart: function onButtonStart() {
        this.audioManager.playButtonClick();
        this.gameManager.sendRequestStartGame();
        this.startButton.interactable = false;
        this.startButton.node.active = false;
    },
    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onFinishGame: function onFinishGame(data) {
        this.clearBeforeChangeTurn();
        var dt = 0;
        if (data.__execInfo__) {
            dt = data.__execInfo__.dt;
        }
        this.countDownTime = Date.now() + data.data.time - dt;
        var countMoneyExchange = 0;
        var isU;
        var finishUDen = false;
        var playerWin;
        if (data.data.result.actions) {
            for (var i = 0; i < data.data.result.actions.length; i += 1) {
                var action = data.data.result.actions[i];
                var playerUIPhom = this.findPlayerNodeByName(action.sourcePlayer);
                if (playerUIPhom) {
                    var isUDen = data.data.uDenPlayer && data.data.uDenPlayer === playerUIPhom.player.data.username;
                    if (isUDen) {
                        finishUDen = true;
                    }
                    if (playerUIPhom.player.data.state !== PhomConstant.PlayerState.WAITING) {
                        playerUIPhom.showRankAndMoneyExchange(-action.moneyExchange, action.action, false, isUDen);
                    }
                }
                countMoneyExchange += action.moneyExchange;
                isU = action.action === PhomConstant.Finish.U;
            }
            playerWin = this.findPlayerNodeByName(data.data.result.actions[0].targetPlayer);
            if (playerWin) {
                countMoneyExchange -= Math.floor(countMoneyExchange * this.gameManager.fee);
                playerWin.showRankAndMoneyExchange(countMoneyExchange, PhomConstant.Finish.VE_NHAT, isU, false);
                if (finishUDen) {
                    playerWin.onShowOffCard(playerWin.player.data.phomList);
                }
                if (data.data.uType) {
                    if (data.data.uType.toUpperCase() === 'Ù TRÒN') {
                        playerWin.addEffect(PhomConstant.Effect.U_TRON);
                    } else if (data.data.uType.toUpperCase() === 'Ù KHÔNG CẠ') {
                        playerWin.addEffect(PhomConstant.Effect.U_KHONG_CA);
                    }
                }
            }
            if (playerWin.player.data.username === AuthUser.username) {
                if (isU) {
                    this.audioManager.playThangTrang();
                } else {
                    this.audioManager.playWin();
                }
            } else {
                this.audioManager.playLose();
            }
        }

        if (data.data.result.summary) {
            for (var j = 0; j < data.data.result.summary.length; j += 1) {
                var summary = data.data.result.summary[j];
                var playerShowCard = this.findPlayerNodeByName(summary.userName);
                if (playerShowCard) {
                    if (finishUDen && playerWin === playerShowCard) {
                        continue;
                    }
                    if (playerShowCard.player.data.state !== PhomConstant.PlayerState.WAITING) {
                        playerShowCard.showAllCards(summary.hand);
                        if (!isU) {
                            playerShowCard.pointLabel.string = summary.point + ' Điểm';
                        }
                        playerShowCard.onRefreshGame(true);
                    }
                }
            }
        }
    },

    onUpdateGame: function onUpdateGame(data) {
        this.updatedGame = true;
        this.updateInfoGame(data.data);
        this.clearBeforeChangeTurn();
        if (data.allData.gameState === PhomConstant.GameState.PGS_WAIT_FOR_DEALING) {
            this.onWaitingDealCard({
                time: data.data.time,
                dealer: data.data.dealer
            });
        } else if (data.allData.gameState === PhomConstant.GameState.DEALING) {
            this.clearStateGame();
        } else if (data.allData.gameState === PhomConstant.GameState.PLAYING) {
            var updateData = data.allData;

            this.setStateNocCard(0);
            if (updateData.nNocCards) {
                this.setStateNocCard(updateData.nNocCards);
            }
            // player
            var childView;
            for (var i = 0; i < updateData.players.length; i += 1) {
                childView = this.getPlayerByUserName(updateData.players[i].username);
                if (childView) {
                    var playerUIPhom = childView.getComponent('PlayerUIPhom');
                    playerUIPhom.onUpdateGame();

                    if (updateData.players[i].state === PhomConstant.PlayerState.IN_TURN) {
                        var dt = 0;
                        if (data.__execInfo__) {
                            dt = data.__execInfo__.dt;
                        }
                        playerUIPhom.setCountDown(updateData.time - dt);
                        playerUIPhom.setStateInTurn(updateData.players[i].inTurnState);
                        if (updateData.players[i].username === AuthUser.username) {
                            this.setCurrentPlayerInTurn();
                        }
                    } else if (updateData.players[i].state === PhomConstant.PlayerState.WAITING) {
                        if (updateData.players[i].username === AuthUser.username) {
                            this.clearBeforeChangeTurn();
                        }
                    }
                }
            }
        } else if (data.allData.gameState === PhomConstant.GameState.FINISH) {
            this.clearStateGame();
            this.gameStateLabel.string = 'Ván mới sẽ được bắt đầu trong giây lát.';
            this.gameStateLabel.node.active = true;
        } else {}
    },

    onUpdateHand: function onUpdateHand(data) {
        this.startButton.node.active = false;
        this.countDownTimeLabel.node.active = false;
        this.gameStateLabel.node.active = false;
        this.setStateNocCard(data.nNocCards);
        this.audioManager.playBaiChia();
        var childView;
        for (var i = 0; i < data.players.length; i += 1) {
            childView = this.getPlayerByUserName(data.players[i].username);
            if (childView) {
                var playerUIPhom = childView.getComponent('PlayerUIPhom');

                if (childView === this.playerNodeList[0].node) {
                    playerUIPhom.onUpdateHand(playerUIPhom.player.data.cards, playerUIPhom.player.data.handSize, true);
                } else {
                    playerUIPhom.onUpdateHand(null, playerUIPhom.player.data.handSize, false);
                }
            }
        }
    },

    onWaitingDealCard: function onWaitingDealCard(data) {
        this.gameStateLabel.string = 'Chuẩn bị ván mới';
        this.gameStateLabel.node.active = true;
        var dt = 0;
        if (data.__execInfo__) {
            dt = data.__execInfo__.dt;
        }
        this.countDownTime = Date.now() + data.time - dt;
        this.countDownTimeLabel.string = Math.floor(data.time / 1000);
        this.countDownTimeLabel.node.active = true;

        this.nocCardNode.active = false;
        this.arrowNocNode.active = false;
        this.numNocCardLabel.string = 0;

        var childView;
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            childView = this.playerNodeList[i];
            if (childView) {
                childView.getComponent('PlayerUIPhom').clearAll();
            }
        }
        if (!data) {
            return;
        }
        if (data.dealer === this.curPlayerUI().player.data.username) {
            this.startButton.node.active = true;
            this.startButton.interactable = true;
        } else {
            this.startButton.node.active = false;
            this.startButton.interactable = false;
        }
    },

    onChangeTurn: function onChangeTurn(data) {
        this.startButton.node.active = false;
        if (data.allData.nNocCards) {
            this.setStateNocCard(data.allData.nNocCards);
        }
        this.audioManager.playTurnStart();
        var childView;
        if (this.foundDiscard) {
            // this.foundDiscard.hoverAnNode.active = false;
            this.foundDiscard = null;
        }
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            childView = this.playerNodeList[i].getComponent('PlayerUIPhom');
            if (!childView.player) {
                continue;
            }
            if (childView.player.data.username !== data.data.userName) {
                childView.clearCountDown();
                if (childView.player.data.state !== PhomConstant.PlayerState.WAITING) {
                    childView.clearEffects();
                }
            } else {
                var dt = 0;
                if (data.__execInfo__) {
                    dt = data.__execInfo__.dt;
                }
                childView.setCountDown(data.data.time - dt);
                childView.setStateAction(data.data.action);
            }
            childView.hideGuiButtons();
        }

        this.clearBeforeChangeTurn();
        if (this.curPlayerUI().player.data.state !== PhomConstant.PlayerState.WAITING) {
            this.xepBaiButton.interactable = true;
        }
        if (data.data.userName === this.curPlayerUI().player.data.username) {
            this.setCurrentPlayerInTurn();
        }
        // this.onRefreshGame(data);
    },

    onDiscardResponse: function onDiscardResponse(data) {
        this.audioManager.playDanhBai();
        this.xepBaiButton.interactable = false;
        this.danhBaiButton.interactable = false;
        var playPhomView = this.getPlayerByUserName(data.data.userName);
        if (playPhomView) {
            playPhomView.getComponent('PlayerUIPhom').onDiscard([data.data.card]);
            this.lastPlayer = playPhomView.getComponent('PlayerUIPhom');
        }
    },

    onSentCardResponse: function onSentCardResponse(data) {
        this.audioManager.playPhomPickCard();
        this.xepBaiButton.interactable = false;
        this.guiBaiButton.interactable = false;
        var sourcePlayer = this.getPlayerByUserName(data.data.userName);
        var sourcePlayerUIPhom;
        if (sourcePlayer) {
            sourcePlayerUIPhom = sourcePlayer.getComponent('PlayerUIPhom');
        }
        var targetPlayer = this.getPlayerByUserName(data.data.targetPlayer);
        if (targetPlayer) {
            targetPlayer.getComponent('PlayerUIPhom').onSentCard(data.data.card, data.data.cards, sourcePlayerUIPhom);
        } else {
            if (this.playerQuit) {
                for (var k = 0; k < this.playerQuit.length; k += 1) {
                    if (this.playerQuit[k].username === data.data.targetPlayer) {
                        targetPlayer = this.playerQuit[k].slot;
                        if (targetPlayer) {
                            targetPlayer.getComponent('PlayerUIPhom').onSentCard(data.data.card, data.data.cards, sourcePlayerUIPhom);
                        }
                    }
                }
            }
        }
    },

    onTakeCardResponse: function onTakeCardResponse(data) {
        this.xepBaiButton.interactable = false;
        this.anBaiButton.interactable = false;
        this.bocBaiButton.interactable = false;
        this.audioManager.playPhomPickCard();
        var targetPlayer = this.getPlayerByUserName(data.data.targetPlayer);
        var targetPlayerUIPhom;
        if (targetPlayer) {
            targetPlayerUIPhom = targetPlayer.getComponent('PlayerUIPhom');
            targetPlayerUIPhom.onTakeCard(data.data.card);
            var moneyExchange = data.data.money - Math.floor(data.data.money * this.gameManager.fee);
            targetPlayerUIPhom.showMoneyExchange(moneyExchange);
        }

        var sourcePlayer = this.getPlayerByUserName(data.data.sourcePlayer);
        if (sourcePlayer) {
            var sourcePlayerUIPhom = sourcePlayer.getComponent('PlayerUIPhom');
            sourcePlayerUIPhom.showMoneyExchange(-data.data.money);
            sourcePlayerUIPhom.effectTakenCard(targetPlayerUIPhom, data.data.card);
        }

        if (data.data.isTaiLuot && data.data.taiLuotPlayer !== '') {
            var taiLuotPlayer = this.getPlayerByUserName(data.data.taiLuotPlayer);
            if (taiLuotPlayer) {
                var taiLuotPlayerUIPhom = taiLuotPlayer.getComponent('PlayerUIPhom');
                taiLuotPlayerUIPhom.setEffect(PhomConstant.Effect.TAI_LUOT);
            }
        }
    },

    onPickCardResponse: function onPickCardResponse(data) {
        this.xepBaiButton.interactable = false;
        this.bocBaiButton.interactable = false;
        this.anBaiButton.interactable = false;
        var playPhomView = this.getPlayerByUserName(data.data.userName);
        if (playPhomView) {
            this.audioManager.playPhomPickCard();
            var playerUIPhom = playPhomView.getComponent('PlayerUIPhom');
            var pickedCard;
            if (playerUIPhom.player.data.pickedCards) {
                pickedCard = playerUIPhom.player.data.pickedCards[playerUIPhom.player.data.pickedCards.length - 1];
            } else {
                pickedCard = null;
            }
            playerUIPhom.onPickCard(pickedCard);
        }
    },

    onShowOffResponse: function onShowOffResponse(data) {
        this.xepBaiButton.interactable = false;
        this.showOff(data);
    },

    onAutoShowOffResponse: function onAutoShowOffResponse(data) {
        this.xepBaiButton.interactable = false;
        this.showOff(data);
    },
    // ============================================================
    // Other
    // ============================================================

    curPlayerUI: function curPlayerUI() {
        return this.playerNodeList[0];
    },

    setCurrentPlayerInTurn: function setCurrentPlayerInTurn() {
        var inTurnData = this.curPlayerUI().player.data.inTurnData;
        var inTurnState = this.curPlayerUI().player.data.inTurnState;
        switch (inTurnState) {
            case PhomConstant.InTurnState.DISCARD:
                this.haBaiButton.node.active = false;
                this.guiBaiButton.node.active = false;
                this.anBaiButton.node.active = true;
                this.bocBaiButton.node.active = true;
                this.setStateDisCard();
                this.curPlayerUI().action = PhomConstant.Action.DISCARD;

                break;
            case PhomConstant.InTurnState.PICK_OR_TAKE_CARD:
                this.haBaiButton.node.active = false;
                this.guiBaiButton.node.active = false;
                this.anBaiButton.node.active = true;
                this.bocBaiButton.node.active = true;
                this.setStatePickCard();
                this.curPlayerUI().action = PhomConstant.Action.PICK_CARD;
                if (inTurnData.canTake) {
                    this.setStateTakeCard(inTurnData.card);
                }

                break;
            case PhomConstant.InTurnState.SHOW_OFF:
                this.haBaiButton.node.active = true;
                this.guiBaiButton.node.active = true;
                this.anBaiButton.node.active = false;
                this.bocBaiButton.node.active = false;
                this.setStateShowOff(inTurnData.phomList);
                this.curPlayerUI().action = PhomConstant.Action.SHOW_OFF;

                break;
            case PhomConstant.InTurnState.SEND:
                this.haBaiButton.node.active = true;
                this.guiBaiButton.node.active = true;
                this.anBaiButton.node.active = false;
                this.bocBaiButton.node.active = false;
                this.setStateSentCard(inTurnData.sendablePhomList);
                this.curPlayerUI().action = PhomConstant.Action.SENT_CARD;

                break;
        }
        if (inTurnData.canU) {
            this.setStateUPhom();
        }
    },

    onRefreshGame: function onRefreshGame(params) {
        // player
        var childView;
        for (var i = 0; i < params.allData.players.length; i += 1) {
            childView = this.getPlayerByUserName(params.allData.players[i].username);
            if (childView) {
                childView.getComponent('PlayerUIPhom').onRefreshGame(false);
            }
        }
    },

    refreshPlayer: function refreshPlayer(event) {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (!this.playerNodeList[i].player) {
                continue;
            }
            this.playerNodeList[i].node.getComponent('PlayerUIPhom').onRefreshGame(false, event.detail);
        }
    },

    getPlayerByUserName: function getPlayerByUserName(username) {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (!this.playerNodeList[i].player) {
                continue;
            }
            if (this.playerNodeList[i].player.data.username === username) {
                return this.playerNodeList[i].node;
            }
        }
        return null;
    },

    updateInfoGame: function updateInfoGame(data) {
        var optionLabel = data && data.acceptUTron ? 'Luật: Ù Tròn' : 'Luật: Ù Thường';
        this.topPanelInGameData.optionLabel = optionLabel;
        if (this.topPanelInGame) {
            this.topPanelInGame.setOptionLabel(optionLabel);
        }
    },

    setStateNocCard: function setStateNocCard(data) {
        // board
        if (data > 0) {
            this.nocCardNode.active = true;
            this.numNocCardLabel.node.active = true;
            this.numNocCardLabel.string = data;
        } else {
            this.nocCardNode.active = false;
            this.numNocCardLabel.node.active = false;
            this.numNocCardLabel.string = '0';
        }
    },

    clearStateGame: function clearStateGame() {
        this.nocCardNode.active = false;
        this.arrowNocNode.active = false;
        this.numNocCardLabel.string = 0;
        this.startButton.node.active = false;
        this.startButton.interactable = false;
        this.playerQuit = [];
        var childView;
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            childView = this.playerNodeList[i].getComponent('PlayerUIPhom');
            if (childView) {
                childView.clearAll();
            }
        }
    },

    showOff: function showOff(data) {
        var playPhomView = this.getPlayerByUserName(data.data.userName);
        if (playPhomView) {
            this.audioManager.playDanhBai();
            var playerUIPhom = playPhomView.getComponent('PlayerUIPhom');
            playerUIPhom.onShowOffCard(data.data.phomList);
        }
    },

    setStateDisCard: function setStateDisCard() {
        this.danhBaiButton.interactable = true;
        this.xepBaiButton.interactable = true;
    },

    setStatePickCard: function setStatePickCard() {
        this.arrowNocNode.active = false;
        this.bocBaiButton.interactable = true;
    },

    setStateTakeCard: function setStateTakeCard(card) {
        this.anBaiButton.interactable = true;
        if (this.lastPlayer) {
            this.foundDiscard = this.lastPlayer.findCard(card, this.lastPlayer.portCardTrash);
            if (this.foundDiscard) {
                this.foundDiscard.hoverAnNode.active = true;
            }
        }
    },

    setStateShowOff: function setStateShowOff(data) {
        this.haBaiButton.interactable = true;
        this.curPlayerUI().setStateCardInShowOff(data);
    },

    setStateSentCard: function setStateSentCard(sendablePhomList) {
        if (sendablePhomList) {
            this.guiBaiButton.interactable = true;
            var playerUIPhom = this.curPlayerUI();
            var cardId = sendablePhomList[0].card;
            var card = playerUIPhom.findCard(cardId, playerUIPhom.cardHold);
            if (card) {
                card.onButtonTouch();
            }
            var count = 0;
            for (var j = 0; j < sendablePhomList.length; j += 1) {
                if (cardId === sendablePhomList[j].card) {
                    count += 1;
                }
            }
            if (count > 1) {
                // this.guiBaiButton.interactable = false;
                for (var i = 0; i < sendablePhomList.length; i += 1) {
                    var targetPlayer = this.getPlayerByUserName(sendablePhomList[i].userName);
                    if (targetPlayer) {
                        targetPlayer.getComponent('PlayerUIPhom').showGuiButtonInPhoms(cardId, sendablePhomList[i].cards, this.gameManager);
                    } else {
                        if (this.playerQuit) {
                            for (var k = 0; k < this.playerQuit.length; k += 1) {
                                if (this.playerQuit[k].username === sendablePhomList[i].userName) {
                                    targetPlayer = this.playerQuit[k].slot;
                                    if (targetPlayer) {
                                        targetPlayer.getComponent('PlayerUIPhom').showGuiButtonInPhoms(cardId, sendablePhomList[i].cards, this.gameManager);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    setStateUPhom: function setStateUPhom() {
        this.uButton.interactable = true;
        this.uButton.node.active = true;
    },

    clearBeforeChangeTurn: function clearBeforeChangeTurn() {
        this.arrowNocNode.active = false;
        this.uButton.node.active = false;
        this.setInteractableButtons(false);
    },

    setInteractableButtons: function setInteractableButtons(value) {
        this.xepBaiButton.interactable = value;
        this.anBaiButton.interactable = value;
        this.danhBaiButton.interactable = value;
        this.bocBaiButton.interactable = value;
        this.uButton.interactable = value;
        this.haBaiButton.interactable = value;
        this.guiBaiButton.interactable = value;

        this.xepBaiButton.node.setScale(1);
        this.anBaiButton.node.setScale(1);
        this.danhBaiButton.node.setScale(1);
        this.bocBaiButton.node.setScale(1);
        this.uButton.node.setScale(1);
        this.haBaiButton.node.setScale(1);
        this.guiBaiButton.node.setScale(1);
    },

    onPrePlayerRemoved: function onPrePlayerRemoved(playerNode) {
        if (this.playerQuit) {
            this.playerQuit = [];
        }
        var playerUIPhom = playerNode.node.getComponent('PlayerUIPhom');
        if (playerUIPhom.backCardNode) {
            playerUIPhom.backCardNode.active = false;
        }
        if (this.playerQuit) {
            this.playerQuit.push({
                username: playerUIPhom.player.data.username,
                slot: playerNode
            });
        }
    },

    onPostPlayerAdded: function onPostPlayerAdded(playerNode) {
        if (playerNode.player) {
            if (playerNode.player.data.state === PhomConstant.PlayerState.WAITING) {
                playerNode.addEffect(PhomConstant.Effect.DANG_DOI);
            }
        }
    }

});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","PhomConstant":"PhomConstant","UiManager":"UiManager"}],"GameplayPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, '48f37FebZhEirVLQ/3A/RfD', 'GameplayPoker');
// scripts\components\games\poker\GameplayPoker.js

var PokerConstant = require('PokerConstant'),
    Utils = require('Utils'),
    Card = require('Card'),
    CardUI = require('CardUI'),
    Slider = require('Slider'),

// AuthUser = require('AuthUser'),
UiManager = require('UiManager'),
    GameConstant = require('GameConstant'),
    GameplayLieng = require('GameplayLieng');

cc.Class({
    'extends': GameplayLieng,

    properties: {
        buyChipSlider: Slider,
        autoBuyCheckBox: cc.Node,
        buyChipPanel: cc.Node,
        buyChipButton: cc.Node,
        currentMoney: cc.Label,
        communityCardsHold: {
            'default': [],
            type: CardUI
        },
        gameCmd: {
            'default': GameConstant.POKER.CMD,
            visible: false,
            override: true
        },
        autoBuy: false
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        GameplayLieng.prototype.$onLoad.call(this);
        this.gameManager.eventDispatchers.local.addEventListener(PokerConstant.Event.SHOW_BUY_CHIP, this.showBuyChipPanel, this);
        this.gameManager.eventDispatchers.local.addEventListener(PokerConstant.Event.HIDE_BUY_CHIP_BUTTON, this.hideBuyChipButton, this);
        this.gameManager.eventDispatchers.local.addEventListener(PokerConstant.Event.CUT_OFF_MONEY_POKER, this.showCutOffMoney, this);
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================
    buyChip: function buyChip() {
        this.gameManager.buyMoneyJoinTable(this.buyChipSlider.currentValue);
        this.buyChipPanel.active = false;
        this.autoBuyMoney = this.buyChipSlider.currentValue;
        this.audioManager.playButtonClick();
    },

    openBuyChipPanel: function openBuyChipPanel() {
        this.buyChipPanel.active = true;
        this.audioManager.playButtonClick();
    },

    closeBuyChipPanel: function closeBuyChipPanel() {
        this.buyChipPanel.active = false;
        this.audioManager.playButtonClick();
    },

    setAutoBuyMoney: function setAutoBuyMoney() {
        this.autoBuyCheckBox.active = !this.autoBuyCheckBox.active;
        this.autoBuy = this.autoBuyCheckBox.active;
        this.audioManager.playButtonClick();
    },
    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onChangeStateGame: function onChangeStateGame(params) {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (this.playerNodeList[i].player) {
                if (this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.FOLDED && this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.ALL_IN && this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.NONE && this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.OFF_MONEY) {
                    this.playerNodeList[i].clearEffects();
                }
                if (PokerConstant.GameStatePoker.PREFLOP !== params.allData.gameState) {
                    this.setCallMoneyPlayer(this.playerNodeList[i], false, 0);
                }
            }
        }
        this.bettingSlider.node.active = false;
        if (params.allData.communityCards && params.allData.communityCards.length > 0) {
            this.showCommunityCards(params.allData.communityCards);
        }
        this.showStateGame(params.allData.gameState);
    },

    onChangeTurn: function onChangeTurn(params) {
        GameplayLieng.prototype.onChangeTurn.call(this, params);
        if (params && params.length > 0) {
            this.showCommunityCards(params);
        }
    },

    // update info game
    updateInfoGame: function updateInfoGame(params) {
        GameplayLieng.prototype.updateInfoGame.call(this, params);
        for (var j = 0; j < this.communityCardsHold.length; j += 1) {
            var cardUI = this.communityCardsHold[j];
            cardUI.fold();
            cardUI.node.active = false;
        }
        //update community cards
        var self = this;
        this.addTimeout(PokerConstant.TimeoutId.SHOW_COMMUNITY_CARDS, setTimeout(function () {
            self.showCommunityCards(params.allData.communityCards);
        }, 2000));

        var totalbetting = 0,
            k;
        if (params.allData.pots) {
            for (k = 0; k < params.allData.pots.length; k += 1) {
                totalbetting += params.allData.pots[k].money;
            }
            this.totalMoneyCallLabel.string = Utils.Number.format(totalbetting);
            this.calculateNumberChipType(totalbetting, this.chipContainer);
        }

        this.showStateGame(params.allData.gameState);
    },

    showBuyChipPanel: function showBuyChipPanel(params) {
        if (!this.autoBuy) {
            this.buyChipSlider.setDefaultValue(params[0], params[1], 0.5, this.gameManager.bettingInfo.betting);
            this.buyChipPanel.active = true;
            this.buyChipButton.active = true;
            this.currentMoney.string = Utils.Number.format(params[2]);
        } else {
            this.gameManager.buyMoneyJoinTable(this.buyChipSlider.currentValue > params[1] ? params[1] : this.buyChipSlider.currentValue);
        }
    },

    hideBuyChipButton: function hideBuyChipButton() {
        this.buyChipButton.active = false;
    },

    // onDrawCard: function () {
    //     var self = this,
    //         card,
    //         count = 0,
    //         time = 0.2,
    //         timeDelay = 0.2,
    //         rotation = 0,
    //         indexZ = 130,
    //         i = 0,
    //         j = 0;
    //     this.hideStartTime();

    //     for (i = 0; i < this.playerNodeList.length; i += 1) {
    //         if (this.playerNodeList[i].player && this.playerNodeList[i].player.data.handSize > 0 && this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.OFF_MONEY) {
    //             var playerUIXiTo = this.playerNodeList[i].node.getComponent('PlayerUIXiTo');
    //             var player = this.playerNodeList[i].player.data;
    //             count = 0;
    //             for (j = playerUIXiTo.getNumberActiveChildren(); j < player.handSize; j += 1) {
    //                 this.playerNodeList[i].node.zIndex = indexZ;
    //                 card = cc.instantiate(this.cardPrefab);
    //                 card.setScale(0.5, 0.5);
    //                 card.zIndex = indexZ;
    //                 card.parent = this.dealer;
    //                 this.dealer.zIndex = 30;
    //                 indexZ -= 1;
    //                 count += 1;
    //                 var cardId;
    //                 if (i === 0 && this.playerNodeList[i].player.data.state !== PokerConstant.PlayerState.FOLD) {
    //                     cardId = player.cards[j];
    //                 } else {
    //                     if (this.gameCmd === GameConstant.XITO.CMD && player.handSize < this.gameManager.gameType) {
    //                         cardId = player.publicCards[j - (player.handSize - player.publicCards.length)];
    //                     } else {
    //                         cardId = null;
    //                     }
    //                 }
    //                 this.drawCardEffect(card, this.playerNodeList[i], time, timeDelay * count, rotation, cardId, j);
    //             }
    //         }
    //     }
    //     this.node.runAction(cc.sequence(
    //         cc.delayTime(time + timeDelay),
    //         cc.callFunc(function () {
    //             var playerUIXiTo = self.playerNodeList[0].node.getComponent('PlayerUIXiTo');
    //             var scale = playerUIXiTo.cardsHold[0].node.parent.getScale();
    //             playerUIXiTo.cardsHold[0].node.parent.setScale(-scale, scale);

    //             var xuatHienCardTrenTayAction = cc.sequence(
    //                 cc.delayTime(0.3),
    //                 cc.scaleTo(0.3, scale)
    //             );
    //             playerUIXiTo.cardsHold[0].node.parent.runAction(xuatHienCardTrenTayAction);
    //         })
    //     ));
    // },

    // drawCardEffect: function (card, player, time, timeDelay, rotation, cardId, index) {
    //     // this.audioManager.playBaiChia();
    //     var playerUIXiTo = player.node.getComponent('PlayerUIXiTo');
    //     var pos = playerUIXiTo.holdNode.convertToWorldSpaceAR(playerUIXiTo.cardsHold[index].node.position);
    //     var position = this.dealer.convertToNodeSpaceAR(pos);
    //     var chiaBaiAction = cc.sequence(
    //         cc.delayTime(timeDelay),
    //         cc.spawn(
    //             cc.moveTo(time, cc.p(position.x, position.y - 17)),
    //             cc.rotateTo(time, rotation)
    //         ),
    //         cc.callFunc(function () {
    //             if (player.player && playerUIXiTo.getNumberActiveChildren() < player.player.data.handSize) {
    //                 if (player.player.data.username === AuthUser.username) {
    //                     var foundCard = playerUIXiTo.findCard(cardId);
    //                     if (foundCard) {
    //                         foundCard.node.position = cc.p(0, 0);
    //                         card.destroy();
    //                         return;
    //                     }
    //                 }
    //                 var cardPlayer = playerUIXiTo.cardsHold[index];
    //                 if (cardPlayer) {
    //                     card.zIndex = cardPlayer.node.zIndex;
    //                     card.rotation = cardPlayer.node.rotation;
    //                     card.position = cardPlayer.node.position;
    //                     card.parent = cardPlayer.node.parent;
    //                     card.setSiblingIndex(cardPlayer.node.getSiblingIndex());

    //                     if (card) {
    //                         var cardUI = card.getComponent('CardUI');
    //                         playerUIXiTo.cardsHold[index] = cardUI;
    //                         cardPlayer.node.destroy();
    //                         cardUI.node.active = true;
    //                         cardUI.node.setScale(1, 1);
    //                         cardUI.node.runAction(cc.sequence(cc.delayTime(0.6 - timeDelay),
    //                             cc.callFunc(function () {
    //                                 if (card) {
    //                                     var cardUI = card.getComponent('CardUI');
    //                                     if (player.player.data.cards) {
    //                                         cardId = player.player.data.cards[index];
    //                                     }
    //                                     if (Utils.Type.isNumber(cardId) && cardId >= 0) {
    //                                         cardUI.setCard(Card.fromId(cardId));
    //                                         cardUI.showTransparentBlackNode(false);
    //                                     }
    //                                 }
    //                             })
    //                         ));
    //                     }
    //                 }
    //             } else {
    //                 card.destroy();
    //             }

    //         }, this)

    //     );
    //     chiaBaiAction.easing(cc.easeCubicActionOut());
    //     card.stopAllActions();
    //     card.runAction(chiaBaiAction);
    // },

    // ============================================================
    // Other
    // ============================================================
    showCutOffMoney: function showCutOffMoney(params) {
        var message = params.data.userName + ' ' + params.data.msg + ' ' + Utils.Number.format(params.data.money);
        UiManager.openWarningMessage(message, 2);
    },

    onShowBetting: function onShowBetting(params, playerUI) {
        var totalbetting = 0,
            k;
        if (params.allData.pots) {
            for (k = 0; k < params.allData.pots.length; k += 1) {
                totalbetting += params.allData.pots[k].money;
            }
            this.totalMoneyCallLabel.string = Utils.Number.format(totalbetting);
        }
        if (params.data.money > 0) {
            this.chipEffect(params.data.money, totalbetting, playerUI);
            this.setCallMoneyPlayer(playerUI, true, params.data.currentBetting);
            this.audioManager.playCoinDrop();
        }
    },

    showStateGame: function showStateGame(gameState) {
        switch (gameState) {
            case PokerConstant.GameStatePoker.PREFLOP:
                this.gameStateLabel.string = 'Vòng 1';
                this.isPlaying = true;
                break;
            case PokerConstant.GameStatePoker.FLOP:
                this.gameStateLabel.string = 'Vòng 2';
                this.isPlaying = true;
                break;
            case PokerConstant.GameStatePoker.TURN:
                this.gameStateLabel.string = 'Vòng 3';
                this.isPlaying = true;
                break;
            case PokerConstant.GameStatePoker.RIVER:
                this.gameStateLabel.string = 'Vòng Cuối';
                this.isPlaying = true;
                break;
        }
        this.gameStateLabel.node.active = true;
    },

    finishDrawCard: function finishDrawCard(cardUI, player) {
        var x = cardUI.node.x;
        var y = cardUI.node.y;
        var nodeCardRotation = cardUI.node.rotation;
        if (player === this.playerNodeList[0]) {
            cardUI.node.scaleX = 0;
        }
        if (player.node.x <= 0) {
            cardUI.node.x = x - 155;
        } else {
            cardUI.node.x = x + 155;
        }
        cardUI.node.rotation = 0;
        cardUI.node.active = true;
        cardUI.node.stopAllActions();
        var xuatHienCardTrenTayAction = cc.sequence(cc.spawn(cc.moveTo(0.3, cc.p(x, y)), cc.scaleTo(0.3, 1), cc.rotateTo(0.3, nodeCardRotation)));
        cardUI.node.runAction(xuatHienCardTrenTayAction);
    },

    showCommunityCards: function showCommunityCards(communityCards) {
        if (communityCards && (this.isPlaying || this.gameManager.gameState === PokerConstant.GameState.DEALING)) {
            for (var j = 0; j < this.communityCardsHold.length; j += 1) {
                var cardUI = this.communityCardsHold[j];
                if (!cardUI.node.active) {
                    cardUI.node.active = true;
                    cardUI.node.stopAllActions();
                    cardUI.node.runAction(cc.scaleTo(0.3, 1));
                }
                if (j < communityCards.length && cardUI.card === null) {
                    cardUI.setCard(Card.fromId(communityCards[j]));
                    cardUI.node.setScale(0, 0.7);
                    cardUI.node.stopAllActions();
                    cardUI.node.runAction(cc.scaleTo(0.3, 1));
                }
            }
        }
    },

    restartGame: function restartGame() {
        GameplayLieng.prototype.restartGame.call(this);
        for (var j = 0; j < this.communityCardsHold.length; j += 1) {
            var cardUI = this.communityCardsHold[j];
            cardUI.fold();
            cardUI.node.active = false;
        }
    }

});

cc._RFpop();
},{"Card":"Card","CardUI":"CardUI","GameConstant":"GameConstant","GameplayLieng":"GameplayLieng","PokerConstant":"PokerConstant","Slider":"Slider","UiManager":"UiManager","Utils":"Utils"}],"GameplayRoulette":[function(require,module,exports){
"use strict";
cc._RFpush(module, '54feat3oE1N9pSuBtyqEdPz', 'GameplayRoulette');
// scripts\components\games\roulte\GameplayRoulette.js

var GameConstant = require('GameConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    BaseMainGameplay = require('BaseMainGameplay'),
    RouletteConstant = require('RouletteConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        resultList: {
            'default': [],
            type: cc.Collider
        },
        potInfor: {
            'default': [],
            type: cc.Node

        },
        parentChipBetting: cc.Node,
        chipPrefab: cc.Prefab,
        parentVongQuay: cc.Node,
        vongQuay: cc.Node,
        resultLabel: cc.Label,
        vienBi: cc.Node,
        lblCuaDat: cc.Label,
        lblTyLe: cc.Label,
        lblTongDat: cc.Label,
        lblState: cc.Label,
        banker: cc.Node,
        lblTimer: cc.Label,
        parentVienBi: cc.Node,
        btnX2: cc.Button,
        btnCancelBet: cc.Button,
        btnRebet: cc.Button,
        gameCmd: {
            'default': GameConstant.ROULTE.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.listChipBetting = [];
        this.moneyBetSelect = 0;
        this.result = 0;
        this.myTotallMoneyBet = 0;

        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.ADD_LIST_BETTING, this._addChipBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.BETTING_SUCCESS, this.onBettingSuccess, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.ROTATE_VONG_QUAY, this._rotateVongQuay, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.FINISH_GAME, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.CHANGE_STATE, this.onChangeState, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.CANCEL_BET, this.onCancelBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(RouletteConstant.Event.BETTING_UPDATEGAME, this.onBettingUpdate, this);
        this._setOnClickPot();
        this._disableColiderResult();
        this._disableAllButton();
        this.lblTongDat.string = 0;
    },

    $onUpdate: function $onUpdate() {
        if (this.gameManager.gameState === RouletteConstant.GameState.PLAYER_BETTING) {
            this.lblTimer.node.parent.active = true;
            var count = Math.floor((this.gameManager.time - Date.now()) / 1000);
            count = count >= 0 ? count : 0;
            this.lblTimer.string = count;
            if (count <= 0) {
                this.lblTimer.node.parent.active = false;
            }
        }
    },

    $onFocus: function $onFocus() {
        if (this.gameManager.gameState === RouletteConstant.GameState.FINALIZING) {
            this.lblTimer.node.parent.active = false;
        }
    },

    onBettingUpdate: function onBettingUpdate(params) {
        this.audioManager.playChipBay();
        for (var i = 0; i < params.info.length; i += 1) {
            var chip,
                playerParent = this.findPlayerNodeByName(params.info[i].userName),
                chipComponent,
                slotComponent,
                myMoney = 0;
            chip = cc.instantiate(this.chipPrefab);
            if (playerParent) {
                chip.parent = playerParent.node.parent;
                chip.position = playerParent.node;
            }
            chipComponent = chip.getComponent('Chip');
            chipComponent.activeSelectChip(false);
            chipComponent.moneyLabel.node.active = false;
            chip.scale = cc.v2(0.5, 0.5);
            chipComponent.init(params.info[i].money);
            chipComponent = chip.getComponent(cc.Button);
            chipComponent.enabled = false;
            // chipComponent =
            chip.removeComponent('ButtonScaler');
            // chipComponent.removeComponent();
            slotComponent = this.potInfor[params.id].getComponent('RoulettePotInfor');
            slotComponent.init();
            if (params.info[i].username === AuthUser.username) {
                myMoney = params.info[i].money;
            }
            slotComponent.setMoneyPot(myMoney, params.info[i].money);
            slotComponent.addPlayerBetToPot(params.info[i].userName, params.info[i].money);
            var moveChip = cc.moveTo(0.5, cc.v2(this.potInfor[params.id].x, this.potInfor[params.id].y)).easing(cc.easeOut(2.0));
            chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
                this.destroy();
            }, chip)));
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}

        var potComponent = this.potInfor[params.pot].getComponent('RoulettePotInfor');
        this._moveChipToPlayer(params.username, this.potInfor[params.pot]);
        potComponent.removeMoneyPot(params.username);
        if (params.username === AuthUser.username) {
            this.lblTongDat.string = '0';
            this.btnX2.interactable = false;
            this.btnCancelBet.interactable = false;
        }
    },

    onChangeState: function onChangeState() {
        switch (this.gameManager.gameState) {
            case RouletteConstant.GameState.PLAYER_BETTING:
                this.myTotallMoneyBet = 0;
                this.lblTongDat.string = Utils.Number.format(this.myTotallMoneyBet);
                this._clearEfectFinish();
                this.lblState.string = 'Hãy chọn cửa để đặt';
                this._showPotWin(0, false);
                if (this.gameManager.history.length > 0 && !this.gameManager.isMaster) {
                    this.btnRebet.interactable = true;
                }
                this.audioManager.playTurnStart();
                break;
            case RouletteConstant.GameState.FINALIZING:
                this.lblState.string = 'Kết quả';
                this._disableAllButton();
                break;
        }
    },
    _disableAllButton: function _disableAllButton() {
        this.btnRebet.interactable = false;
        this.btnX2.interactable = false;
        this.btnCancelBet.interactable = false;
    },
    onFinishGame: function onFinishGame(params) {
        var self = this;
        var action = cc.sequence(cc.callFunc(function () {
            self._showPotWin(params.potWin, true);
        }), cc.callFunc(function () {
            self._bankerPayChip(params.potWin);
        }), cc.delayTime(1), cc.callFunc(function () {
            self._payChipToPlayer(params.potWin);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._showMoneyFinish(params.players);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._moveChipToBanker();
        }), cc.callFunc(function () {
            self._showBankerMoneyFinish(params.banker);
        }), cc.callFunc(function () {
            self._clearPlayerInPot();
        }), cc.delayTime(2), cc.callFunc(function () {
            self._clearEfectFinish();
        }));
        this.node.runAction(action);
    },
    _clearPlayerInPot: function _clearPlayerInPot() {
        var self = this;
        for (var i = 0; i < self.potInfor.length; i += 1) {
            var slotComponent = self.potInfor[i].getComponent('RoulettePotInfor');
            slotComponent.playerBetList = {};
            slotComponent.totallMoneyLong = 0;
            slotComponent.myMoneyLong = 0;
            slotComponent.setMoneyPot(0, 0);
            slotComponent.destroyChipFacke(true);
        }
    },

    _bankerPayChip: function _bankerPayChip(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            if (this.potInfor[pots[i]]) {
                if (Object.keys(this.potInfor[pots[i]].getComponent('RoulettePotInfor').playerBetList).length > 0) {
                    this._moveChipToPlayer(this.potInfor[pots[i]], this.banker);
                }
            }
        }
    },

    _payChipToPlayer: function _payChipToPlayer(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            if (this.potInfor[pots[i]]) {
                var slot = this.potInfor[pots[i]].getComponent('RoulettePotInfor');
                this._findPlayerWinInSlost(slot.playerBetList, pots[i]);
            }
        }
    },
    _findPlayerWinInSlost: function _findPlayerWinInSlost(player, pot) {
        var self = this;
        if (this.potInfor[pot]) {
            var slotComponent = self.potInfor[pot].getComponent('RoulettePotInfor');
            slotComponent.destroyChipFacke();
            var arr = Object.keys(player);
            for (var i = 0; i < arr.length; i += 1) {
                self._moveChipToPlayer(arr[i], self.potInfor[pot]);
            }
        }
    },

    _moveChipToBanker: function _moveChipToBanker() {
        var self = this;
        for (var i = 0; i < self.potInfor.length; i += 1) {
            if (this.potInfor[i]) {
                var slotComponent = this.potInfor[i].getComponent('RoulettePotInfor');
                if (!slotComponent.isWin) {
                    if (slotComponent.chipFackeList.length > 0) {
                        this._moveChipToPlayer(self.banker, self.potInfor[i]);
                    }
                }
            }
        }
    },
    _moveChipToPlayer: function _moveChipToPlayer(player, createPosition, money) {
        var chip, playerParent, chipComponent;
        this.audioManager.playChipBay();
        for (var i = 0; i < 3; i += 1) {

            if (Utils.Type.isString(player)) {
                playerParent = this.findPlayerNodeByName(player);
                if (playerParent) {
                    playerParent = playerParent.node;
                }
            } else {
                playerParent = player;
            }
            if (playerParent) {
                chip = cc.instantiate(this.chipPrefab);
                chip.parent = playerParent.parent;
                chip.position = createPosition;
                chipComponent = chip.getComponent('Chip');
                chipComponent.activeSelectChip(false);
                chipComponent.moneyLabel.node.active = false;
                chip.removeComponent('ButtonScaler');
                chip.removeComponent(cc.Button);
                chip.scale = cc.v2(0.5, 0.5);
                chipComponent.init(money);
                var action = cc.moveTo(0.8, cc.v2(playerParent.x, playerParent.y)).easing(cc.easeOut(2.0));
                chip.runAction(cc.sequence(cc.delayTime(i - i * 0.95), action, cc.callFunc(function () {
                    this.destroy();
                }, chip)));
            }
        }
    },

    _showMoneyFinish: function _showMoneyFinish(params) {
        for (var i = 0; i < params.length; i += 1) {
            var player = this.findPlayerNodeByName(params[i].userName);
            if (player) {
                player.setFinishEffect(params[i].moneyExchange);
                if (params[i].userName === AuthUser.username) {
                    if (params[i].moneyExchange > 0) {
                        this.audioManager.playWin();
                    } else {
                        this.audioManager.playLose();
                    }
                }
            }
        }
    },

    _showBankerMoneyFinish: function _showBankerMoneyFinish(params) {
        if (params.userName !== undefined) {
            var banker = this.findPlayerNodeByName(params.userName);
            if (banker) {
                banker.setFinishEffect(params.moneyExchange);
            }
        }
    },

    _clearEfectFinish: function _clearEfectFinish() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].clearEffects();
        }
    },

    _showPotWin: function _showPotWin(lstPot, isShow) {
        if (isShow) {
            for (var i = 0; i < lstPot.length; i += 1) {
                var pot = this.potInfor[lstPot[i]].getComponent('RoulettePotInfor');
                pot.activeEfectWin(true);
                pot.isWin = true;
            }
        } else {
            for (var j = 0; j < this.potInfor.length; j += 1) {
                var pot1 = this.potInfor[j].getComponent('RoulettePotInfor');
                pot1.activeEfectWin(false);
            }
        }
    },

    stopVienBi: function stopVienBi() {
        this.vienBi.parent.stopAllActions();
        this.vienBi.parent = this.resultList[this.result].node;
        // var action = cc.moveTo(0, cc.v2(0, 0)).easing(cc.easeOut(2.0));
        // this.vienBi.runAction(action);
        // this.vienBi.position = cc.v2(0, 0);
        this.resultLabel.string = this.result;
        this.vienBi.position = cc.p(0, 0);
        this.audioManager.stopEffect(this.ballRunAudioId);
    },

    _rotateVongQuay: function _rotateVongQuay(params) {
        //{result: 20, gameState: 1, action: 5, command: 20, time: 15000}
        // this.resultList[0].active = true;
        this.result = params.result;

        if (this.resultList[params.result].node) {
            this.resultList[params.result].node.active = true;
            this._disableAllButton();
            var tmpTime = Date.now() + params.time;
            var time = Math.floor((tmpTime - Date.now()) / 1000);
            if (time > 6) {
                this._openVongQuay(true, time - 2);
            }
        }
    },

    _disableColiderResult: function _disableColiderResult() {
        for (var i = 0; i < this.resultList.length; i += 1) {
            if (this.resultList[i].node) {
                this.resultList[i].node.active = false;
            }
        }
    },

    _openVongQuay: function _openVongQuay(isOpen, time) {
        var self = this;

        function rotateVongQuay(time) {
            var actionVongQuay = cc.rotateBy(time, -1500).easing(cc.easeOut(3));
            self.vongQuay.runAction(actionVongQuay);
            // var vongQuayAnim = self.vongQuay.getComponent(cc.Animation);
            // vongQuayAnim.play('Rotate');
            var actionVienBi1 = cc.moveBy(5, cc.p(-90, 0));
            self.vienBi.runAction(actionVienBi1);
            var actionVienBi = [];
            actionVienBi.push(cc.rotateBy(10, 4000).easing(cc.easeOut(2.5)));
            var actionRotateVienBi = cc.spawn(actionVienBi);
            self.vienBi.parent.runAction(actionRotateVienBi);
        }

        if (isOpen) {
            self.ballRunAudioId = this.audioManager.playBallRun();
            self.resultLabel.string = '';
            var actions = [];
            actions.push(cc.moveTo(1, cc.p(0, 0)));
            actions.push(cc.callFunc(rotateVongQuay(time)));
            actions.push(cc.delayTime(time));
            actions.push(cc.callFunc(function () {
                self._openVongQuay(false);
            }));
            var action = cc.sequence(actions);
            self.parentVongQuay.runAction(action);
        } else {
            var actionClosed = [];
            actionClosed.push(cc.moveTo(1, cc.v2(0, 1000)));
            actionClosed.push(cc.delayTime(2));
            actionClosed.push(cc.callFunc(function () {
                self.vienBi.parent = self.parentVienBi;
                self.vienBi.position = cc.p(215, 0);
            }));
            self._disableColiderResult();
            var actionClose = cc.sequence(actionClosed);
            self.parentVongQuay.runAction(actionClose);
        }
    },

    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 3, username: "phamvanthien25554"}
        if (params.username === AuthUser.username) {
            this.myTotallMoneyBet += params.money;
            this.lblTongDat.string = Utils.Number.format(this.myTotallMoneyBet);
        }
        var chip,
            playerParent = this.findPlayerNodeByName(params.username),
            chipComponent,
            potComponent,
            isInit = false,
            myMoney = 0;
        chip = cc.instantiate(this.chipPrefab);
        if (playerParent) {
            chip.parent = playerParent.node.parent;
            chip.position = playerParent.node;
        }
        chipComponent = chip.getComponent('Chip');
        chipComponent.activeSelectChip(false);
        // chipComponent.moneyLabel.node.active = false;
        chip.scale = cc.v2(0.5, 0.5);
        for (var i = 0; i < this.gameManager.bettingList.length; i++) {
            if (this.gameManager.bettingList[i] == params.money) {
                chipComponent.init(params.money, RouletteConstant.ChipColor.findById(i).NAME);
                isInit = true;
                break;
            }
        }
        if (!isInit) {
            chipComponent.moneyLabel.node.active = false;
            chipComponent.init(params.money);
        }
        chipComponent = chip.getComponent(cc.Button);
        chipComponent.enabled = false;
        chip.removeComponent('ButtonScaler');
        potComponent = this.potInfor[params.pot].getComponent('RoulettePotInfor');
        potComponent.init();
        if (params.username === AuthUser.username) {
            myMoney = params.money;
            this.btnX2.interactable = true;
            this.btnCancelBet.interactable = true;
        }
        potComponent.setMoneyPot(myMoney, params.money);
        potComponent.addPlayerBetToPot(params.username, params.money);
        var moveChip = cc.moveTo(0.5, cc.v2(this.potInfor[params.pot].x, this.potInfor[params.pot].y)).easing(cc.easeOut(2.0));
        chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
            this.destroy();
        }, chip)));
        this.audioManager.playChipBay();
    },

    _setOnClickPot: function _setOnClickPot() {
        var self = this,
            tmpPot;
        for (var i = 0; i < self.potInfor.length; i += 1) {
            tmpPot = self.potInfor[i];
            tmpPot.on(cc.Node.EventType.TOUCH_START, function (event) {
                self._selectPot(event.target);
            }, tmpPot);
        }
    },

    _selectPot: function _selectPot(pot) {
        // var potComponent = pot.getComponent('RoulettePotInfor');
        if (this.gameManager.lstRatio[parseInt(pot.name)]) {
            this.gameManager.sendBet(parseInt(pot.name), this.moneyBetSelect);
            this.lblCuaDat.string = pot.name;
            this.lblTyLe.string = this.gameManager.lstRatio[parseInt(pot.name)];
        } else {
            this.gameManager.sendBet(parseInt(pot.parent.parent.name), this.moneyBetSelect);
            this.lblCuaDat.string = pot.parent.parent.name;
            this.lblTyLe.string = this.gameManager.lstRatio[parseInt(pot.parent.parent.name)];
        }
    },

    _addChipBetting: function _addChipBetting(params) {
        var chipSelect,
            self = this,
            chipComponent;
        this.parentChipBetting.removeAllChildren();
        for (var i = 0; i < params.length; i += 1) {
            chipSelect = cc.instantiate(this.chipPrefab);
            this.listChipBetting.push(chipSelect);
            chipComponent = chipSelect.getComponent('Chip');
            chipComponent.init(params[i], RouletteConstant.ChipColor.findById(i).NAME);
            chipSelect.on(cc.Node.EventType.TOUCH_START, function () {
                this.activeSelectChip(true);
                self._selectChip(this.node);
            }, chipComponent);
            this.parentChipBetting.addChild(chipSelect);
        }
        this._selectChip(this.listChipBetting[0]);
    },

    _removeSelectChip: function _removeSelectChip() {
        for (var i = 0; i < this.listChipBetting.length; i += 1) {
            var chip = this.listChipBetting[i].getComponent('Chip');
            chip.activeSelectChip(false);
        }
    },

    _selectChip: function _selectChip(chipSelect) {
        this._removeSelectChip();
        var chip = chipSelect.getComponent('Chip');
        chip.activeSelectChip(true);
        this.moneyBetSelect = chip.money;
    },

    clickReBet: function clickReBet() {
        this.gameManager.sendReBet();
    },

    clickDoubleBet: function clickDoubleBet() {
        this.gameManager.sendDoubleBet();
    },

    clickCancelBet: function clickCancelBet() {
        this.gameManager.sendCancelBet();
    },

    clickRequestBanker: function clickRequestBanker() {
        this.gameManager.sendRequestBanker();
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","GameConstant":"GameConstant","RouletteConstant":"RouletteConstant","Utils":"Utils"}],"GameplaySam":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8600bcCVRBEGLu5TXHWoSM6', 'GameplaySam');
// scripts\components\games\sam\GameplaySam.js

var GameConstant = require('GameConstant'),
    SamConstant = require('SamConstant'),
    AuthUser = require('AuthUser'),
    GameplayTLMN = require('GameplayTLMN');
cc.Class({
    'extends': GameplayTLMN,

    properties: {
        gameCmd: {
            'default': GameConstant.SAM.CMD,
            visible: false,
            override: true
        },
        baoSamButton: cc.Button,
        boQuaBaoSamButton: cc.Button
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        GameplayTLMN.prototype.$onLoad.call(this);
        this.MAX_NUMBER_CARDS = 10;
        this.gameManager.eventDispatchers.local.addEventListener(SamConstant.Event.WAITING_BAO_SAM, this.onWaitBaoSam, this);
        this.gameManager.eventDispatchers.local.addEventListener(SamConstant.Event.PLAYER_BAO_SAM, this.onPlayerBaoSam, this);
        this.gameManager.eventDispatchers.local.addEventListener(SamConstant.Event.PLAYER_BAO_MOT, this.onPlayerBaoMot, this);
        this.gameManager.eventDispatchers.local.addEventListener(SamConstant.Event.PLAYER_HUY_BAO_SAM, this.onPlayerHuyBaoSam, this);
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================

    onButtonBaoSamClick: function onButtonBaoSamClick() {
        this.gameManager.sendRequestBaoSam();
        this.audioManager.playButtonClick();
    },

    onButtonBoQuaBaoSamClick: function onButtonBoQuaBaoSamClick() {
        this.gameManager.sendRequestBoQuaBaoSam();
        this.audioManager.playButtonClick();
    },

    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onWaitBaoSam: function onWaitBaoSam(params) {
        this.count += 1;
        this.gameStateLabel.string = 'Thời gian báo Sâm!';
        this.gameStateLabel.node.active = true;
        this.startButton.node.active = false;
        var dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.countDownTime = Date.now() + params.allData.time - dt;
        this.countDownTimeLabel.string = Math.floor(params.allData.time / 1000);
        this.countDownTimeLabel.node.active = true;
        if (this.curPlayerUI().getComponent('PlayerUITLMN').player.data.handSize > 0) {
            this.baoSamButton.node.active = true;
            this.boQuaBaoSamButton.node.active = true;
            this.baoSamButton.node.setScale(1);
            this.boQuaBaoSamButton.node.setScale(1);
        }
    },

    onPlayerBaoSam: function onPlayerBaoSam(userName) {
        var player = this.findPlayerNodeByName(userName);
        if (player) {
            player.getComponent('PlayerUITLMN').addEffect(SamConstant.Effect.BAO_SAM);
        }
    },

    onPlayerHuyBaoSam: function onPlayerHuyBaoSam() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            var child = this.playerNodeList[i].getComponent('PlayerUITLMN');
            if (!child.player) {
                continue;
            }
            if (child.player.data.isHuyBaoSam) {
                child.addEffect(SamConstant.Effect.HUY_BAO_SAM);
                if (i === 0) {
                    this.baoSamButton.node.active = false;
                    this.boQuaBaoSamButton.node.active = false;
                }
            }
        }
    },

    onPlayerBaoMot: function onPlayerBaoMot(userName) {
        var player = this.findPlayerNodeByName(userName);
        if (player) {
            player.getComponent('PlayerUITLMN').addEffect(SamConstant.Effect.BAO, true);
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        if (params.allData.gameState === SamConstant.GameState.WAITING_FOR_PLAYER) {
            this.gameStateLabel.string = 'Đợi người chơi khác';
        }
    },

    onTurn: function onTurn(params) {
        this.gameStateLabel.node.active = false;
        this.countDownTimeLabel.node.active = false;
        this.baoSamButton.node.active = false;
        this.boQuaBaoSamButton.node.active = false;
        GameplayTLMN.prototype.onTurn.call(this, params);
    },

    // ============================================================
    // Other
    // ============================================================
    checkDenLang: function checkDenLang(params, playerResult, playerUITLMN) {
        switch (params.data.finishTypeId) {
            case SamConstant.ActionFinishType.SAM_THAT_BAI:
                if (params.data.loser === playerResult.userName) {
                    playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[SamConstant.Effect.SAM_THAT_BAI]);
                }
                break;
            case SamConstant.ActionFinishType.SAM_THANH_CONG:
                if (params.data.winner === playerResult.userName) {
                    playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[SamConstant.Effect.SAM_THANH_CONG]);
                    if (playerResult.userName === AuthUser.username) {
                        this.audioManager.playThangTrang();
                    }
                }
                break;
            case SamConstant.ActionFinishType.DEN_LANG_THOI_HAI:
                if (params.data.loser === playerResult.userName) {
                    playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[SamConstant.Effect.DEN_LANG]);
                }
                break;
        }
        var actions = params.data.result.actions;
        if (actions) {
            for (var k = 0; k < actions.length; k += 1) {
                if (actions[k].isCong && actions[k].sourcePlayer === playerResult.userName) {
                    playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[SamConstant.Effect.THUA_CONG]);
                }
            }
        }
        // kiem tra den bao
        if (params.data.denBaoPlayer) {
            if (params.data.result.summary.length > 2) {
                if (params.data.denBaoPlayer === playerResult.userName) {
                    playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[SamConstant.Effect.DEN_TRANG]);
                }
            }
        }
    },

    showPlayerWin: function showPlayerWin(params) {
        for (var i = 0; i < params.data.result.summary.length; i += 1) {
            var summary = params.data.result.summary[i];
            var playerUI = this.findPlayerNodeByName(summary.userName);
            if (playerUI) {
                if (playerUI.player.data.state !== SamConstant.PlayerState.WAITING) {
                    playerUI.clearEffects();
                    playerUI.setFinishEffect(summary.moneyExchange);
                }
            }
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","GameConstant":"GameConstant","GameplayTLMN":"GameplayTLMN","SamConstant":"SamConstant"}],"GameplaySanThuong":[function(require,module,exports){
"use strict";
cc._RFpush(module, '82ee2m8ZKJOfosLpqtGopaM', 'GameplaySanThuong');
// scripts\components\games\san_thuong\GameplaySanThuong.js

var GameConstant = require('GameConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    CommonConstant = require('CommonConstant'),
    BaseMainGameplay = require('BaseMainGameplay'),
    RowInforSanThuong = require('RowInforSanThuong'),
    GameManagerConstant = require('GameManagerConstant'),
    UiManager = require('UiManager'),
    DropDown = require('DropDown'),
    RulePotSanThuong = require('RulePotSanThuong'),
    SanThuongConstant = require('SanThuongConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        potInfor: {
            'default': [],
            type: cc.Node
        },

        rowInfor: {
            'default': [],
            type: RowInforSanThuong
        },
        rulePotSanThuongList: {
            'default': [],
            type: RulePotSanThuong
        },
        parentChipBetting: cc.Node,
        chipPrefab: cc.Prefab,
        lineResult: {
            'default': [],
            type: cc.Node
        },
        moneyLableTemp: cc.Label,
        btnXu: cc.Node,
        btnPi: cc.Node,
        moneyResultLabel: cc.Label,
        totalMoneyBetLabel: cc.Label,
        moneyGaLabel: cc.Label,
        btnQuay: cc.Button,
        btnTuQuay: cc.Button,
        parentHop: cc.Node,
        hopPrefab: cc.Prefab,
        panelDapHop: cc.Node,
        countOpenHopQuaLabel: cc.Label,
        itemMaDuThuongPrefab: cc.Prefab,
        contentMaDuThuong: cc.Node,
        panelMaDuThuong: cc.Node,
        countMaDuThuongLabel: cc.Label,
        resultKetQuaXoSoLabel: cc.Label,
        nameShowMaDuThuong: cc.Label,
        dateDropdow: DropDown,
        xuSprite: cc.SpriteFrame,
        piSprite: cc.SpriteFrame,
        numberFree: cc.Node,
        historyTablePrefab: cc.Prefab,
        btnHistory: cc.Button,
        gameCmd: {
            'default': GameConstant.SAN_THUONG.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.listChipBetting = [];
        this.listHopQua = [];
        this.moneyBetSelect = 0;
        this.currencySelect = 'IP';
        this.isDoneFinish = true;
        this.isDoneEfect = true;
        this.autoPlay = false;
        this.countFreePlay = 0;
        this.countOpenHopQua = 0;
        this.countLottery = 0;
        this.listMaDuThuong = [];
        this.currencyMa = 'IP';
        this.SanThuongAudioId = 0;

        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.ADD_LIST_BETTING, this._addChipBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.TURN_START, this.onStartGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.FINISH, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.CLEAR_FINISH, this.onWaitStartGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.UPDATE_CHICKEN_JAR, this.onUpdateChickenJar, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.SHOW_PANEL_DAPHOP, this.openPanelDapHop, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.OPEN_HOP, this.openHop, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.SET_RULE, this.onSetRule, this);
        this.gameManager.eventDispatchers.local.addEventListener(SanThuongConstant.Event.CHICKEN_CODE, this.onOpenMaDuThuong, this);

        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.UPDATE_USER_MONEY, this._updateMoney, this);

        this.cleaseLineFinish();
        this.btnPi.opacity = 255;
        this.btnXu.opacity = 90;
        this._updateMoney();
        this.gameManager.sendGetChickenJar();
        this._setOnClickPot();
    },

    $onFocus: function $onFocus() {

        if (this.gameManager.gameState !== SanThuongConstant.GameState.NONE) {
            this.panelMaDuThuong.active = false;
            this.countOpenHopQua = 0;
            // this.bow.position = cc.v2(0, 0);
            // for (var i = 0; i < this.slotInfor.length; i += 1) {
            //     var potComponent = this.slotInfor[i].getComponent('SlotInfor');
            //     potComponent.showEfectWin(false);
            // }
        }
        if (this.gameManager.gameState !== SanThuongConstant.GameState.FINISH) {
            // this.bow.position = cc.v2(0, 0);
            // for (var i = 0; i < this.slotInfor.length; i += 1) {
            //     var potComponent = this.slotInfor[i].getComponent('SlotInfor');
            //     potComponent.showEfectWin(false);
            // }
        }
        if (this.gameManager.gameState !== SanThuongConstant.GameState.OPEN_HOP) {
            this.panelMaDuThuong.active = false;
            // this.onClickQuay();
            // var anim = this.bowDice.getComponent(cc.Animation);
            // anim.stop('shake');
        }
        if (this.gameManager.gameState === SanThuongConstant.GameState.EFFECT) {
            this.isDoneEfect = true;
            // this.bowDice.position = cc.v2(0, 0);
        }
    },

    onOpenMaDuThuong: function onOpenMaDuThuong(params) {
        var index = 0,
            self = this;
        this.panelMaDuThuong.active = true;
        this.nameShowMaDuThuong.string = AuthUser.username;
        this.listMaDuThuong = params;
        this.dateDropdow.clearAllItems();
        Object.keys(params).sort().reverse().forEach(function (maDuThuong) {
            self.dateDropdow.addItem(maDuThuong, index > 0 ? false : true);
            index += 1;
        });
        this.updateMaDuThuong();
    },

    updateMaDuThuong: function updateMaDuThuong() {
        var currentMa = this.dateDropdow.getSelectedItem(),
            itemMaDuThuong;
        if (this.listMaDuThuong[currentMa].result) {
            this.resultKetQuaXoSoLabel.string = 'Kết quả sổ xố: ' + this.listMaDuThuong[currentMa].result;
        } else {
            this.resultKetQuaXoSoLabel.string = 'Kết quả sổ xố:';
        }
        if (this.listMaDuThuong[currentMa].codes[this.currencyMa]) {
            this.countMaDuThuongLabel.string = 'SỐ LƯỢNG MÃ: ' + this.listMaDuThuong[currentMa].codes[this.currencyMa].length;
        } else {
            this.countMaDuThuongLabel.string = 'SỐ LƯỢNG MÃ: 0';
        }
        this.contentMaDuThuong.removeAllChildren();
        for (var i = 0; i < this.listMaDuThuong[currentMa].codes[this.currencyMa].length; i += 1) {
            itemMaDuThuong = cc.instantiate(this.itemMaDuThuongPrefab);
            itemMaDuThuong.getChildByName('LblIndex').getComponent(cc.Label).string = i + 1;
            itemMaDuThuong.getChildByName('LblMa').getComponent(cc.Label).string = this.listMaDuThuong[currentMa].codes[this.currencyMa][i];
            this.contentMaDuThuong.addChild(itemMaDuThuong);
        }
    },

    _setOnClickPot: function _setOnClickPot() {
        var self = this,
            tmpPot;
        for (var i = 0; i < self.potInfor.length; i += 1) {
            tmpPot = self.potInfor[i];
            tmpPot.on(cc.Node.EventType.TOUCH_START, function (event) {
                self._selectPot(event.target);
            }, tmpPot);
        }
    },

    _selectPot: function _selectPot(pot) {
        if (this.isDoneFinish && this.isDoneEfect) {
            var potComponent = pot.getComponent('PotInforSanThuong');
            potComponent.clickPot();
            this._showTotalMoneyBet();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi cửa đặt.');
        }
    },

    onSetRule: function onSetRule(params) {
        for (var i = 0; i < params.length; i += 1) {
            this.rulePotSanThuongList[params[i].id - 1].setRatio(params[i]);
        }
    },
    _updateMoney: function _updateMoney() {
        this.btnPi.getComponentInChildren(cc.Label).string = Utils.Number.format(AuthUser.currencies[CommonConstant.CurrencyType.Ip.NAME].balance);
        this.btnXu.getComponentInChildren(cc.Label).string = Utils.Number.format(AuthUser.currencies[CommonConstant.CurrencyType.Xu.NAME].balance);
    },

    openHop: function openHop(params) {
        var hopQuaComponent,
            self = this,
            animation;
        for (var i = 0; i < params.results.length; i += 1) {
            hopQuaComponent = this.listHopQua[params.results[i].id].getComponent('HopquaInfor');
            animation = this.listHopQua[params.results[i].id].getComponent(cc.Animation);
            animation.stop('hopQuaEfect');
            this.countOpenHopQua -= 1;
            if (this.countOpenHopQua <= 0) {
                var actions = cc.sequence(cc.delayTime(2), cc.callFunc(function () {
                    self.panelDapHop.active = false;
                }), cc.delayTime(1), cc.callFunc(function () {
                    self._checkDoneFinish();
                }));
                self.node.runAction(actions);
            }
            if (this.countOpenHopQua >= 0) {
                this.countOpenHopQuaLabel.string = 'Bạn còn ' + this.countOpenHopQua + ' lần mở hộp quà';
            }
            switch (params.results[i].awardType) {
                case SanThuongConstant.AwardType.NONE:
                    hopQuaComponent.openHopQua('Chúc may mắn lần sau');
                    break;
                case SanThuongConstant.AwardType.MONEY:
                    hopQuaComponent.openHopQua('Bạn nhận được ' + params.results[i].ratio + ' lần tiền cược');
                    break;
                case SanThuongConstant.AwardType.FREE_PLAY:
                    hopQuaComponent.openHopQua('Bạn nhận được ' + params.results[i].ratio + ' lượt quay miễn phí');
                    self.countFreePlay += params.results[i].ratio;
                    break;
                case SanThuongConstant.AwardType.MA_DU_THUONG:
                    hopQuaComponent.openHopQua('Bạn nhận được ' + params.results[i].ratio + ' mã dự thưởng');
                    break;

            }
        }
    },

    openPanelDapHop: function openPanelDapHop() {
        if (this.countOpenHopQua >= 0) {
            this.panelDapHop.active = true;
            this.countOpenHopQuaLabel.string = 'Bạn còn ' + this.countOpenHopQua + ' lần mở hộp quà';
            this.createHopQua(24);
        }
    },

    createHopQua: function createHopQua(count) {
        this.parentHop.removeAllChildren();
        this.listHopQua = [];
        var self = this,
            hopQua,
            animation,
            hopQuaComponent;
        for (var i = 0; i < count; i += 1) {
            hopQua = cc.instantiate(this.hopPrefab);
            self.listHopQua.push(hopQua);
            hopQuaComponent = hopQua.getComponent('HopquaInfor');
            animation = hopQua.getComponent(cc.Animation);
            hopQuaComponent.init(i);
            hopQua.on(cc.Node.EventType.TOUCH_START, function () {
                self._selectHopQua(this.node);
            }, hopQuaComponent);
            this.parentHop.addChild(hopQua);
            animation.play('hopQuaEfect');
        }
    },

    _selectHopQua: function _selectHopQua(hopQua) {
        var hopQuaComponent = hopQua.getComponent('HopquaInfor');
        this.gameManager.sendOpentHop(hopQuaComponent.id);
    },

    onWaitStartGame: function onWaitStartGame() {
        this.cleaseLineFinish();
        this.isDoneFinish = true;
        if (!Utils.Game.isFocus() && this.autoPlay) {
            this.isDoneEfect = true;
            this.onClickQuay();
        } else {
            this._checkDoneFinish();
        }
    },

    _checkDoneFinish: function _checkDoneFinish() {
        while (this.isDoneEfect && this.isDoneFinish) {
            // if (this.isDoneEfect && this.isDoneFinish) {
            if (this.autoPlay) {
                if (this.countOpenHopQua <= 0 && !this.panelDapHop.active) {
                    this.onClickQuay();
                }
            } else {
                this._checkActiveButton();
            }
            // }
            break;
        }
    },

    onUpdateChickenJar: function onUpdateChickenJar() {
        if (this.currencySelect === 'IP') {
            this.moneyGaLabel.string = Utils.Number.format(this.gameManager.moneyChickenPi);
        } else {
            this.moneyGaLabel.string = Utils.Number.format(this.gameManager.moneyChickenXu);
        }
        this._showTotalMoneyBet();
    },

    _checkActiveButton: function _checkActiveButton() {
        if (this.isDoneFinish && this.isDoneEfect) {
            if (this.autoPlay) {
                this.btnQuay.getComponent(cc.Button).interactable = false;
            } else {
                this.btnQuay.getComponent(cc.Button).interactable = true;
            }
        } else {
            this.btnQuay.getComponent(cc.Button).interactable = false;
        }
    },

    onFinishGame: function onFinishGame(params) {
        if (Utils.Game.isFocus()) {
            this._showLineFinish(params.awards);
            this.moneyResultLabel.string = Utils.Number.format(params.player.moneyExchange);
            this._updateMoney();
        }
        this.btnHistory.node.active = true;
    },
    _showLineFinish: function _showLineFinish(params) {
        var self = this;
        this.audioManager.stopEffect(this.SanThuongAudioId);

        function doneFinish() {
            return function () {
                self.isDoneEfect = true;
                self._checkDoneFinish();
            };
        }

        function showPotWrapper(pot, ratio, awardType, isShow) {
            return function () {
                if (isShow) {
                    self.lineResult[pot - 1].active = true;
                    self._calculateTypeAward(ratio, awardType);
                    self._showGemFinishLine(pot);
                    self.audioManager.playChickenRow();
                } else {
                    self.lineResult[pot - 1].active = false;
                }
            };
        }

        var actions = [];
        if (params.length > 0) {
            for (var i = 0; i < params.length; i += 1) {
                actions.push(cc.delayTime(1));
                actions.push(cc.callFunc(showPotWrapper(params[i].pot, params[i].ratio, params[i].awardType, true)));
                actions.push(cc.delayTime(1));
                actions.push(cc.callFunc(showPotWrapper(params[i].pot, params[i].ratio, params[i].awardType, false)));
                if (i === params.length - 1) {
                    actions.push(cc.delayTime(2));
                    actions.push(cc.callFunc(doneFinish()));
                }
            }
        } else {
            actions.push(cc.callFunc(doneFinish()));
        }
        var action = cc.sequence(actions);
        if (action) {
            self.node.runAction(action);
        }
    },

    _calculateTypeAward: function _calculateTypeAward(ratio, awardType) {
        var self = this;
        switch (awardType) {
            // case SanThuongConstant.AwardType.NONE:
            //     self._showTextAwardType();
            //     break;
            case SanThuongConstant.AwardType.MONEY:
                self._showTextAwardType(self.moneyBetSelect * ratio);
                break;
            case SanThuongConstant.AwardType.FREE_PLAY:
                self._showTextAwardType(ratio + ' lần quay miễn phí');
                self.countFreePlay += ratio;
                self.numberFree.active = true;
                self.numberFree.getComponentInChildren(cc.Label).string = self.countFreePlay;
                break;
            case SanThuongConstant.AwardType.HOPQUA:
                self._showTextAwardType(ratio + ' hộp quà');
                self.countOpenHopQua += ratio;
                break;
            case SanThuongConstant.AwardType.MA_DU_THUONG:
                self._showTextAwardType(ratio + ' mã dự thưởng');
                self.countLottery += ratio;
                break;

        }
    },

    _showTextAwardType: function _showTextAwardType(value) {
        var self = this;

        function ShowHideLabelMoney(money, isShow) {
            return function () {
                if (Utils.Type.isNumber(value)) {
                    self.moneyLableTemp.string = Utils.Number.format(value);
                } else {
                    self.moneyLableTemp.string = value;
                }
                self.moneyLableTemp.node.active = isShow;
                var animation = self.moneyLableTemp.node.getComponent(cc.Animation);
                if (isShow) {
                    animation.play('MoveMoneyReceive');
                } else {
                    animation.stop('MoveMoneyReceive');
                }
            };
        }
        var actions = [];
        actions.push(cc.callFunc(ShowHideLabelMoney(value, true)));
        actions.push(cc.delayTime(1));
        actions.push(cc.callFunc(ShowHideLabelMoney(0, false)));

        var action = cc.sequence(actions);
        self.node.runAction(action);
    },

    _showTotalMoneyBet: function _showTotalMoneyBet() {
        this.totalMoneyBetLabel.string = Utils.Number.format(this.moneyBetSelect * this._getPotSelect().length);
        if (this._getPotSelect().length > 0) {
            if (this.isDoneFinish && this.isDoneEfect) {
                this.btnQuay.getComponent(cc.Button).interactable = true;
                this.btnTuQuay.getComponent(cc.Button).interactable = true;
            }
        } else {
            this.btnQuay.getComponent(cc.Button).interactable = false;
            this.btnTuQuay.getComponent(cc.Button).interactable = false;
        }
    },

    cleaseLineFinish: function cleaseLineFinish() {
        for (var i = 0; i < this.lineResult.length; i += 1) {
            this.lineResult[i].active = false;
        }
        this.moneyResultLabel.string = 0;
    },

    _showGemFinishLine: function _showGemFinishLine(pot) {
        var arrGem = [];
        switch (pot) {
            case 1:
                arrGem = [1, 1, 1, 1, 1];
                break;
            case 2:
                arrGem = [2, 2, 2, 2, 2];
                break;
            case 3:
                arrGem = [0, 0, 0, 0, 0];
                break;
            case 4:
                arrGem = [1, 1, 2, 1, 1];
                break;
            case 5:
                arrGem = [1, 1, 0, 1, 1];
                break;
            case 6:
                arrGem = [2, 2, 1, 2, 2];
                break;
            case 7:
                arrGem = [0, 0, 1, 0, 0];
                break;
            case 8:
                arrGem = [2, 0, 2, 0, 2];
                break;
            case 9:
                arrGem = [0, 2, 0, 2, 0];
                break;
            case 10:
                arrGem = [1, 2, 0, 2, 1];
                break;
            case 11:
                arrGem = [0, 1, 2, 1, 0];
                break;
            case 12:
                arrGem = [2, 1, 0, 1, 2];
                break;
            case 13:
                arrGem = [1, 0, 1, 2, 1];
                break;
            case 14:
                arrGem = [1, 2, 1, 0, 1];
                break;
            case 15:
                arrGem = [0, 1, 1, 1, 0];
                break;
            case 16:
                arrGem = [2, 1, 1, 1, 2];
                break;
            case 17:
                arrGem = [1, 0, 0, 0, 1];
                break;
            case 18:
                arrGem = [1, 2, 2, 2, 1];
                break;
            case 19:
                arrGem = [0, 0, 1, 2, 2];
                break;
            case 20:
                arrGem = [2, 2, 1, 0, 0];
                break;
        }
        this._activeGem(arrGem);
    },

    _activeGem: function _activeGem(params) {
        var self = this;

        function showScale(gem, isShow) {
            return function () {
                if (gem && gem.name !== '') {
                    var efect = gem.getChildByName('ImgTrung');
                    if (isShow) {
                        if (efect) {
                            efect.active = true;
                            gem.getComponent(cc.Animation).play();
                        }
                    } else {
                        if (efect) {
                            gem.getChildByName('ImgTrung').active = false;
                            gem.getComponent(cc.Animation).stop();
                        }
                    }
                }
            };
        }
        for (var i = 0; i < this.rowInfor.length; i += 1) {
            var gem = this.rowInfor[i].gemTemp[params[i]];
            if (gem) {
                var action = cc.sequence(cc.callFunc(showScale(gem, true)), cc.delayTime(1), cc.callFunc(showScale(gem, false)));
                self.node.runAction(action);
            }
        }
    },

    onStartGame: function onStartGame(params) {
        if (Utils.Game.isFocus()) {
            var self = this;
            self.node.stopAllActions();
            this.cleaseLineFinish();

            self.isDoneFinish = false;
            self.isDoneEfect = false;
            self._checkActiveButton();
            self.panelDapHop.active = false;
            self.countOpenHopQua = 0;
            if (self.countFreePlay > 1) {
                self.countFreePlay -= 1;
                self.numberFree.active = true;
                self.numberFree.getComponentInChildren(cc.Label).string = self.countFreePlay;
            } else {
                self.numberFree.active = false;
            }
            var action = cc.sequence(cc.callFunc(function () {
                self._removeGemFinish();
            }), cc.delayTime(0.05), cc.callFunc(function () {
                self._addChipFinish(params);
            }), cc.delayTime(0.1), cc.callFunc(function () {
                for (var i = 0; i < self.rowInfor.length; i += 1) {
                    self.rowInfor[i].node.y = -160;
                    var action = cc.sequence(cc.moveTo(3 - i * 0.4, cc.v2(self.rowInfor[i].node.x, -(self.rowInfor[i].node.height - 160)))).easing(cc.easeOut(2.0));
                    self.rowInfor[i].node.runAction(action);
                }
            }));
            action.easing(cc.easeQuadraticActionOut());
            this.node.runAction(action);
            this._updateMoney();
            this.SanThuongAudioId = this.audioManager.playVongQuay();
        }
    },

    _addChipFinish: function _addChipFinish(params) {
        var chips = params;
        chips.reverse();
        for (var i = 0; i < chips.length; i += 1) {
            switch (i) {
                case 0:
                case 5:
                case 10:
                    this._initGemFinish(4, params[i]);
                    break;
                case 1:
                case 6:
                case 11:
                    this._initGemFinish(3, params[i]);
                    break;
                case 2:
                case 7:
                case 12:
                    this._initGemFinish(2, params[i]);
                    break;
                case 3:
                case 8:
                case 13:
                    this._initGemFinish(1, params[i]);
                    break;
                case 4:
                case 9:
                case 14:
                    this._initGemFinish(0, params[i]);
                    break;

            }
        }
    },

    _initGemFinish: function _initGemFinish(rowIndex, value) {
        var row = this.rowInfor[rowIndex].getComponent('RowInforSanThuong');
        row.initGemFinish(value - 1);
    },

    _removeGemFinish: function _removeGemFinish() {
        for (var i = 0; i < this.rowInfor.length; i += 1) {
            this.rowInfor[i].destroyGemTemp();
        }
    },

    onClickDongLe: function onClickDongLe() {
        if (this.isDoneFinish && this.isDoneEfect) {
            this.onClickHuy();
            for (var i = 0; i < this.potInfor.length; i += 2) {
                var pot = this.potInfor[i].getComponent('PotInforSanThuong');
                pot.activePot(true);
            }
            this._showTotalMoneyBet();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi cửa đặt.');
        }
    },
    onClickDongChan: function onClickDongChan() {
        if (this.isDoneFinish && this.isDoneEfect) {
            this.onClickHuy();
            for (var i = 1; i < this.potInfor.length; i += 2) {
                var pot = this.potInfor[i].getComponent('PotInforSanThuong');
                pot.activePot(true);
            }
            this._showTotalMoneyBet();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi cửa đặt.');
        }
    },
    onClickTatCa: function onClickTatCa() {
        if (this.isDoneFinish && this.isDoneEfect) {
            for (var i = 0; i < this.potInfor.length; i += 1) {
                var pot = this.potInfor[i].getComponent('PotInforSanThuong');
                pot.activePot(true);
            }
            this._showTotalMoneyBet();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi cửa đặt.');
        }
    },
    onClickHuy: function onClickHuy() {
        if (this.isDoneFinish && this.isDoneEfect) {
            for (var i = 0; i < this.potInfor.length; i += 1) {
                var pot = this.potInfor[i].getComponent('PotInforSanThuong');
                pot.activePot(false);
            }
            this._showTotalMoneyBet();
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi cửa đặt.');
        }
    },

    onClickQuay: function onClickQuay() {
        if (this._getPotSelect().length > 0) {
            if (this.isDoneEfect && this.isDoneFinish) {
                this.gameManager.sendStartGame(this.autoPlay, this.moneyBetSelect, this._getPotSelect(), this.currencySelect);
            }
        } else {
            UiManager.openWarningMessage('Bạn phải chọn cửa đặt trước khi quay.');
        }
    },

    onClickTuQuay: function onClickTuQuay() {
        var nameButton = this.btnTuQuay.getComponentInChildren(cc.Label);
        if (!this.autoPlay) {
            nameButton.string = 'HỦY';
            this.autoPlay = true;
            if (this.isDoneEfect && this.isDoneFinish) {
                this.onClickQuay();
            }
        } else {
            nameButton.string = 'TỰ QUAY';
            this.autoPlay = false;
        }
    },

    onClickXu: function onClickXu() {
        if (this.isDoneFinish && this.isDoneEfect) {
            if (this.currencySelect === 'IP') {
                this.currencySelect = 'XU';
                this._addChipBetting(this.gameManager.lstXuBetting);
                this.btnPi.opacity = 150;
                this.btnXu.opacity = 255;
                this.onUpdateChickenJar();
                var nameButton = this.btnTuQuay.getComponentInChildren(cc.Label);
                nameButton.string = 'TỰ QUAY';
                this.autoPlay = false;
            }
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi loại tiền.');
        }
    },

    onClickPi: function onClickPi() {
        if (this.isDoneFinish && this.isDoneEfect) {
            if (this.currencySelect === 'XU') {
                this.currencySelect = 'IP';
                this._addChipBetting(this.gameManager.lstPiBetting);
                this.btnPi.opacity = 255;
                this.btnXu.opacity = 150;
                this.onUpdateChickenJar();
                var nameButton = this.btnTuQuay.getComponentInChildren(cc.Label);
                nameButton.string = 'TỰ QUAY';
                this.autoPlay = false;
            }
        } else {
            UiManager.openWarningMessage('Đang quay không thể thay đổi loại tiền.');
        }
    },

    onClickSwidthMaDuThuong: function onClickSwidthMaDuThuong(event) {
        if (this.currencyMa === 'IP') {
            event.target.getComponent(cc.Sprite).spriteFrame = this.xuSprite;
            this.currencyMa = 'XU';
        } else {
            event.target.getComponent(cc.Sprite).spriteFrame = this.piSprite;
            this.currencyMa = 'IP';
        }
        this.updateMaDuThuong();
    },

    onClickMaDuThuong: function onClickMaDuThuong() {
        this.gameManager.sendOpenPopupMaDuThuong();
        // this.onClickHistory();
    },

    onClickHistory: function onClickHistory() {
        var hisotryTable = cc.instantiate(this.historyTablePrefab);
        hisotryTable.getComponent('HistorySanThuong').init(this.gameManager.lstHistory.slice());
        cc.director.getScene().addChild(hisotryTable);
    },

    CloseMaDuThuong: function CloseMaDuThuong() {
        this.panelMaDuThuong.active = false;
    },

    _getPotSelect: function _getPotSelect() {
        var potActive = [];
        for (var i = 0; i < this.potInfor.length; i += 1) {
            var pot = this.potInfor[i].getComponent('PotInforSanThuong');
            if (pot.isActive) {
                potActive.push(i + 1);
            }
        }
        return potActive;
    },

    _addChipBetting: function _addChipBetting(params) {
        var chipSelect,
            indexColor = 0,
            index = 0,
            self = this,
            chipComponent;
        this.listChipBetting = [];
        this.parentChipBetting.removeAllChildren();
        for (var i = 0; i < params.length; i += 1) {
            chipSelect = cc.instantiate(this.chipPrefab);
            this.listChipBetting.push(chipSelect);
            chipComponent = chipSelect.getComponent('Chip');
            if (i < 12) {
                index = i;
            } else if (i >= 12 && i < 24) {
                index = index - 12;
            } else if (i >= 24 && i < 36) {
                index = index - 24;
            }

            if (index >= 3 && index < 6) {
                indexColor = 1;
            } else if (index >= 6 && index < 9) {
                indexColor = 2;
            } else if (index >= 9 && index < 12) {
                indexColor = 3;
            }
            chipComponent.init(params[i], SanThuongConstant.ChipColor.findById(indexColor).NAME);
            chipSelect.on(cc.Node.EventType.TOUCH_START, function () {
                self._selectChip(this.node);
            }, chipComponent);
            this.parentChipBetting.addChild(chipSelect);
        }
        this._selectChip(this.listChipBetting[0]);
    },

    _removeSelectChip: function _removeSelectChip() {
        for (var i = 0; i < this.listChipBetting.length; i += 1) {
            var chip = this.listChipBetting[i].getComponent('Chip');
            chip.activeSelectChip(false);
        }
    },

    _selectChip: function _selectChip(chipSelect) {
        if (this.isDoneFinish && this.isDoneEfect) {
            this._removeSelectChip();
            var chip = chipSelect.getComponent('Chip');
            chip.activeSelectChip(true);
            this.moneyBetSelect = chip.money;
            this._showTotalMoneyBet();
        } else {
            return UiManager.openWarningMessage('Đang quay không thể thay đổi mức cược.');
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","CommonConstant":"CommonConstant","DropDown":"DropDown","GameConstant":"GameConstant","GameManagerConstant":"GameManagerConstant","RowInforSanThuong":"RowInforSanThuong","RulePotSanThuong":"RulePotSanThuong","SanThuongConstant":"SanThuongConstant","UiManager":"UiManager","Utils":"Utils"}],"GameplayTLMN":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a799dMf8ZNO8pQfvJ1cFBH1', 'GameplayTLMN');
// scripts\components\games\tlmn\GameplayTLMN.js

var GameConstant = require('GameConstant'),
    TLMNConstant = require('TLMNConstant'),
    AuthUser = require('AuthUser'),
    BaseMainGameplay = require('BaseMainGameplay'),
    UiManager = require('UiManager'),
    Utils = require('Utils'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');
cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        countDownTimeLabel: cc.Label,
        gameStateLabel: cc.Label,
        startButton: cc.Button,
        boChonButton: cc.Button,
        boLuotButton: cc.Button,
        danhButton: cc.Button,
        portCardTrash: cc.Node,
        gameCmd: {
            'default': GameConstant.TLMN.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.FINISH_GAME, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.UPDATE_GAME, this.onUpdateGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.UPDATE_HAND, this.onUpdateHand, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.WAITING_DEAL_CARD, this.onWaitingDealCard, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.WAITING_FOR_PLAYER, this.onWaitingForPlayer, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.TURN, this.onTurn, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.DISCARD, this.onDiscard, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.REFRESH_GAME, this.onRefreshGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(TLMNConstant.Event.CHAT_HANG, this.onChatHang, this);

        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_INFO, this.onUpdateUserInfo, this);
        this.count = 0;
        this.MAX_NUMBER_CARDS = 13;
        if (!this.updatedGame) {
            this.setCurrentPlayerInTurn(false);
        }
        // var self = this;
        this.curPlayerUI().cardHold.on('check_chosen_card', this.showButtonBoChon, this);
    },

    // called every frame, uncomment this function to activate update callback
    $onUpdate: function $onUpdate() {
        if (this.gameManager) {
            if (this.gameManager.gameState === TLMNConstant.GameStateTLMN.WAITING_FOR_NEW_GAME || this.gameManager.gameState === TLMNConstant.GameState.BAO_SAM || this.gameManager.gameState === TLMNConstant.GameStateTLMN.FINISH || this.gameManager.gameState === TLMNConstant.GameStateTLMN.FINALIZING) {
                var count = Math.floor((this.countDownTime - Date.now()) / 1000);
                count = count >= 0 ? count : 0;
                this.countDownTimeLabel.string = count;
                if (count === 0) {
                    this.countDownTimeLabel.node.active = false;
                    this.gameStateLabel.node.active = false;
                    if (this.gameManager.gameState === TLMNConstant.GameStateTLMN.FINISH || this.gameManager.gameState === TLMNConstant.GameStateTLMN.FINALIZING) {
                        this.clearStateGame();
                        this.gameStateLabel.string = 'Ván mới sẽ được bắt đầu trong giây lát.';
                        this.gameStateLabel.node.active = true;
                        this.gameManager.gameState = TLMNConstant.GameStateTLMN.NONE;
                    } else {}
                }
            } else {
                this.startButton.node.active = false;
                this.countDownTimeLabel.node.active = false;
                this.gameStateLabel.node.active = false;
            }
        }
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================
    onButtonStartClick: function onButtonStartClick() {
        this.gameManager.sendRequestStartGame();
        this.audioManager.playButtonClick();
    },

    onButtonBoChonClick: function onButtonBoChonClick() {
        this.audioManager.playButtonClick();
        var cardDiscard = this.curPlayerUI().getCardTouched();
        for (var i = 0; i < cardDiscard.length; i += 1) {
            cardDiscard[i].onButtonTouch();
        }
    },

    onButtonBoLuotClick: function onButtonBoLuotClick() {
        var self = this;
        this.audioManager.playButtonClick();
        this.gameManager.sendRequestDiscard([]);
        this.addTimeout(TLMNConstant.TimeoutId.BOLUOT_ANIMATION, setTimeout(function () {
            var cardDiscard = self.curPlayerUI().getCardTouched();
            for (var i = 0; i < cardDiscard.length; i += 1) {
                cardDiscard[i].onButtonTouch();
            }
        }, 200));
    },

    onButtonDanhClick: function onButtonDanhClick() {
        this.audioManager.playButtonClick();
        if (this.curPlayerUI().player.data.state === TLMNConstant.PlayerState.IN_TURN) {
            var cardDiscard = this.curPlayerUI().getCardTouched();
            var cardIds = [];
            for (var i = 0; i < cardDiscard.length; i += 1) {
                cardIds.push(cardDiscard[i].card.getId());
            }
            if (cardIds.length === 0) {
                UiManager.openWarningMessage('Bạn cần chọn quân bài để đánh.', 1);
                return;
            }
            this.gameManager.sendRequestDiscard(cardIds);
        }
    },
    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onWaitingForPlayer: function onWaitingForPlayer() {
        this.gameStateLabel.string = 'Đợi người chơi khác';
    },

    onWaitingDealCard: function onWaitingDealCard(params) {
        var dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.count += 1;
        this.gameStateLabel.string = 'Ván bài sẽ bắt đầu sau :';
        this.gameStateLabel.node.active = true;
        this.countDownTime = Date.now() + params.allData.time - dt;
        this.countDownTimeLabel.string = Math.floor(params.allData.time / 1000);
        this.countDownTimeLabel.node.active = true;
        this.clearStateGame();

        if (!params) {
            return;
        }
        if (this.playerNodeList[0].player && this.playerNodeList[0].player.data.isMaster) {
            this.startButton.node.active = true;
            this.startButton.interactable = true;
        } else {
            this.startButton.node.active = false;
            this.startButton.interactable = false;
        }
    },

    onUpdateHand: function onUpdateHand(params) {
        this.gameStateLabel.node.active = false;
        this.countDownTimeLabel.node.active = false;
        this.startButton.interactable = false;
        this.startButton.node.active = false;
        this.clearTrashCards();
        this.audioManager.playBaiChia();
        var childView;
        for (var i = 0; i < params.players.length; i += 1) {
            if (params.players[i].username) {
                childView = this.findPlayerNodeByName(params.players[i].username);
            } else {
                childView = this.findPlayerNodeByName(params.players[i].userName);
            }
            if (childView) {
                if (childView === this.playerNodeList[0]) {
                    childView.getComponent('PlayerUITLMN').onUpdateHand(params.hand, params.players[i].handSize, false);
                } else {
                    childView.getComponent('PlayerUITLMN').onUpdateHand(null, params.players[i].handSize, false);
                }
            }
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        if (params.allData.gameState === TLMNConstant.GameStateTLMN.WAITING_FOR_PLAYER) {
            this.gameStateLabel.string = 'Đợi người chơi khác';
        }
    },

    onTurn: function onTurn(params) {
        var self = this;
        if (params.newTurn) {
            for (var j = 0; j < this.portCardTrash.childrenCount; j += 1) {
                var card = this.portCardTrash.children[j];
                card.stopAllActions();
                var chiaBaiAction = cc.sequence(cc.spawn(cc.moveTo(0.2, cc.p(-350, 0)), cc.scaleTo(0.2, 0.5, 1)), cc.callFunc(function () {
                    this.getComponent('CardUIPhom').fold();
                    this.rotation = 0;
                }, card), cc.scaleTo(0.1, 0.7));
                chiaBaiAction.easing(cc.easeQuadraticActionOut());
                card.runAction(chiaBaiAction);
            }
        }

        var childView;
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            childView = this.playerNodeList[i].getComponent('PlayerUITLMN');
            if (!childView.player) {
                continue;
            }
            if (childView.player.data.state !== TLMNConstant.PlayerState.WAITING) {
                childView.clearEffects();
            }
            if (childView.player.data.username !== params.userName) {
                childView.clearCountDown();
            } else {
                var dt = 0;
                if (params.__execInfo__) {
                    dt = params.__execInfo__.dt;
                }
                childView.setCountDown(params.timeTurn - dt);
            }

            if (childView.player.data.isBaoSam) {
                childView.addEffect(TLMNConstant.Effect.BAO_SAM);
            }

            if (childView.player.data.isBao) {
                childView.addEffect(TLMNConstant.Effect.BAO, true);
            }

            if (childView.player.data.state === TLMNConstant.PlayerState.NONE) {
                childView.addEffect(TLMNConstant.Effect.DANG_DOI);
            }

            if (childView.player.data.state === TLMNConstant.PlayerState.OUT_TURN) {
                childView.addEffect(TLMNConstant.Effect.HET_LUOT);
            }

            childView.onRefresh();
        }

        this.updatedGame = true;
        if (this.curPlayerUI().getComponent('PlayerUITLMN').player.data.state === TLMNConstant.PlayerState.IN_TURN) {
            this.audioManager.playTurnStart();
            this.addTimeout(TLMNConstant.TimeoutId.CHANGE_TURN, setTimeout(function () {
                self.setCurrentPlayerInTurn(true);
            }, 1000));
        } else {
            this.setCurrentPlayerInTurn(false);
        }
        // this.curPlayerUI().onRefresh();
    },

    onDiscard: function onDiscard(params) {
        var childView = this.findPlayerNodeByName(params.userName);

        if (childView) {
            var self = this;
            childView.getComponent('PlayerUITLMN').clearCountDown();
            childView.getComponent('PlayerUITLMN').onDiscard(params.cards);
            if (params.cards && params.cards.length > 0) {
                this.audioManager.playBaiBay();
                this.addTimeout(TLMNConstant.TimeoutId.DISCARD_MUSIC, setTimeout(function () {
                    if (self.audioManager) {
                        self.audioManager.playDanhBai();
                    }
                }, 400));
            }
        }
    },

    onRefreshGame: function onRefreshGame(params) {
        if (params.data.trash) {
            this.curPlayerUI().showTrashCard(params.data.trash);
        }
    },

    onFinishGame: function onFinishGame(params) {
        var dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.countDownTime = Date.now() + params.data.time - dt;
        if (params.data.lastPlayer) {
            var data = {
                userName: params.data.lastPlayer.userName,
                cards: params.data.cards
            };
            this.onDiscard(data);
        }
        this.setCurrentPlayerInTurn(false);

        this.showPlayerWin(params);

        for (var i = 0; i < params.data.result.summary.length; i += 1) {
            var playerResult = params.data.result.summary[i];
            var childView = this.findPlayerNodeByName(playerResult.userName);
            if (childView) {
                var playerUITLMN = childView.getComponent('PlayerUITLMN');
                if (playerUITLMN.player.data.state !== TLMNConstant.PlayerState.WAITING) {
                    if (playerUITLMN.backCardNode) {
                        playerUITLMN.backCardNode.active = false;
                    }

                    if (playerResult) {
                        if (playerResult.hand) {
                            playerUITLMN.showAllCards(playerResult.hand);
                        }
                    }
                    var checkCurrentPlayerThangTrang = false;
                    if (params.data.finishType === 'Thắng trắng') {
                        if (params.data.winners) {
                            for (var j = 0; j < params.data.winners.length; j += 1) {
                                if (params.data.winners[j] === playerResult.userName) {
                                    this.showPlayerThangTrang(playerUITLMN, params.data.thangTrangType);
                                    if (playerResult.userName === AuthUser.username) {
                                        checkCurrentPlayerThangTrang = true;
                                    }
                                }
                            }
                        }

                        if (params.data.winner) {
                            if (params.data.winner === playerResult.userName) {
                                this.showPlayerThangTrang(playerUITLMN, params.data.thangTrangType);
                                if (playerResult.userName === AuthUser.username) {
                                    checkCurrentPlayerThangTrang = true;
                                }
                            }
                        }
                    }
                    if (checkCurrentPlayerThangTrang) {
                        this.audioManager.playThangTrang();
                    } else {
                        if (playerResult.userName === AuthUser.username) {
                            if (playerResult.moneyExchange > 0) {
                                this.audioManager.playWin();
                            } else {
                                this.audioManager.playLose();
                            }
                        }
                    }
                    this.checkDenLang(params, playerResult, playerUITLMN);
                }
            }
        }
    },

    onChatHang: function onChatHang(params) {
        var targetPlayer = this.findPlayerNodeByName(params.data.targetPlayer);
        var targetPlayerUITLMN;
        if (targetPlayer) {
            targetPlayerUITLMN = targetPlayer.getComponent('PlayerUITLMN');
            var moneyExchange = params.data.money - Math.floor(params.data.money * this.gameManager.fee);
            targetPlayerUITLMN.showMoneyExchange(moneyExchange);
        }

        var sourcePlayer = this.findPlayerNodeByName(params.data.sourcePlayer);
        if (sourcePlayer) {
            var sourcePlayerUITLMN = sourcePlayer.getComponent('PlayerUITLMN');
            sourcePlayerUITLMN.showMoneyExchange(-params.data.money);
        }
    },
    // ============================================================
    // Other
    // ============================================================
    showPlayerWin: function showPlayerWin(params) {
        var countMoneyExchange = 0;
        for (var i = 0; i < params.data.result.actions.length; i += 1) {
            var action = params.data.result.actions[i];
            var playerUI = this.findPlayerNodeByName(action.sourcePlayer);
            if (playerUI) {
                if (playerUI.player.data.state !== TLMNConstant.PlayerState.WAITING) {
                    playerUI.clearEffects();
                    playerUI.setFinishEffect(-action.moneyExchange);
                }
            }
            countMoneyExchange += action.moneyExchange;
        }
        var playerWin = this.findPlayerNodeByName(params.data.result.actions[0].targetPlayer);
        if (playerWin) {
            countMoneyExchange -= Math.floor(countMoneyExchange * this.gameManager.fee);
            playerWin.setFinishEffect(countMoneyExchange);
        }
    },

    showButtonBoChon: function showButtonBoChon() {
        var cardDiscard = this.curPlayerUI().getCardTouched();
        if (cardDiscard.length > 0) {
            this.boChonButton.interactable = true;
            if (this.curPlayerUI().getComponent('PlayerUITLMN').player.data.state === TLMNConstant.PlayerState.IN_TURN) {
                this.danhButton.interactable = true;
            }
        } else {
            this.boChonButton.interactable = false;
            this.danhButton.interactable = false;
        }
    },

    showPlayerThangTrang: function showPlayerThangTrang(playerUITLMN, type) {
        var effect = playerUITLMN._addEffect(playerUITLMN.effectTemplateNodeList[TLMNConstant.Effect.THANG_TRANG]);
        var typeToiTrangLabel = effect.getChildByName('LblToiTrang');
        if (typeToiTrangLabel) {
            typeToiTrangLabel.getComponent(cc.Label).string = 'Thắng trắng: ' + type;
        }
    },

    checkDenLang: function checkDenLang(params, playerResult, playerUITLMN) {
        var actions = params.data.result.actions;
        for (var k = 0; k < actions.length; k += 1) {
            if (actions[k].isCong) {
                playerUITLMN.addEffect(TLMNConstant.Effect.THUA_CONG);
            }
        }
    },

    clearTrashCards: function clearTrashCards() {
        Utils.Node.destroyAllChildrenInNode(this.portCardTrash);
        // this.portCardTrash.removeAllChildren();
    },

    setCurrentPlayerInTurn: function setCurrentPlayerInTurn(value) {
        this.boChonButton.interactable = value;
        this.boLuotButton.interactable = value;
        this.danhButton.interactable = value;

        if (value) {
            var cardDiscard = this.curPlayerUI().getCardTouched();
            if (cardDiscard.length > 0) {
                this.boChonButton.interactable = true;
                this.danhButton.interactable = true;
            } else {
                this.boChonButton.interactable = false;
                this.danhButton.interactable = false;
            }
        }
        this.boChonButton.node.setScale(1);
        this.boLuotButton.node.setScale(1);
        this.danhButton.node.setScale(1);
    },

    curPlayerUI: function curPlayerUI() {
        return this.playerNodeList[0];
    },

    clearStateGame: function clearStateGame() {
        this.clearTrashCards();

        var childView;
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            childView = this.playerNodeList[i];
            if (childView) {
                childView.getComponent('PlayerUITLMN').clearAll();
            }
        }
    },

    onPrePlayerRemoved: function onPrePlayerRemoved(playerNode) {
        playerNode.node.getComponent('PlayerUITLMN').clearAll();
    },

    onPostPlayerAdded: function onPostPlayerAdded(playerNode) {
        var playerUITLMN = playerNode.node.getComponent('PlayerUITLMN');
        if (playerUITLMN.player) {
            if (playerUITLMN.player.data.handSize > 0) {
                if (playerUITLMN.backCardNode) {
                    playerUITLMN.backCardNode.active = true;
                    playerUITLMN.numberCardLabel.string = playerUITLMN.player.data.handSize;
                }
            }
        }
        if (playerNode.player) {
            if (playerNode.player.data.state === TLMNConstant.PlayerState.WAITING) {
                playerNode.addEffect(TLMNConstant.Effect.DANG_DOI);
            }
        }
    }

});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","TLMNConstant":"TLMNConstant","UiManager":"UiManager","Utils":"Utils"}],"GameplayTaiXiu":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2aa36OdRqdDnqaotsfW+G3U', 'GameplayTaiXiu');
// scripts\components\games\tai_xiu\GameplayTaiXiu.js

var BaseMinigameGameplay = require('BaseMinigameGameplay'),
    GameConstant = require('GameConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    CommonConstant = require('CommonConstant'),
    GameManagerConstant = require('GameManagerConstant'),
    TaiXiuConstant = require('TaiXiuConstant');

cc.Class({
    'extends': BaseMinigameGameplay,

    properties: {
        chipPrefab: cc.Prefab,
        chipListNode: cc.Node,
        chipListScrollView: cc.ScrollView,

        diceNode: {
            'default': [],
            type: cc.Node
        },
        diceSpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        },

        bigPotResultNode: cc.Node,
        littlePotResultNode: cc.Node,

        bigPotNumberOfPlayersLabel: cc.Label,
        littlePotNumberOfPlayersLabel: cc.Label,

        bigPotTotalBettingLabel: cc.Label,
        littlePotTotalBettingLabel: cc.Label,

        bigPotPlayerBettingLabel: cc.Label,
        littlePotPlayerBettingLabel: cc.Label,

        bigPotTempPlayerBettingLabel: cc.Label,
        littlePotTempPlayerBettingLabel: cc.Label,

        bigPotTempPlayerBettingNode: cc.Node,
        littlePotTempPlayerBettingNode: cc.Node,

        bigPotResultHistoryNode: cc.Node,
        littlePotResultHistoryNode: cc.Node,
        activePotResultHistoryNode: cc.Node,
        historyListNode: cc.Node,
        historyTrayScrollView: cc.ScrollView,

        toggleCurrencyIconNode: cc.Node,
        bottomToggleCurrencyIconNode: cc.Node,

        bottomPanelNode: cc.Node,

        balanceLabel: cc.Label,

        timeLeftLabel: cc.Label,

        gameStateLabel: cc.Label,

        historyTablePrefab: cc.Prefab,
        topTablePrefab: cc.Prefab,
        textMoneyPrefab: cc.Prefab,

        denNhapNhayAnimation: cc.Animation,
        denNhapNhaySprite: cc.Sprite,
        denNhapNhaySpriteFrameFirst: cc.SpriteFrame,
        gameCmd: {
            'default': GameConstant.TAI_XIU.CMD,
            visible: false
        }
    },

    onEnable: function onEnable() {
        var self = this;
        this.gameManager.enablePing();

        this.historyListNode.active = false;
        this.addTimeout(TaiXiuConstant.TimeoutId.SHOW_HISTORY_TRAY, setTimeout(function () {
            self.historyListNode.opacity = 0;
            self.historyListNode.active = true;
            if (self.historyListNode.width >= self.historyListNode.parent.width) {
                self.historyTrayScrollView.scrollToRight();
            } else {
                self.historyTrayScrollView.scrollToLeft();
            }
            self.historyListNode.opacity = 255;
        }, 500));
    },

    onDisable: function onDisable() {
        this.gameManager.disablePing();
    },

    // called every frame, uncomment this function to activate update callback
    $onUpdate: function $onUpdate() {
        if (this.gameManager) {
            this.timeLeftLabel.string = this.gameManager.getFormattedCurrentTimeLeft();
            this.gameStateLabel.string = this.gameManager.getStateLabel();
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        var self = this;

        this.active = {
            pot: -1,
            currency: null
        };

        this.chipListByCurrency = {};
        this._clearPots();
        this._clearTempBetting();
        this._clearWinningPotActive();
        this._setPot(-1);
        this.gameStateLabel.string = TaiXiuConstant.GameStateName.BETTING;

        this._updateTable();

        if (this.gameManager.bettingInfo) {
            this.switchCurrency();
        }

        this.historyTrayScrollView.scrollToLeft();

        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.UPDATE_POTS, this.onUpdatePots, this);
        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.UPDATE_TEMP_BETTING, this.onUpdateTempBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.BETTING_SUCCESS, this.onBettingSuccess, this);
        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.EFFECT_STATE, this.onChangeStateToEffect, this);
        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.PLAYER_BETTING_STATE, this.onChangeStateToPlayerBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(TaiXiuConstant.Event.FINISH, this.onFinishGame, this);

        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.UPDATE_USER_MONEY, this.onUpdateUserMoney, this);
        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.NEW_MATCH_LOST_FOCUS, this.onNewMatchLostFocus, this);

        self.addTimeout(setTimeout(function () {
            if (self.node.isValid && !self.bottomPanelNode.active) {
                var oldY = self.bottomPanelNode.y;
                self.bottomPanelNode.y = 10000;
                self.bottomPanelNode.active = true;
                self.addTimeout(setTimeout(function () {
                    if (self.node.isValid) {
                        self.chipListScrollView.scrollToPercentHorizontal(0.5);
                        self.bottomPanelNode.active = false;
                        self.bottomPanelNode.y = oldY;
                    }
                }, 100));
            }
        }, 10));
    },

    close: function close() {
        this.node.active = false;
    },

    submitTempBetting: function submitTempBetting() {
        this.gameManager.acceptTempBetting();
    },

    cancelTempBetting: function cancelTempBetting() {
        this.gameManager.cancelTempBetting();
    },

    onUpdateTempBetting: function onUpdateTempBetting() {
        var tempBettingInfo = this.gameManager.current.tempBettingInfo;
        if (Utils.Object.isEmpty(tempBettingInfo)) {
            this._clearTempBetting();
        } else if (this.active.currency === tempBettingInfo.currency && this.active.pot === tempBettingInfo.pot) {
            this._setTempBetting(this.active.pot, tempBettingInfo.betting || 0);
        }
    },

    selectBigPot: function selectBigPot() {
        this._selectPot(TaiXiuConstant.Pot.BIG.ID);
    },

    selectLittlePot: function selectLittlePot() {
        this._selectPot(TaiXiuConstant.Pot.LITTLE.ID);
    },

    _selectPot: function _selectPot(pot) {
        if (this.gameManager.gameState === TaiXiuConstant.GameState.PLAYER_BETTING) {
            if (this.active.pot !== pot) {
                if (pot === TaiXiuConstant.Pot.BIG.ID) {
                    this._setBettingPotActive(TaiXiuConstant.Pot.BIG.ID, true);
                    this._setBettingPotActive(TaiXiuConstant.Pot.LITTLE.ID, false);
                } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
                    this._setBettingPotActive(TaiXiuConstant.Pot.BIG.ID, false);
                    this._setBettingPotActive(TaiXiuConstant.Pot.LITTLE.ID, true);
                }
                this._setPot(pot);
                this.cancelTempBetting();
            }
        }
    },

    _setBettingPotActive: function _setBettingPotActive(pot, isActive) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotTempPlayerBettingNode.active = isActive;
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotTempPlayerBettingNode.active = isActive;
        }
    },

    _setWinningPotActive: function _setWinningPotActive(pot, isActive) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotResultNode.active = isActive;
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotResultNode.active = isActive;
        }
    },

    switchCurrency: function switchCurrency() {
        var success = false;
        if (this.active.currency === CommonConstant.CurrencyType.Ip.NAME) {
            this.active.currency = CommonConstant.CurrencyType.Xu.NAME;
            success = true;
        } else if (!this.active.currency || this.active.currency === CommonConstant.CurrencyType.Xu.NAME) {
            this.active.currency = CommonConstant.CurrencyType.Ip.NAME;
            success = true;
        }

        if (success) {
            var toggleCurrencyIconComp = this.toggleCurrencyIconNode.getComponent('ToggleCurrency'),
                bottomToggleCurrencyIconComp = this.bottomToggleCurrencyIconNode.getComponent('ToggleCurrency'),
                bettingValues = this.gameManager.bettingInfo[this.active.currency] || [],
                colors = Utils.Array.createCircular(['blue', 'purple', 'green', 'red']),
                self = this,
                chipComponent,
                chip,
                i;

            this.chipListNode.removeAllChildren();
            this.chipListNode.opacity = 0;
            for (i = 0; i < bettingValues.length; i += 1) {
                chip = cc.instantiate(this.chipPrefab);
                chipComponent = chip.getComponent('Chip');
                chipComponent.init(bettingValues[i], colors.next());
                chip.on(cc.Node.EventType.TOUCH_END, function () {
                    if (self.gameManager.gameState === TaiXiuConstant.GameState.PLAYER_BETTING) {
                        self.gameManager.addTempBetting(self.active.pot, this.money, self.active.currency);
                        self.onUpdateTempBetting();
                    }
                    self.audioManager.playChipBay();
                }, chipComponent);
                this.chipListNode.addChild(chip);
            }
            this.addTimeout(TaiXiuConstant.TimeoutId.SWITCH_CURRENCY, setTimeout(function () {
                if (self.node.isValid) {
                    if (self.chipListNode.width >= self.chipListScrollView.node.width) {
                        self.chipListScrollView.scrollToLeft();
                    } else {
                        self.chipListScrollView.scrollToPercentHorizontal(0.5);
                    }
                    self.chipListNode.opacity = 255;
                }
            }, 10));

            toggleCurrencyIconComp.switchTo(this.active.currency);
            bottomToggleCurrencyIconComp.switchTo(this.active.currency);
            this._updateTable();
            this.cancelTempBetting();
        }
    },

    _updateTable: function _updateTable() {
        this.onUpdatePots();
        this.onBettingSuccess();
        this.onUpdateTempBetting();
        this.onUpdateUserMoney();
    },

    onUpdatePots: function onUpdatePots() {
        var pots = this.gameManager.pots,
            potBettingMap = pots && pots[this.active.currency] || {},
            bigPotBettingInfo = potBettingMap[TaiXiuConstant.Pot.BIG.ID] || {},
            littlePotBettingInfo = potBettingMap[TaiXiuConstant.Pot.LITTLE.ID] || {};

        this._setTotalBetting(TaiXiuConstant.Pot.BIG.ID, bigPotBettingInfo.money || 0);
        this._setNumberPlayerBetting(TaiXiuConstant.Pot.BIG.ID, bigPotBettingInfo.size || 0);

        this._setTotalBetting(TaiXiuConstant.Pot.LITTLE.ID, littlePotBettingInfo.money || 0);
        this._setNumberPlayerBetting(TaiXiuConstant.Pot.LITTLE.ID, littlePotBettingInfo.size || 0);

        this._clearWinningPotActive();
    },

    onBettingSuccess: function onBettingSuccess() {
        var bettingInfo = this.gameManager.current.bettingInfo,
            potBettingMap = bettingInfo[this.active.currency] || {};

        this._setBetting(TaiXiuConstant.Pot.BIG.ID, potBettingMap[TaiXiuConstant.Pot.BIG.ID] || 0);
        this._setBetting(TaiXiuConstant.Pot.LITTLE.ID, potBettingMap[TaiXiuConstant.Pot.LITTLE.ID] || 0);
    },

    onChangeStateToEffect: function onChangeStateToEffect(params) {
        var dices = params.dices,
            i;
        if (dices) {
            for (i = 0; i < dices.length; i += 1) {
                this.rotateDice(this.diceNode[i], this.diceSpriteFrames, dices[i], i);
            }
            this.denNhapNhayAnimation.play();
        }
        this._setPot(-1);
    },

    onChangeStateToPlayerBetting: function onChangeStateToPlayerBetting() {
        this.denNhapNhayAnimation.stop();
        this.denNhapNhaySprite.spriteFrame = this.denNhapNhaySpriteFrameFirst;
        this._clearWinningPotActive();
        this._clearPots();
        this._clearBetting();
        this._updateTable();
    },

    onFinishGame: function onFinishGame(params) {
        var potWin = params && params.potWin && params.potWin[0];
        if (Utils.Type.isNumber(potWin)) {
            this._clearWinningPotActive();
            this._setWinningPotActive(potWin, true);
            this.createNewPotResult(potWin);
        }
        this.gameManager.startGame();

        // Money
        var ipExchange = params.player[CommonConstant.CurrencyType.Ip.NAME],
            xuExchange = params.player[CommonConstant.CurrencyType.Xu.NAME],
            moneyIpExchange = 0,
            moneyXuExchange = 0;
        if (ipExchange) {
            moneyIpExchange = ipExchange.moneyExchange;
            if (moneyIpExchange !== 0) {
                var textFly = cc.instantiate(this.textMoneyPrefab);
                textFly.getComponent(cc.Label).string = (moneyIpExchange > 0 ? '+' : '') + Utils.Number.format(moneyIpExchange) + ' ' + CommonConstant.CurrencyType.Ip.DISPLAY_NAME;
                var action = cc.sequence(cc.moveBy(2, cc.v2(0, 200)).easing(cc.easeQuinticActionOut()), cc.delayTime(6), cc.callFunc(function () {
                    textFly.removeFromParent();
                }));
                textFly.runAction(action);
                this.node.addChild(textFly);
            }
        }
        if (xuExchange) {
            moneyXuExchange = xuExchange.moneyExchange;
            if (moneyXuExchange !== 0) {
                var textFly1 = cc.instantiate(this.textMoneyPrefab);
                textFly1.getComponent(cc.Label).string = (moneyXuExchange > 0 ? '+' : '') + Utils.Number.format(moneyXuExchange) + ' ' + CommonConstant.CurrencyType.Xu.DISPLAY_NAME;
                textFly1.getComponent(cc.Label).enabled = false;
                var action1 = cc.sequence(cc.delayTime(ipExchange ? 1 : 0), cc.callFunc(function () {
                    textFly1.getComponent(cc.Label).enabled = true;
                }), cc.moveBy(2, cc.v2(0, 150)).easing(cc.easeQuinticActionOut()), cc.delayTime(6.5), cc.callFunc(function () {
                    textFly1.removeFromParent();
                }));
                textFly1.runAction(action1);
                this.node.addChild(textFly1);
            }
        }
    },

    _setTotalBetting: function _setTotalBetting(pot, betting) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotTotalBettingLabel.string = Utils.Number.format(betting);
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotTotalBettingLabel.string = Utils.Number.format(betting);
        }
    },

    _setNumberPlayerBetting: function _setNumberPlayerBetting(pot, size) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotNumberOfPlayersLabel.string = '(' + Utils.Number.format(size) + ')';
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotNumberOfPlayersLabel.string = '(' + Utils.Number.format(size) + ')';
        }
    },

    _setTempBetting: function _setTempBetting(pot, betting) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotTempPlayerBettingLabel.string = Utils.Number.format(betting);
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotTempPlayerBettingLabel.string = Utils.Number.format(betting);
        }
    },

    _setBetting: function _setBetting(pot, betting) {
        if (pot === TaiXiuConstant.Pot.BIG.ID) {
            this.bigPotPlayerBettingLabel.string = Utils.Number.format(betting);
        } else if (pot === TaiXiuConstant.Pot.LITTLE.ID) {
            this.littlePotPlayerBettingLabel.string = Utils.Number.format(betting);
        }
    },

    _clearTempBetting: function _clearTempBetting() {
        this._setTempBetting(TaiXiuConstant.Pot.BIG.ID, 0);
        this._setTempBetting(TaiXiuConstant.Pot.LITTLE.ID, 0);
    },

    _clearBetting: function _clearBetting() {
        this._setBetting(TaiXiuConstant.Pot.BIG.ID, 0);
        this._setBetting(TaiXiuConstant.Pot.LITTLE.ID, 0);
    },

    _clearPots: function _clearPots() {
        this._setTotalBetting(TaiXiuConstant.Pot.BIG.ID, 0);
        this._setNumberPlayerBetting(TaiXiuConstant.Pot.BIG.ID, 0);
        this._setBettingPotActive(TaiXiuConstant.Pot.BIG.ID, false);

        this._setTotalBetting(TaiXiuConstant.Pot.LITTLE.ID, 0);
        this._setNumberPlayerBetting(TaiXiuConstant.Pot.LITTLE.ID, 0);
        this._setBettingPotActive(TaiXiuConstant.Pot.LITTLE.ID, false);
    },

    _clearWinningPotActive: function _clearWinningPotActive() {
        this._setWinningPotActive(TaiXiuConstant.Pot.BIG.ID, false);
        this._setWinningPotActive(TaiXiuConstant.Pot.LITTLE.ID, false);
    },

    _setPot: function _setPot(pot) {
        this.active.pot = pot;
        if (pot >= 0) {
            this.bottomPanelNode.active = true;
        } else {
            this.bottomPanelNode.active = false;
        }
    },

    onUpdateUserMoney: function onUpdateUserMoney() {
        if (this.active.currency) {
            this.balanceLabel.string = Utils.Number.format(AuthUser.currencies[this.active.currency].balance);
        }
    },

    onNewMatchLostFocus: function onNewMatchLostFocus() {
        this._clearPots();
        this._clearTempBetting();
        this._clearWinningPotActive();
        this._updateTable();
        this.gameManager.startGame();
    },

    rotateDice: function rotateDice(diceNode, diceSpriteFrames, result, index) {
        diceNode.active = true;
        diceNode.setScale(1);
        // var randomRotation = Math.random();
        // var rRotation = (randomRotation * 360) || 0;
        var anim = diceNode.getComponent(cc.Animation),
            sprite = diceNode.getComponent(cc.Sprite);
        anim.play('XucXac');
        var duration = anim.currentClip.duration * 1000;
        this.addTimeout(TaiXiuConstant.TimeoutId.ROTATE_DICE + index, setTimeout(function () {
            anim.stop();
            sprite.spriteFrame = diceSpriteFrames[result];
        }, duration));

        // var quayAction = cc.spawn(
        //     cc.sequence(
        //         cc.spawn(
        //             cc.scaleTo(1, 1.5),
        //             cc.sequence(
        //                 cc.callFunc(function () {
        //                     animState.speed = 1.5;
        //                 }),

        //                 cc.delayTime(0.25),
        //                 cc.callFunc(function () {
        //                     animState.speed = 2.5;
        //                 }),
        //                 cc.delayTime(0.25),
        //                 cc.callFunc(function () {
        //                     animState.speed = 3;
        //                 }),
        //                 cc.delayTime(0.1),
        //                 cc.callFunc(function () {
        //                     animState.speed = 2.25;
        //                 }),
        //                 cc.delayTime(0.15),
        //                 cc.callFunc(function () {
        //                     animState.speed = 1.25;
        //                 })
        //             )
        //         ),
        //         cc.delayTime(0.4),
        //         cc.spawn(
        //             cc.scaleTo(0.4, 1),
        //             cc.callFunc(function () {
        //                 animState.speed = 5;
        //             })
        //         ),

        //         cc.delayTime(0.2),
        //         cc.callFunc(function () {
        //             anim.stop();
        //             sprite.spriteFrame = diceSpriteFrames[result];
        //             diceNode.setScale(0.6);
        //         })
        //     ),
        //     cc.rotateTo(0, rRotation)
        // );
        // diceNode.runAction(quayAction);
    },

    createNewPotResult: function createNewPotResult(pot) {
        var node = cc.instantiate(pot === TaiXiuConstant.Pot.BIG.ID ? this.bigPotResultHistoryNode : this.littlePotResultHistoryNode);
        node.parent = this.historyListNode;
        node.active = true;
        this.activePotResultHistoryNode.parent = node;
        this.activePotResultHistoryNode.active = true;
        if (this.historyListNode.width + node.width >= this.historyListNode.parent.width) {
            this.historyTrayScrollView.scrollToRight();
        }
    },

    openHistoryTable: function openHistoryTable() {
        var hisotryTable = cc.instantiate(this.historyTablePrefab);
        hisotryTable.getComponent('HistoryTableTaiXiu').init(this.gameManager.history.slice());
        cc.director.getScene().addChild(hisotryTable);
    },

    openTopTable: function openTopTable() {
        var topTable = cc.instantiate(this.topTablePrefab);
        topTable.getComponent('TopTableTaiXiu').getData(this.active.currency, new Date().getTime());
        cc.director.getScene().addChild(topTable);
    },

    openHelpTable: function openHelpTable() {
        this.gameManager.openHelpModal();
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMinigameGameplay":"BaseMinigameGameplay","CommonConstant":"CommonConstant","GameConstant":"GameConstant","GameManagerConstant":"GameManagerConstant","TaiXiuConstant":"TaiXiuConstant","Utils":"Utils"}],"GameplayXiTo":[function(require,module,exports){
"use strict";
cc._RFpush(module, '43da2OLCjBCz5j+iXHgSRFE', 'GameplayXiTo');
// scripts\components\games\xito\GameplayXiTo.js

var GameConstant = require('GameConstant'),
    XiToConstant = require('XiToConstant'),
    Card = require('Card'),
    GameplayLieng = require('GameplayLieng'),
    Utils = require('Utils');

cc.Class({
    'extends': GameplayLieng,

    properties: {
        moneyCallLabel: cc.Label,
        choseCardNoticeLabel: cc.Label,
        bettingPanel: cc.Node,
        moneyToLabel: cc.Label,
        moneyToTatCaLabel: cc.Label,
        moneyTo12Label: cc.Label,
        moneyTo14Label: cc.Label,
        moneyToX2Label: cc.Label,
        gameCmd: {
            'default': GameConstant.XITO.CMD,
            visible: false,
            override: true
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        GameplayLieng.prototype.$onLoad.call(this);
        this.canClickToCard = false;
    },

    // ============================================================
    // Xử lý Button được click
    // ============================================================
    bettingCall: function bettingCall() {
        this.gameManager.bet(XiToConstant.Action.CALL);
        this.audioManager.playButtonClick();
    },
    bettingCheck: function bettingCheck() {
        this.gameManager.bet(XiToConstant.Action.CHECK);
        this.audioManager.playButtonClick();
    },
    bettingFold: function bettingFold() {
        this.gameManager.bet(XiToConstant.Action.FOLD);
        this.audioManager.playButtonClick();
    },
    bettingAll: function bettingAll() {
        this.gameManager.bet(XiToConstant.Action.ALL_IN);
        this.bettingPanel.active = false;
        this.audioManager.playButtonClick();
    },
    betting12: function betting12() {
        this.gameManager.bet(XiToConstant.Action.BET_1_2);
        this.bettingPanel.active = false;
        this.audioManager.playButtonClick();
    },
    betting14: function betting14() {
        this.gameManager.bet(XiToConstant.Action.BET_1_4);
        this.bettingPanel.active = false;
        this.audioManager.playButtonClick();
    },
    bettingX2: function bettingX2() {
        this.gameManager.bet(XiToConstant.Action.BET_X2);
        this.bettingPanel.active = false;
        this.audioManager.playButtonClick();
    },
    bettingNormal: function bettingNormal() {
        this.gameManager.bet(XiToConstant.Action.BET);
        this.bettingPanel.active = false;
        this.audioManager.playButtonClick();
    },
    showBettingPanel: function showBettingPanel() {
        this.bettingPanel.active = !this.bettingPanel.active;
        this.audioManager.playButtonClick();
    },

    // ============================================================
    // Xử lý các event từ GameManager
    // ============================================================
    onChangeStateGame: function onChangeStateGame() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            if (this.playerNodeList[i].player) {
                if (this.playerNodeList[i].player.data.state !== XiToConstant.PlayerState.FOLDED && this.playerNodeList[i].player.data.state !== XiToConstant.PlayerState.ALL_IN && this.playerNodeList[i].player.data.state !== XiToConstant.PlayerState.NONE) {
                    this.playerNodeList[i].clearEffects();
                }
            }
        }
        this.bettingPanel.active = false;
        this.moneyCallLabel.string = 0;
    },

    onChangeTurn: function onChangeTurn(params) {
        GameplayLieng.prototype.onChangeTurn.call(this, params);
        this.bettingPanel.active = false;
    },

    // drawcard
    onDrawCard: function onDrawCard(timeChooseOpenCard) {
        this.choseCardNoticeLabel.node.active = false;
        if (!this.layoutPlayerXiTo) {
            var cardsHoldCurrentPlayer = this.playerNodeList[0].node.getChildByName('Cards');
            this.layoutPlayerXiTo = cardsHoldCurrentPlayer.getComponent(cc.Layout);
        }

        if (this.gameManager.currentRound !== 1) {
            this.layoutPlayerXiTo.spacingX = -55;
        } else {
            this.layoutPlayerXiTo.spacingX = 45;
            this.choseCardNoticeLabel.node.active = true;
            if (timeChooseOpenCard) {
                this.playerNodeList[0].setCountDown(timeChooseOpenCard);
            }
        }
        GameplayLieng.prototype.onDrawCard.call(this);
    },

    // update info game
    updateInfoGame: function updateInfoGame(params) {
        var optionLabel = 'Luật: ' + this.gameManager.gameType + ' cây';
        this.topPanelInGameData.optionLabel = optionLabel;
        if (this.topPanelInGame) {
            this.topPanelInGame.setOptionLabel(optionLabel);
        }

        this.moneyCallLabel.string = Utils.Number.format(params.allData.callBetting);
        GameplayLieng.prototype.updateInfoGame.call(this, params);
    },
    // ============================================================
    // Other
    // ============================================================

    initAllBettingButtons: function initAllBettingButtons() {
        this.allButtonBettings = {};
        this.allButtonBettings[XiToConstant.Action.BET] = this.bettingButtonsList[0];
        this.allButtonBettings[XiToConstant.Action.ALL_IN] = this.bettingButtonsList[1];
        this.allButtonBettings[XiToConstant.Action.CALL] = this.bettingButtonsList[2];
        this.allButtonBettings[XiToConstant.Action.CHECK] = this.bettingButtonsList[3];
        this.allButtonBettings[XiToConstant.Action.FOLD] = this.bettingButtonsList[4];
        this.allButtonBettings[XiToConstant.Action.BET_1_2] = this.bettingButtonsList[5];
        this.allButtonBettings[XiToConstant.Action.BET_1_4] = this.bettingButtonsList[6];
        this.allButtonBettings[XiToConstant.Action.BET_X2] = this.bettingButtonsList[7];

        this.disableBettingButtons(true);
    },

    choosePublicCard: function choosePublicCard(params) {
        if (this.gameManager.currentRound === 1) {
            var cardUI = params.target.getComponent('CardUI');
            this.gameManager.choosePublicCard(cardUI.card.getId());
            this.layoutPlayerXiTo.spacingX = -55;
            var cardId = cardUI.card.getId();
            var playerUIXiTo = this.playerNodeList[0].node.getComponent('PlayerUIXiTo');
            if (this.gameManager.gameType === 7) {
                if (playerUIXiTo.cardsHold[2].node !== params.target.node) {
                    var card3rd = playerUIXiTo.cardsHold[2].getComponent('CardUI');
                    cardUI.setCard(Card.fromId(card3rd.card.getId()));
                    card3rd.setCard(Card.fromId(cardId));
                }
                playerUIXiTo.cardsHold[0].showTransparentBlackNode(true);
                playerUIXiTo.cardsHold[1].showTransparentBlackNode(true);
            } else {
                if (playerUIXiTo.cardsHold[1].node !== params.target.node) {
                    var card2nd = playerUIXiTo.cardsHold[1].getComponent('CardUI');
                    cardUI.setCard(Card.fromId(card2nd.card.getId()));
                    card2nd.setCard(Card.fromId(cardId));
                }
                playerUIXiTo.cardsHold[0].showTransparentBlackNode(true);
            }
        }
    },

    showOpenCardCurrentPlayer: function showOpenCardCurrentPlayer(playerXiTo, player) {
        for (var i = 0; i < playerXiTo.cardsHold.length; i += 1) {
            if (playerXiTo.cardsHold[i].node.active) {
                if (player.publicCards.length > 0) {
                    playerXiTo.cardsHold[i].showTransparentBlackNode(true);
                }
                for (var j = 0; j < player.publicCards.length; j += 1) {
                    if (playerXiTo.cardsHold[i].getComponent('CardUI').card && player.publicCards[j] === playerXiTo.cardsHold[i].getComponent('CardUI').card.getId()) {
                        playerXiTo.cardsHold[i].showTransparentBlackNode(false);
                        break;
                    }
                }
            }
        }
    },

    setCurrentPlayerInTurn: function setCurrentPlayerInTurn(allowedActionsList, actionMoneyList) {
        var j = 0;
        if (allowedActionsList) {
            this.disableBettingButtons(true);
            for (j = 0; j < allowedActionsList.length; j += 1) {
                this.allButtonBettings[allowedActionsList[j]].interactable = true;
            }
            this.bettingButtonsList[this.bettingButtonsList.length - 1].interactable = true;
        } else {
            // this.disableBettingButtons(false);
        }
        if (actionMoneyList) {
            this.moneyToLabel.string = '';
            this.moneyToX2Label.string = '';
            this.moneyTo14Label.string = '';
            this.moneyTo12Label.string = '';
            this.moneyToTatCaLabel.string = '';
            for (j = 0; j < actionMoneyList.length; j += 1) {
                switch (actionMoneyList[j].action) {
                    case XiToConstant.Action.BET:
                        this.moneyToLabel.string = Utils.Number.format(actionMoneyList[j].money);
                        break;
                    case XiToConstant.Action.BET_X2:
                        this.moneyToX2Label.string = Utils.Number.format(actionMoneyList[j].money);
                        break;
                    case XiToConstant.Action.BET_1_4:
                        this.moneyTo14Label.string = Utils.Number.format(actionMoneyList[j].money);
                        break;
                    case XiToConstant.Action.BET_1_2:
                        this.moneyTo12Label.string = Utils.Number.format(actionMoneyList[j].money);
                        break;
                    case XiToConstant.Action.ALL_IN:
                        this.moneyToTatCaLabel.string = Utils.Number.format(actionMoneyList[j].money);
                        break;
                }
            }
        }
    },

    initClickEventToCards: function initClickEventToCards() {
        var gameManager = this.gameManager,
            that = this;

        var cardsHold = this.playerNodeList[0].node.getComponent('PlayerUIXiTo').cardsHold;
        for (var i = 0; i < cardsHold.length; i += 1) {
            cardsHold[i].addComponent(cc.Button);
            cardsHold[i].on(cc.Node.EventType.TOUCH_START, function () {
                var cardScript = this.getComponent('CardUI');
                gameManager.choosePublicCard(cardScript.card.getId());
                that.canClickToCard = false;
            });
        }
    },

    reDrawCard: function reDrawCard(player, playerXiTo, index) {
        var k = 0,
            cardUI;

        if (index === 0) {
            for (k = 0; k < player.handSize; k += 1) {
                cardUI = playerXiTo.cardsHold[k].getComponent('CardUI');
                if (cardUI.card && cardUI.card.getId() !== player.cards[k]) {
                    cardUI.setCard(Card.fromId(player.cards[k]));
                }
            }
            if (player.publicCards) {
                this.showOpenCardCurrentPlayer(playerXiTo, player);
            }
        } else {
            for (k = 0; k < player.handSize; k += 1) {
                cardUI = playerXiTo.cardsHold[k].getComponent('CardUI');
                if (player.cards[k] >= 0) {
                    cardUI.setCard(Card.fromId(player.cards[k]));
                }
            }
        }
        if (player.state === XiToConstant.PlayerState.FOLDED) {
            if (index !== 0) {
                playerXiTo.fold();
            } else {
                playerXiTo.currentPlayerFold();
            }
        }
    },

    onShowBetting: function onShowBetting(params, playerUI) {
        GameplayLieng.prototype.onShowBetting.call(this, params, playerUI);
        this.moneyCallLabel.string = Utils.Number.format(params.allData.callBetting);
    },

    convertTypeBetting: function convertTypeBetting(typeBetting) {
        switch (typeBetting) {
            case XiToConstant.Action.BET:
                return XiToConstant.Effect.TO;
            case XiToConstant.Action.ALL_IN:
                return XiToConstant.Effect.TO_TAT_CA;
            case XiToConstant.Action.CALL:
                return XiToConstant.Effect.THEO;
            case XiToConstant.Action.CHECK:
                return XiToConstant.Effect.NHUONG_TO;
            case XiToConstant.Action.FOLD:
                return XiToConstant.Effect.UP_BO;
            case XiToConstant.Action.BET_1_2:
                return XiToConstant.Effect.TO_12;
            case XiToConstant.Action.BET_1_4:
                return XiToConstant.Effect.TO_14;
            case XiToConstant.Action.BET_X2:
                return XiToConstant.Effect.TO_X2;
            case XiToConstant.Action.ALL_HAND:
                return XiToConstant.Effect.CHOI_TAT_TAY;
        }
    },

    restartGame: function restartGame() {
        this.moneyCallLabel.string = '0';
        GameplayLieng.prototype.restartGame.call(this);
    }

});
// $onFocus: function () {
//     if (this.gameManager.gameState === XiToConstant.GameState.ROUND) {
//         this.onReDrawCard();
//     }
// },

cc._RFpop();
},{"Card":"Card","GameConstant":"GameConstant","GameplayLieng":"GameplayLieng","Utils":"Utils","XiToConstant":"XiToConstant"}],"GameplayXoSo":[function(require,module,exports){
"use strict";
cc._RFpush(module, '41c41IZt1FL0avkvy05z+ZP', 'GameplayXoSo');
// scripts\components\games\xo_so\GameplayXoSo.js

var EventDispatcherConstant = require('EventDispatcherConstant'),
    EventDispatcher = require('EventDispatcher'),
    NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant'),
    ToggleCurrency = require('ToggleCurrency'),
    UiManager = require('UiManager'),
    AuthUser = require('AuthUser'),
    Utils = require('Utils'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        xoSoItemPrefab: cc.Prefab,
        xoSoItemsContainer: cc.Node,

        dateLabel: cc.Label,
        remainTimeLabel: cc.Label,
        xoSoLogRichText: cc.RichText,

        xoSoEditBox: cc.EditBox,
        xoSoTypeInfoLabel: cc.Label,

        mucCuocPrefab: cc.Prefab,
        mucCuocContainer: cc.Node,

        balanceLabel: cc.Label,
        betAmountLabel: cc.Label,
        toggleCurrency: ToggleCurrency
    },

    start: function start() {
        this.node.zIndex = CommonConstant.ZINDEX.MINIGAME_PREFAB;
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.fetchXoSoTypes();
        this.fetchXoSoLogs();
        this.resetTienCuoc();

        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
    },

    fetchXoSoTypes: function fetchXoSoTypes() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.XOSO_TYPES, {}, {
            cache: 1800,
            delay: 500
        }).success(function (xoSoResp) {
            var mucCuocNode,
                icaoComponent,
                expireTime,
                xoSoItems = xoSoResp.data.types;
            that.betValues = xoSoResp.data.bet_values;
            expireTime = Utils.Date.fromString(xoSoResp.data.expire_time);
            that.remainSeconds = (expireTime.getTime() - new Date().getTime()) / 1000;
            that.dateLabel.string = 'Ngày ' + Utils.Date.format(expireTime, 'dd/mm/yyyy');

            that.switchCurrency();
            that.toggleCurrency.switchTo(that.currentCurrency);
            that.xoSoItemsContainer.removeAllChildren();
            for (var i = 0; i < xoSoItems.length; i += 1) {
                mucCuocNode = cc.instantiate(that.xoSoItemPrefab);
                icaoComponent = mucCuocNode.getComponent('XoSoItem');
                icaoComponent.updateData(xoSoItems[i]);
                mucCuocNode.xoSoType = xoSoItems[i];
                that.xoSoItemsContainer.addChild(mucCuocNode);

                if (i === 0) {
                    that.xoSoItemsContainer.getComponent('MultiSelect').selectItem(mucCuocNode);
                }
            }
        });
    },

    fetchXoSoLogs: function fetchXoSoLogs() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.XOSO_BET_LIST, {}, {
            cache: 300,
            delay: 500
        }).success(function (resp) {
            var logItems = resp.data,
                logStrings = [],
                logItem;
            for (var i = 0; i < logItems.length; i += 1) {
                logItem = logItems[i];
                logStrings.push(logItem.username + ' <color=#ff5c97>' + Utils.Number.abbreviate(logItem.amount) + ' ' + CommonConstant.CurrencyType.findByName(logItem.currency).DISPLAY_NAME + '</color> <color=#ed9459>' + logItem.bet_name + '</color> <color=#3debf5>' + logItem.numbers.join(' ') + '</color>');
            }
            that.xoSoLogRichText.string = logStrings.join('\n');
        });
    },

    betXoSo: function betXoSo(event) {
        var that = this;
        if (this.betAmount > 0) {
            NetworkManager.Http.fetch('POST', Url.Http.XOSO_BET, {
                username: AuthUser.username,
                accesstoken: AuthUser.accesstoken,
                amount: this.betAmount,
                currency: this.currentCurrency,
                bet_type: this.currentXoSoType,
                numbers: this.xoSoEditBox.string
            }).success(function (resp) {
                UiManager.openModal(resp.msg);
                that.resetTienCuoc();
                AuthUser.currencies[resp.data.currency].balance = resp.data.balance;
                EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_MONEY);
            }).setWaitingButton(event.target);
        } else {
            UiManager.openModal('Vui lòng chọn mức tiền cược.');
        }
    },

    selectXoSoType: function selectXoSoType(selectedItems) {
        if (selectedItems.length > 0) {
            var xoSoType = selectedItems[0].xoSoType,
                defaultNumber,
                i,
                tmpArray = [];
            this.currentXoSoType = xoSoType.id;
            this.xoSoTypeInfoLabel.string = xoSoType.name + ' (Đặt 1 ăn ' + xoSoType.ratio + ')';
            defaultNumber = new Array(xoSoType.number_of_digit + 1).join('0');
            for (i = 0; i < xoSoType.quantity_number; i += 1) {
                tmpArray.push(defaultNumber);
            }
            this.xoSoEditBox.string = tmpArray.join(', ');
        }
    },

    switchCurrency: function switchCurrency() {
        if (this.currentCurrency === CommonConstant.CurrencyType.Ip.NAME) {
            this.currentCurrency = CommonConstant.CurrencyType.Xu.NAME;
        } else {
            this.currentCurrency = CommonConstant.CurrencyType.Ip.NAME;
        }
        this.updateUserMoney();
        this.resetTienCuoc();

        var that = this,
            cacMucCuoc = that.betValues[that.currentCurrency],
            mucCuocNode;

        that.mucCuocContainer.removeAllChildren();
        for (var i = 0; i < cacMucCuoc.length; i += 1) {
            mucCuocNode = cc.instantiate(that.mucCuocPrefab);
            mucCuocNode.betAmount = cacMucCuoc[i];
            mucCuocNode.getComponentInChildren(cc.Label).string = Utils.Number.abbreviate(cacMucCuoc[i]);
            that.mucCuocContainer.addChild(mucCuocNode);

            mucCuocNode.on(cc.Node.EventType.TOUCH_START, function (event) {
                that.themTienCuoc(event.target.betAmount);
            }, mucCuocNode);
        }
    },

    updateUserMoney: function updateUserMoney() {
        this.balanceLabel.string = Utils.Number.format(AuthUser.currencies[this.currentCurrency].balance);
    },

    themTienCuoc: function themTienCuoc(amount) {
        this.betAmount += amount;
        this.betAmountLabel.string = Utils.Number.format(this.betAmount);
    },

    resetTienCuoc: function resetTienCuoc() {
        this.betAmount = 0;
        this.betAmountLabel.string = Utils.Number.format(this.betAmount);
    },

    openXoSoResult: function openXoSoResult() {
        this.openXoSoInfoModal('XoSoResult');
    },

    openXoSoMyBetHistory: function openXoSoMyBetHistory() {
        this.openXoSoInfoModal('LichSu');
    },

    openXoSoHelp: function openXoSoHelp() {
        this.openXoSoInfoModal('Help');
    },

    openXoSoInfoModal: function openXoSoInfoModal(tabName) {
        UiManager.openModalByName('games/xo_so/XoSoInfoModal', function (newNode) {
            newNode.getComponentInChildren('TabView').activeByName(tabName);
        });
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var remainTimeStr, remainHours, remainSeconds;
        if (this.remainSeconds > 0) {
            this.remainSeconds -= dt;
            remainSeconds = this.remainSeconds;
            if (remainSeconds > 0) {
                remainHours = Math.floor(remainSeconds / 3600);
                remainTimeStr = Utils.Number.fillZero(remainHours, 2);
                remainTimeStr += ':' + Utils.Number.fillZero(Math.floor(remainSeconds / 60 - remainHours * 60), 2);
                remainTimeStr += ':' + Utils.Number.fillZero(Math.floor(remainSeconds % 60), 2);
                this.remainTimeLabel.string = remainTimeStr;
            }
        } else {
            this.remainTimeLabel.string = '00:00:00';
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","NetworkManager":"NetworkManager","ToggleCurrency":"ToggleCurrency","UiManager":"UiManager","Url":"Url","Utils":"Utils"}],"GameplayXocDia":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3ec08zHK0VPFJRoPbXZc2+V', 'GameplayXocDia');
// scripts\components\games\xoc_dia\GameplayXocDia.js

var GameConstant = require('GameConstant'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    BaseMainGameplay = require('BaseMainGameplay'),
    GameManagerConstant = require('GameManagerConstant'),
    XocDiaConstant = require('XocDiaConstant');

cc.Class({
    'extends': BaseMainGameplay,

    properties: {
        slotInfor: {
            'default': [],
            type: cc.Node

        },
        banker: cc.Node,
        chipPrefab: cc.Prefab,
        moveTo: cc.Node,
        moveFrom: cc.Node,
        bowDice: cc.Node,
        parentChipBetting: cc.Node,
        nhiKetQuaList: {
            'default': [],
            type: cc.Sprite
        },
        spriteFrameKetQua: {
            'default': [],
            type: cc.SpriteFrame
        },
        timeLabel: cc.Label,
        timeCountDow: cc.Sprite,
        gridResult: cc.Node,
        resultXanh: cc.Prefab,
        resultTrang: cc.Prefab,
        bow: cc.Node,
        stateGameLabel: cc.Label,
        btnX2: cc.Button,
        btnCancelBet: cc.Button,
        btnRebet: cc.Button,
        gameCmd: {
            'default': GameConstant.XOC_DIA.CMD,
            visible: false
        }
    },

    // use this for initialization
    $onLoad: function $onLoad() {
        this.listChipBetting = [];
        //this.bow = this.bowDice.getChildByName('ImgBat');

        this.moneyBetSelect = 0;
        this.time = 0;

        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.BETTING_SUCCESS, this.onBettingSuccess, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.SHAKE_BOW_DICE, this.onShakeBow, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.ADD_LIST_BETTING, this._addChipBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.PLAYER_BETTING_STATE, this._playerBettingState, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.FINISH, this.onFinishGame, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.CANCEL_BET, this.onCancelBetting, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.SET_RATIO, this.onSetRatio, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.BETTING_UPDATEGAME, this.onBettingUpdate, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.MASTER_CANEL_BET, this.onMasterCencelBet, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.MASTER_CANEL_BET_RECEIVE, this.onMasterCencelBetReceive, this);
        this.gameManager.eventDispatchers.local.addEventListener(XocDiaConstant.Event.CHANGE_STATE, this.onChangeState, this);

        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.NEW_MATCH_LOST_FOCUS, this.onNewMatchLostFocus, this);
        this._enableNodeWhenLoad(false);
        this._disableAllButton();
    },

    $onUpdate: function $onUpdate() {
        this._checkOnFocus();
        if (this.gameManager.gameState === XocDiaConstant.GameState.PLAYER_BETTING || this.gameManager.gameState === XocDiaConstant.GameState.MASTER_CANEL_BET) {
            var count = Math.floor((this.time - Date.now()) / 1000);
            count = count >= 0 ? count : 0;
            this.timeLabel.string = count;
            if (count <= 0) {
                this.timeLabel.node.active = false;
                this.timeCountDow.node.active = false;
            }
        }
    },

    $onDestroy: function $onDestroy() {
        if (this.xocAudioId) {
            this.audioManager.stopEffect(this.xocAudioId);
        }
    },

    $onFocus: function $onFocus() {

        if (this.gameManager.gameState !== XocDiaConstant.GameState.FINISH) {
            this.bow.position = cc.v2(0, 0);
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.showEfectWin(false);
            }
        }
        if (this.gameManager.gameState !== XocDiaConstant.GameState.EFFECT) {
            var anim = this.bowDice.getComponent(cc.Animation);
            anim.stop('Shake');
            if (this.xocAudioId) {
                this.audioManager.stopEffect(this.xocAudioId);
            }
        }
        if (this.gameManager.gameState === XocDiaConstant.GameState.EFFECT) {
            this.bowDice.position = cc.v2(0, 0);
        }
    },

    onNewMatchLostFocus: function onNewMatchLostFocus() {},

    onChangeState: function onChangeState() {
        switch (this.gameManager.gameState) {
            case XocDiaConstant.GameState.EFFECT:
                this.stateGameLabel.string = 'Nhà cái bắt đầu xóc!';
                this._disableAllButton();
                break;
            case XocDiaConstant.GameState.PLAYER_BETTING:
                this.stateGameLabel.string = 'Hãy chọn cửa để đặt!';
                if (this.gameManager.history.length > 0 && !this.gameManager.isMaster) {
                    this.btnRebet.interactable = true;
                }
                this.audioManager.playTurnStart();
                break;
            case XocDiaConstant.GameState.MASTER_CANEL_BET:
                this.stateGameLabel.string = 'Nhà cái hủy cược!';
                this._disableAllButton();
                break;
            case XocDiaConstant.GameState.FINALIZING:
                this.stateGameLabel.string = 'Kết quả!';
                this._disableAllButton();
                break;
        }
    },
    _disableAllButton: function _disableAllButton() {
        this.btnRebet.interactable = false;
        this.btnX2.interactable = false;
        this.btnCancelBet.interactable = false;
    },
    _checkOnFocus: function _checkOnFocus() {
        if (this.gameManager.gameState !== XocDiaConstant.GameState.FINALIZING) {
            this.bow.position = cc.v2(0, 0);
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.showEfectWin(false);
            }
        }
        if (this.gameManager.gameState !== XocDiaConstant.GameState.EFFECT) {
            var anim = this.bowDice.getComponent(cc.Animation);
            anim.stop('Shake');
            if (this.xocAudioId) {
                this.audioManager.stopEffect(this.xocAudioId);
            }
        } else {
            this.bowDice.position = cc.v2(0, 0);
        }
    },

    _showTimeState: function _showTimeState(time) {
        var anim = this.bowDice.getComponent(cc.Animation);
        anim.stop('Shake', 5);
        if (this.xocAudioId) {
            this.audioManager.stopEffect(this.xocAudioId);
        }
        this.bowDice.position = cc.v2(0, 0);
        this._enableNodeWhenLoad(true);
        var action = cc.rotateBy(5, 360);
        this.timeCountDow.node.runAction(cc.repeatForever(action));
        this.time = Date.now() + time;
    },

    onMasterCencelBetReceive: function onMasterCencelBetReceive(params) {
        var potComponent = this.slotInfor[params].getComponent('SlotInfor');
        for (var username in potComponent.playerBetList) {
            this._moveChipToPlayer(username, this.slotInfor[params]);
            potComponent.removeMoneyPot(username);
        }
    },

    onMasterCencelBet: function onMasterCencelBet(params) {
        this._showTimeState(params.time);
        this._activeSellCancelPot(true);
    },

    _activeSellCancelPot: function _activeSellCancelPot(isActive) {
        if (this.gameManager.isMaster && isActive) {
            for (var i = 0; i < this.slotInfor.length; i += 1) {
                var potComponent = this.slotInfor[i].getComponent('SlotInfor');
                potComponent.activeCancelPotXocDia(isActive);
            }
        } else {
            for (var j = 0; j < this.slotInfor.length; j += 1) {
                var potComponent1 = this.slotInfor[j].getComponent('SlotInfor');
                potComponent1.activeCancelPotXocDia(false);
            }
        }
    },

    _enableNodeWhenLoad: function _enableNodeWhenLoad(isEnable) {
        this.timeCountDow.node.active = isEnable;
        this.timeLabel.node.active = isEnable;
    },

    onBettingUpdate: function onBettingUpdate(params) {
        this.audioManager.playChipBay();
        for (var i = 0; i < params.info.length; i += 1) {
            var chip,
                playerParent = this.findPlayerNodeByName(params.info[i].userName),
                chipComponent,
                slotComponent,
                myMoney = 0;
            chip = cc.instantiate(this.chipPrefab);
            if (playerParent) {
                chip.parent = playerParent.node.parent;
                chip.position = playerParent.node;
            }
            chipComponent = chip.getComponent('Chip');
            chipComponent.activeSelectChip(false);
            chipComponent.moneyLabel.node.active = false;
            chip.scale = cc.v2(0.5, 0.5);
            chipComponent.init(params.info[i].money);
            chipComponent = chip.getComponent(cc.Button);
            chipComponent.enabled = false;
            // chipComponent =
            chip.removeComponent('ButtonScaler');
            // chipComponent.removeComponent();
            slotComponent = this.slotInfor[params.id].getComponent('SlotInfor');
            slotComponent.init();
            if (params.info[i].username === AuthUser.username) {
                myMoney = params.info[i].money;
            }
            slotComponent.setMoneyPot(myMoney, params.info[i].money);
            slotComponent.addPlayerBetToPot(params.info[i].userName, params.info[i].money);
            var moveChip = cc.moveTo(0.5, cc.v2(this.slotInfor[params.id].x, this.slotInfor[params.id].y)).easing(cc.easeOut(2.0));
            chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
                this.destroy();
            }, chip)));
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}
        var potComponent = this.slotInfor[params.pot].getComponent('SlotInfor');
        this._moveChipToPlayer(params.username, this.slotInfor[params.pot]);
        if (params.username === AuthUser.username) {
            this.btnX2.interactable = false;
            this.btnCancelBet.interactable = false;
        }
        potComponent.removeMoneyPot(params.username);
    },

    onSetRatio: function onSetRatio(params) {
        for (var i = 0; i < params.length; i += 1) {
            var potComponent = this.slotInfor[params[i].id].getComponent('SlotInfor');
            potComponent.setRatioPot(params[i].ratio);
        }
    },

    onFinishGame: function onFinishGame(params) {
        var self = this;
        self.timeCountDow.node.active = false;
        var action = cc.sequence(cc.callFunc(function () {
            self._setKetQua(params.dices);
        }), cc.callFunc(function () {
            self._openBow();
        }), cc.delayTime(1), cc.callFunc(function () {
            self._showSlostWin(params.potWin);
        }), cc.callFunc(function () {
            self._bankerPayChip(params.potWin);
        }), cc.delayTime(1), cc.callFunc(function () {
            self._payChipToPlayer(params.potWin);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._showMoneyFinish(params.players);
        }), cc.delayTime(2), cc.callFunc(function () {
            self._moveChipToBanker();
        }), cc.callFunc(function () {
            self._showBankerMoneyFinish(params.banker);
        }), cc.callFunc(function () {
            self._addResult(params.dices);
        }), cc.callFunc(function () {
            self._clearPlayerInPot();
        }), cc.delayTime(2), cc.callFunc(function () {
            self._clearEfectFinish();
        }));
        this.node.runAction(action);
    },

    _addResult: function _addResult(params) {
        var self = this;
        var result = 0;
        for (var i = 0; i < params.length; i += 1) {
            result += params[i];
        }
        var resultPre;
        var resultInt = result % 2;

        if (resultInt === 0) {
            resultPre = cc.instantiate(this.resultTrang);
        } else {
            resultPre = cc.instantiate(this.resultXanh);
        }
        if (self.gridResult.childrenCount === 32) {
            self.gridResult.removeAllChildren();
        }
        self.gridResult.addChild(resultPre);
    },

    _clearEfectFinish: function _clearEfectFinish() {
        for (var i = 0; i < this.playerNodeList.length; i += 1) {
            this.playerNodeList[i].clearEffects();
        }
    },

    _moveChipToPlayer: function _moveChipToPlayer(player, createPosition, money) {
        var chip, playerParent, chipComponent;
        this.audioManager.playChipBay();
        for (var i = 0; i < 3; i += 1) {

            if (Utils.Type.isString(player)) {
                playerParent = this.findPlayerNodeByName(player);
                if (playerParent) {
                    playerParent = playerParent.node;
                }
            } else {
                playerParent = player;
            }
            if (playerParent) {
                chip = cc.instantiate(this.chipPrefab);
                chip.parent = playerParent.parent;
                chip.position = createPosition;
                chipComponent = chip.getComponent('Chip');
                chipComponent.activeSelectChip(false);
                chipComponent.moneyLabel.node.active = false;
                chip.removeComponent('ButtonScaler');
                chip.removeComponent(cc.Button);
                chip.scale = cc.v2(0.5, 0.5);
                chipComponent.init(money);
                var action = cc.moveTo(0.8, cc.v2(playerParent.x, playerParent.y)).easing(cc.easeOut(2.0));
                chip.runAction(cc.sequence(cc.delayTime(i - i * 0.95), action, cc.callFunc(function () {
                    this.destroy();
                }, chip)));
            }
        }
    },

    _bankerPayChip: function _bankerPayChip(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            if (Object.keys(this.slotInfor[pots[i]].getComponent('SlotInfor').playerBetList).length > 0) {
                this._moveChipToPlayer(this.slotInfor[pots[i]], this.banker);
            }
        }
    },

    _payChipToPlayer: function _payChipToPlayer(pots) {
        for (var i = 0; i < pots.length; i += 1) {
            var slot = this.slotInfor[pots[i]].getComponent('SlotInfor');
            this._findPlayerWinInSlost(slot.playerBetList, pots[i]);
        }
    },

    _moveChipToBanker: function _moveChipToBanker() {
        var self = this;
        for (var i = 0; i < self.slotInfor.length; i += 1) {
            var slotComponent = this.slotInfor[i].getComponent('SlotInfor');
            if (!slotComponent.isWin) {
                if (slotComponent.chipFackeList.length > 0) {
                    this._moveChipToPlayer(self.banker, self.slotInfor[i]);
                }
            }
        }
    },

    _findPlayerWinInSlost: function _findPlayerWinInSlost(player, pot) {
        var self = this;
        var slotComponent = self.slotInfor[pot].getComponent('SlotInfor');
        slotComponent.destroyChipFacke();
        var arr = Object.keys(player);
        for (var i = 0; i < arr.length; i += 1) {
            self._moveChipToPlayer(arr[i], self.slotInfor[pot]);
        }
    },

    _setKetQua: function _setKetQua(params) {
        this._activeSellCancelPot(false);
        for (var i = 0; i < params.length; i += 1) {
            this.nhiKetQuaList[i].spriteFrame = this.spriteFrameKetQua[params[i]];
        }
    },

    _showSlostWin: function _showSlostWin(params) {
        for (var i = 0; i < params.length; i += 1) {
            var slot = this.slotInfor[params[i]].getComponent('SlotInfor');
            slot.showEfectWin(true);

            slot.isWin = true;
        }
    },

    _disableEfectSlostWin: function _disableEfectSlostWin() {
        for (var i = 0; i < this.slotInfor.length; i += 1) {
            var slot = this.slotInfor[i].getComponent('SlotInfor');
            slot.showEfectWin(false);
            slot.isWin = false;
        }
    },

    _showMoneyFinish: function _showMoneyFinish(params) {
        for (var i = 0; i < params.length; i += 1) {
            var player = this.findPlayerNodeByName(params[i].userName);
            if (player) {
                player.setFinishEffect(params[i].moneyExchange);
                if (params[i].userName === AuthUser.username) {
                    if (params[i].moneyExchange > 0) {
                        this.audioManager.playWin();
                    } else {
                        this.audioManager.playLose();
                    }
                }
            }
        }
    },

    _showBankerMoneyFinish: function _showBankerMoneyFinish(params) {
        if (params.userName !== undefined) {
            var banker = this.findPlayerNodeByName(params.userName);
            if (banker) {
                //banker = banker.getComponent('PlayerUI');
                banker.setFinishEffect(params.moneyExchange);
            }
        }
    },

    _clearPlayerInPot: function _clearPlayerInPot() {
        var self = this;
        for (var i = 0; i < self.slotInfor.length; i += 1) {
            var slotComponent = self.slotInfor[i].getComponent('SlotInfor');
            slotComponent.playerBetList = {};
            slotComponent.totallMoneyLong = 0;
            slotComponent.myMoneyLong = 0;
            slotComponent.potX = 0;
            slotComponent.setMoneyPot(0, 0);
            slotComponent.destroyChipFacke();
        }
    },

    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 3, username: "phamvanthien25554"}
        var chip,
            playerParent = this.findPlayerNodeByName(params.username),
            chipComponent,
            slotComponent,
            isInit = false,
            myMoney = 0;
        chip = cc.instantiate(this.chipPrefab);
        if (playerParent) {
            chip.parent = playerParent.node.parent;
            chip.position = playerParent.node;
        }
        chipComponent = chip.getComponent('Chip');
        chipComponent.activeSelectChip(false);
        chip.scale = cc.v2(0.5, 0.5);
        for (var i = 0; i < this.gameManager.bettingList.length; i++) {
            if (this.gameManager.bettingList[i] == params.money) {
                chipComponent.init(params.money, XocDiaConstant.ChipColor.findById(i).NAME);
                isInit = true;
                break;
            }
        }
        if (!isInit) {
            chipComponent.moneyLabel.node.active = false;
            chipComponent.init(params.money);
        }
        chipComponent = chip.getComponent(cc.Button);
        chipComponent.enabled = false;
        chip.removeComponent('ButtonScaler');
        slotComponent = this.slotInfor[params.pot].getComponent('SlotInfor');
        slotComponent.init();
        if (params.username === AuthUser.username) {
            myMoney = params.money;
            this.btnX2.interactable = true;
            this.btnCancelBet.interactable = true;
        }
        slotComponent.setMoneyPot(myMoney, params.money);
        slotComponent.addPlayerBetToPot(params.username, params.money);
        for (var j = 0; j < this.gameManager.bettingList.length; j++) {
            if (this.gameManager.bettingList[j] == params.money) {
                var newVec1 = this.slotInfor[params.pot].getChildByName(j.toString()).convertToWorldSpace(cc.v2(0, 0));
                var newVec2 = this.node.convertToNodeSpaceAR(newVec1);
                var moveChip = cc.moveTo(0.3, newVec2).easing(cc.easeOut(2.0));
                chip.runAction(cc.sequence(moveChip, cc.callFunc(function () {
                    this.destroy();
                    slotComponent.caculateChip();
                }, chip)));
            }
        }
        this.audioManager.playChipBay();
    },

    onShakeBow: function onShakeBow() {
        this._disableEfectSlostWin();
        var self = this;

        var anim = this.bowDice.getComponent(cc.Animation);
        var action = cc.sequence(cc.callFunc(self._closeBow()), cc.delayTime(1.5), cc.callFunc(function () {
            if (self.bow.position.x > 0) {
                self.bow.position = cc.v2(0, 0);
            }
            anim.play('Shake');
            self.xocAudioId = self.audioManager.playXoc(true);
        }, this));
        this.bow.runAction(action);
        for (var i = 0; i < this.slotInfor.length; i += 1) {
            var potComponent = this.slotInfor[i].getComponent('SlotInfor');
            potComponent.showEfectWin(false);
        }
    },

    clickReBet: function clickReBet() {
        this.gameManager.sendReBet();
    },

    clickDoubleBet: function clickDoubleBet() {
        this.gameManager.sendDoubleBet();
    },

    clickCancelBet: function clickCancelBet() {
        this.gameManager.sendCancelBet();
    },

    clickRequestBanker: function clickRequestBanker() {
        this.gameManager.sendRequestBanker();
    },

    _openBow: function _openBow() {
        var action = cc.moveTo(1, cc.p(-90, 0)).easing(cc.easeOut(2.0));
        this.bow.runAction(action);
        this.timeCountDow.node.active = false;
        this.timeLabel.node.active = false;
    },

    _closeBow: function _closeBow() {

        var action = cc.moveTo(1, cc.p(0, 0));
        this.bow.runAction(action);
    },

    _playerBettingState: function _playerBettingState(params) {
        this._showTimeState(params.time);
    },

    _showTimeCountDow: function _showTimeCountDow(params) {
        this.timeLabel.string = params;
    },

    _addChipBetting: function _addChipBetting(params) {
        var chipSelect,
            self = this,
            chipComponent;
        this.audioManager.playChipBay();
        this.parentChipBetting.removeAllChildren();
        for (var i = 0; i < params.length; i += 1) {
            chipSelect = cc.instantiate(this.chipPrefab);
            this.listChipBetting.push(chipSelect);
            chipComponent = chipSelect.getComponent('Chip');
            chipComponent.init(params[i], XocDiaConstant.ChipColor.findById(i).NAME);
            chipSelect.on(cc.Node.EventType.TOUCH_START, function () {
                this.activeSelectChip(true);
                self._selectChip(this.node);
            }, chipComponent);
            this.parentChipBetting.addChild(chipSelect);
        }
        this._selectChip(this.listChipBetting[0]);
    },

    _removeSelectChip: function _removeSelectChip() {
        for (var i = 0; i < this.listChipBetting.length; i += 1) {
            var chip = this.listChipBetting[i].getComponent('Chip');
            chip.activeSelectChip(false);
        }
    },

    _selectChip: function _selectChip(chipSelect) {
        this._removeSelectChip();
        var chip = chipSelect.getComponent('Chip');
        chip.activeSelectChip(true);
        this.moneyBetSelect = chip.money;
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","GameConstant":"GameConstant","GameManagerConstant":"GameManagerConstant","Utils":"Utils","XocDiaConstant":"XocDiaConstant"}],"GiftCode":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'acf5blDJupB757lvldHya+3', 'GiftCode');
// scripts\components\kiem_xu\GiftCode.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        infoLabel: cc.Label,

        giftCodeEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {},

    getGiftCodeInfo: function getGiftCodeInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.GIFT_CODE, {}, {
            cache: 1800
        }).success(function (respDone) {
            that.infoLabel.string = respDone.data.note;
        });
    },

    confirmGiftCode: function confirmGiftCode(event) {
        var invite_code = this.giftCodeEditBox.string;
        if (!invite_code) {
            return UiManager.openModal('Vui lòng nhập mã giftcode');
        }
        NetworkManager.Http.fetch('POST', Url.Http.GIFT_CODE, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            pin: invite_code
        }).setWaitingButton(event.target);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"Hall":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'bd2ef48uEVJG4GgrfA5n4pV', 'Hall');
// scripts\components\Hall.js

var GameItem = require('GameItem'),
    UiManager = require('UiManager'),
    GameManager = require('GameManager'),
    GameConstant = require('GameConstant'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    TopPanelOutGameWrapper = require('TopPanelOutGameWrapper');

cc.Class({
    'extends': TopPanelOutGameWrapper,

    properties: {
        gameItemPrefab: cc.Prefab,
        listGameScrollView: cc.ScrollView
    },

    // use this for initialization
    onLoad: function onLoad() {
        TopPanelOutGameWrapper.prototype.onLoad.call(this);

        this.updateGameList();

        EventDispatcher.addEventListener(EventDispatcherConstant.GAME.UPDATE_LIST, this.updateGameList, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.GAME.UPDATE_LIST, this.updateGameList, this);
    },

    openNapXien: function openNapXien() {
        UiManager.openNapXienModal();
    },

    openTopUsers: function openTopUsers() {
        UiManager.openTopUsersModal();
    },

    openDoiThuong: function openDoiThuong() {
        UiManager.openPopupDoiThuong();
    },

    openDaiLy: function openDaiLy() {
        UiManager.openPopupDaiLy();
    },

    openKiemXu: function openKiemXu() {
        UiManager.openPopupKiemXu();
    },

    openSettings: function openSettings() {
        UiManager.openPopupSettings();
    },

    updateGameList: function updateGameList() {
        var gameItem,
            gameGroup,
            game,
            gameGroups = [],
            i,
            gamePriorities = GameConstant.getGamePriorities();
        if (this.listGameScrollView) {
            for (i = 0; i < GameManager.GAME_GROUP_LIST.length; i += 1) {
                gameGroup = GameManager.GAME_GROUP_LIST[i];
                if (gameGroup && gameGroup.length > 0) {
                    game = gameGroup[0];
                    if (game && game.CONFIG && game.CONFIG.IS_MINIGAME && GameManager.isSmartFoxGame(game)) {
                        continue;
                    }
                    gameGroups.push(gameGroup);
                }
            }

            gameGroups.sort(function (g1, g2) {
                return gamePriorities[g1[0].gameId] - gamePriorities[g2[0].gameId];
            });
            this.listGameScrollView.content.removeAllChildren();
            for (i = 0; i < gameGroups.length; i += 1) {
                gameItem = cc.instantiate(this.gameItemPrefab);
                gameItem.getComponent(GameItem).init(gameGroups[i]);
                this.listGameScrollView.content.addChild(gameItem);
            }
            this.listGameScrollView.scrollToTopLeft();
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","GameItem":"GameItem","GameManager":"GameManager","TopPanelOutGameWrapper":"TopPanelOutGameWrapper","UiManager":"UiManager"}],"HelpMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'edfbaK3mhlJQbX8ssY2bqXY', 'HelpMiniPoker');
// scripts\components\games\mini_poker\HelpMiniPoker.js

var Url = require('Url'),
    GameConstant = require('GameConstant'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        lblTextHelp: cc.Label,
        scrollView: cc.ScrollView
    },

    onLoad: function onLoad() {
        this.scrollView.node.active = false;
        NetworkManager.Http.fetch('GET', Url.Http.GAME_HELP, {
            game_id: GameConstant.MINI_POKER.ID
        }, {
            cache: 900,
            delay: 500
        }).success((function (results) {
            if (results) {
                if (!this.isValid) {
                    return;
                }

                this.scrollView.node.active = true;
                this.lblTextHelp.string = results.data.content;
            }
        }).bind(this));
    }
});

cc._RFpop();
},{"GameConstant":"GameConstant","NetworkManager":"NetworkManager","Url":"Url"}],"HistorySanThuong":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a7e96aB1itNKroheqFOFWz/', 'HistorySanThuong');
// scripts\components\games\san_thuong\HistorySanThuong.js

var Pagination = require('Pagination');

cc.Class({
    'extends': cc.Component,

    properties: {
        pagination: Pagination,
        historyItemTemplateNode: cc.Node,
        historyListNode: cc.Node,
        historyListScrollView: cc.ScrollView,
        maxRows: 10
    },

    onLoad: function onLoad() {
        this.historyListScrollView.node.active = false;
        this.historyListNode.runAction(cc.sequence(cc.delayTime(0.3), cc.callFunc((function () {
            this.historyListScrollView.node.active = true;
        }).bind(this))));
    },

    init: function init(historyList) {
        if (historyList) {
            var nPages = Math.ceil(historyList.length / 10),
                pageList = [],
                i;

            this.historyList = historyList;

            for (i = 1; i <= nPages; i += 1) {
                pageList.push(i);
            }

            this.selectPage({
                page: 1
            });
            this.pagination.init({
                pageList: pageList,
                currentPage: 1
            }, this.selectPage.bind(this));
        }
    },

    selectPage: function selectPage(pageInfo) {
        if (this.historyList && pageInfo) {
            var page = pageInfo.page - 1,
                startIndex = page * this.maxRows,
                historyListInPage = this.historyList.slice(startIndex, startIndex + this.maxRows),
                labelListNode,
                item,
                node,
                i;

            this.historyListNode.removeAllChildren();

            for (i = 0; i < historyListInPage.length; i += 1) {
                node = cc.instantiate(this.historyItemTemplateNode);
                node.active = true;

                item = historyListInPage[i];

                labelListNode = node.getComponentsInChildren(cc.Label);
                labelListNode[0].string = item[0];
                labelListNode[1].string = item[1];
                labelListNode[2].string = item[2];
                labelListNode[3].string = item[3];
                labelListNode[4].string = item[4];
                this.historyListNode.addChild(node);
            }
        }
    }

});

cc._RFpop();
},{"Pagination":"Pagination"}],"HistoryTableMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, '12301Ua6UZF+qnbcwQspV/e', 'HistoryTableMiniPoker');
// scripts\components\games\mini_poker\HistoryTableMiniPoker.js

var Utils = require('Utils'),
    Pagination = require('Pagination'),
    CommonConstant = require('CommonConstant'),
    MiniPokerConstant = require('MiniPokerConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemPrefab: {
            'default': null,
            type: cc.Prefab
        },
        contentItem: cc.Node,
        scrollView: cc.ScrollView,
        pagination: Pagination,
        maxRow: 10
    },

    onLoad: function onLoad() {
        this.scrollView.node.active = false;
        this.contentItem.runAction(cc.sequence(cc.delayTime(0.3), cc.callFunc((function () {
            this.scrollView.node.active = true;
        }).bind(this))));
    },

    init: function init(historyList) {
        if (historyList) {
            this.historyList = historyList;
            var nPage = Math.ceil(historyList.length / this.maxRow),
                pageList = [];
            for (var i = 0; i < nPage; i += 1) {
                pageList.push(i + 1);
            }
            this.selectPage({ page: 1 });
            this.pagination.init({
                pageList: pageList,
                currentPage: 1
            }, this.selectPage.bind(this));
        }
    },

    selectPage: function selectPage(pageInfo) {
        if (this.historyList && pageInfo) {
            var page = pageInfo.page - 1,
                startIndex = page * this.maxRow,
                historyListInPage = this.historyList.slice(startIndex, startIndex + this.maxRow);

            this.contentItem.removeAllChildren();

            for (var i = 0; i < historyListInPage.length; i += 1) {
                var historyData = historyListInPage[i];
                var currencyName = historyData.currency === CommonConstant.CurrencyType.Ip.NAME ? CommonConstant.CurrencyType.Ip.DISPLAY_NAME : CommonConstant.CurrencyType.Xu.DISPLAY_NAME;
                var itemNode = cc.instantiate(this.itemPrefab);
                itemNode.getChildByName('1').getComponent(cc.Label).string = i + 1;
                itemNode.getChildByName('2').getComponent(cc.Label).string = historyData.time;
                itemNode.getChildByName('3').getComponent(cc.Label).string = historyData.moneyBet + ' ' + currencyName;
                itemNode.getChildByName('4').getComponent(cc.Label).string = historyData.potWin > 0 ? MiniPokerConstant.getPotName(historyData.potWin) : 'Thua';
                itemNode.getChildByName('5').getComponent(cc.Label).string = Utils.Number.format(historyData.moneyExchange) + ' ' + currencyName;
                itemNode.enabled = true;
                this.contentItem.addChild(itemNode);
            }
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","MiniPokerConstant":"MiniPokerConstant","Pagination":"Pagination","Utils":"Utils"}],"HistoryTableTaiXiu":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5235d75aq5J+q1CrvAKfQdX', 'HistoryTableTaiXiu');
// scripts\components\games\tai_xiu\HistoryTableTaiXiu.js

var Pagination = require('Pagination'),
    CommonConstant = require('CommonConstant'),
    TaiXiuConstant = require('TaiXiuConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        pagination: Pagination,
        historyItemTemplateNode: cc.Node,
        historyListNode: cc.Node,
        historyListScrollView: cc.ScrollView,
        maxRows: 10
    },

    onLoad: function onLoad() {
        this.historyListScrollView.node.active = false;
        this.historyListNode.runAction(cc.sequence(cc.delayTime(0.3), cc.callFunc((function () {
            this.historyListScrollView.node.active = true;
        }).bind(this))));
    },

    init: function init(historyList) {
        if (historyList) {
            var nPages = Math.ceil(historyList.length / 10),
                pageList = [],
                i;

            this.historyList = historyList;

            for (i = 1; i <= nPages; i += 1) {
                pageList.push(i);
            }

            this.selectPage({
                page: 1
            });
            this.pagination.init({
                pageList: pageList,
                currentPage: 1
            }, this.selectPage.bind(this));
        }
    },

    selectPage: function selectPage(pageInfo) {
        if (this.historyList && pageInfo) {
            var page = pageInfo.page - 1,
                startIndex = page * this.maxRows,
                historyLength = this.historyList.length,
                historyListInPage = this.historyList.slice(startIndex, startIndex + this.maxRows),
                labelListNode,
                currencyType,
                potBettingMap,
                item,
                node,
                pot,
                s1,
                s2,
                i;

            this.historyListNode.removeAllChildren();

            for (i = 0; i < historyListInPage.length; i += 1) {
                node = cc.instantiate(this.historyItemTemplateNode);
                node.active = true;

                item = historyListInPage[i];
                currencyType = CommonConstant.CurrencyType.findByName(item.currency);
                potBettingMap = item.potBettingMap;
                s1 = '';
                s2 = '';
                for (pot in potBettingMap) {
                    s1 += TaiXiuConstant.Pot.findById(pot).NAME + '\n';
                    s2 += potBettingMap[pot] + ' ' + currencyType.DISPLAY_NAME + '\n';
                }
                s1 = s1.trim();
                s2 = s2.trim();

                labelListNode = node.getComponentsInChildren(cc.Label);
                labelListNode[0].string = historyLength - this.maxRows * page - i;
                labelListNode[1].string = item.time;
                labelListNode[2].string = s1;
                labelListNode[3].string = s2;
                labelListNode[4].string = TaiXiuConstant.Pot.findById(item.potWin).NAME;
                labelListNode[5].string = item.moneyExchange + ' ' + currencyType.DISPLAY_NAME;
                this.historyListNode.addChild(node);
            }
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","Pagination":"Pagination","TaiXiuConstant":"TaiXiuConstant"}],"HopquaInfor":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3b15ctrIaRGEZTJ2RI3OQWl', 'HopquaInfor');
// scripts\components\games\san_thuong\HopquaInfor.js

cc.Class({
    'extends': cc.Component,

    properties: {
        hopMoSprite: cc.Sprite,
        efectSprite: cc.Sprite,
        textPhanThuong: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    init: function init(id) {
        this.id = id;
    },

    openHopQua: function openHopQua(value) {
        cc.warn(value + ' value ' + this.id);
        this.node.getComponent(cc.Sprite).enabled = false;
        this.hopMoSprite.node.active = true;
        this.efectSprite.node.active = true;
        this.textPhanThuong.node.active = true;
        this.textPhanThuong.string = value;
    }
});

cc._RFpop();
},{}],"HotEventTrigger":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'dda3cULDWNGsqbL7GqDXEGE', 'HotEventTrigger');
// scripts\components\hot_event\HotEventTrigger.js

var Url = require('Url'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager');

var lastOpen = null,
    TTL = 3600 * 2 * 1000;

cc.Class({
    'extends': cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        var now = new Date().getTime();
        if (lastOpen + TTL > now) {
            return;
        }
        lastOpen = now;
        NetworkManager.Http.fetch('GET', Url.Http.BANNER, {}, {
            cache: 3600
        }).success(function (tnResp) {
            if (tnResp.data && tnResp.data.length > 0) {
                UiManager.openPopupHotEvent();
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"HotEvent":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3ad9cx0WThJrK1bhY5zBhHj', 'HotEvent');
// scripts\components\hot_event\HotEvent.js

var Url = require('Url'),
    UrlImage = require('UrlImage'),
    Carousel = require('Carousel'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    PlatformImplement = require('PlatformImplement');

cc.Class({
    'extends': cc.Component,

    properties: {
        bannerCarousel: Carousel
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.fetchBannerList();
    },

    fetchBannerList: function fetchBannerList() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.BANNER, {}, {
            cache: 3600
        }).success(function (tnResp) {
            var bannerItems = tnResp.data,
                bannerNode;

            that.bannerCarousel.clearAllTimes();
            for (var i = 0; i < bannerItems.length; i += 1) {
                bannerNode = that._initBannerNode(bannerItems[i]);
                that.bannerCarousel.addItem(bannerNode, !i);
            }
        });
    },

    openEventItem: function openEventItem(itemNode) {
        var target_url = itemNode.bannerData.target_url;
        if (target_url[0] === 'h') {
            PlatformImplement.openWebUrl(target_url);
        } else {
            target_url = JSON.parse(target_url);
            if (target_url.type === 'event') {
                UiManager.openPopupEvent(target_url.id);
            } else if (target_url.type === 'webview') {
                UiManager.openWebView(target_url.url, target_url.title);
            }
        }
    },

    _initBannerNode: function _initBannerNode(bannerData) {
        var bannerNode, spriteComponent, urlImageComponent;
        bannerNode = new cc.Node();
        spriteComponent = bannerNode.addComponent(cc.Sprite);
        spriteComponent.type = cc.Sprite.Type.SIMPLE;
        spriteComponent.sizeMode = cc.Sprite.SizeMode.CUSTOM;
        urlImageComponent = bannerNode.addComponent(UrlImage);
        urlImageComponent.url = bannerData.image_url;
        bannerNode.bannerData = bannerData;
        return bannerNode;
    }
});

cc._RFpop();
},{"Carousel":"Carousel","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","UiManager":"UiManager","Url":"Url","UrlImage":"UrlImage"}],"InviteCode":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7a983PK0fdIv4g/K9WMJWkz', 'InviteCode');
// scripts\components\kiem_xu\InviteCode.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        infoLabel: cc.Label,
        myInviteCodeLabel: cc.Label,

        inviteCodeEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {},

    getInviteCodeInfo: function getInviteCodeInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.INVITE_CODE, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }, {
            cache: 1800
        }).success(function (respDone) {
            that.infoLabel.string = respDone.info;
            that.myInviteCodeLabel.string = respDone.data;
        });
    },

    confirmInviteCode: function confirmInviteCode(event) {
        var invite_code = this.inviteCodeEditBox.string;
        if (!invite_code) {
            return UiManager.openModal('Vui lòng nhập mã giới thiệu');
        }
        NetworkManager.Http.fetch('POST', Url.Http.INVITE_CODE, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            invite_code: invite_code
        }).setWaitingButton(event.target);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"IplayHttp":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a33afOihq1I6a4Z/t7bnHbv', 'IplayHttp');
// scripts\network\IplayHttp.js

/*jslint bitwise: true */

var Utils = require('Utils'),
    FetchHandler;

FetchHandler = Utils.Class({

    setWaitingButton: function setWaitingButton(buttonNode) {
        this._buttonComponent = buttonNode.getComponent(cc.Button);
        this._buttonComponent.interactable = false;
        return this;
    },

    error: function error(callback) {
        if (callback) {
            this._error_callback = callback;
        }
        return this;
    },

    onError: function onError(xhr) {
        if (this._buttonComponent) {
            this._buttonComponent.interactable = true;
        }
        if (this._error_callback) {
            try {
                this._error_callback(xhr);
            } catch (e) {}
        }
    },

    success: function success(callback) {
        if (callback) {
            this._success_callback = callback;
        }
        return this;
    },

    onSuccess: function onSuccess(successData) {
        if (this._buttonComponent) {
            this._buttonComponent.interactable = true;
        }
        if (this._success_callback) {
            try {
                this._success_callback(successData);
            } catch (e) {}
        }
    }

});

if (!XMLHttpRequest.prototype.sendAsBinary) {
    XMLHttpRequest.prototype.sendAsBinary = function (sData) {
        var nBytes = sData.length,
            ui8Data = new Uint8Array(nBytes);
        for (var nIdx = 0; nIdx < nBytes; nIdx += 1) {
            ui8Data[nIdx] = sData.charCodeAt(nIdx) & 0xff;
        }
        this.send(ui8Data);
    };
}

module.exports = {
    init: function init(host, port, protocol, auth_user, auth_pass) {
        this.host = host;
        this.port = port;
        this.protocol = protocol || 'http';
        this.auth_user = auth_user || '';
        this.auth_pass = auth_pass || '';
        this._cache = {};
    },

    addInterceptor: function addInterceptor(interceptor) {
        if (!this.interceptors) {
            this.interceptors = [];
        }
        this.interceptors.push(interceptor);
    },

    _generateBoundary: function _generateBoundary() {
        return 'AJAX-----------------------' + new Date().getTime();
    },

    _hasFileUpload: function _hasFileUpload(params) {
        for (var name in params) {
            if (Utils.Type.isObject(params[name])) {
                return true;
            }
        }
        return false;
    },

    _buildMessage: function _buildMessage(params, boundary) {
        var CRLF = '\r\n';
        var parts = [],
            param;

        for (var name in params) {
            param = params[name];
            var part = '';

            if (Utils.Type.isObject(param)) {
                /*
                 * Content-Disposition header contains name of the field used
                 * to upload the file and also the name of the file as it was
                 * on the user's computer.
                 */
                part += 'Content-Disposition: form-data; ';
                part += 'name="' + name + '"; ';
                part += 'filename="' + param.fileName + '"' + CRLF;

                /*
                 * Content-Type header contains the mime-type of the file to
                 * send. Although we could build a map of mime-types that match
                 * certain file extensions, we'll take the easy approach and
                 * send a general binary header: application/octet-stream.
                 */
                part += 'Content-Type: application/octet-stream' + CRLF + CRLF;

                /*
                 * File contents read as binary data, obviously
                 */
                part += param.value + CRLF;
            } else {
                /*
                 * In case of non-files fields, Content-Disposition contains
                 * only the name of the field holding the data.
                 */
                part += 'Content-Disposition: form-data; ';
                part += 'name="' + name + '"' + CRLF + CRLF;

                /*
                 * Field value
                 */
                part += param + CRLF;
            }

            parts.push(part);
        }

        var request = '--' + boundary + CRLF;
        request += parts.join('--' + boundary + CRLF);
        request += '--' + boundary + '--' + CRLF;

        return request;
    },

    _getKeyCache: function _getKeyCache(method, path, params) {
        var keyCache = method + path;
        Object.keys(params).sort().forEach(function (key) {
            keyCache += '&' + key + '=' + params[key];
        });
        return keyCache;
    },

    resetCache: function resetCache() {
        this._cache = {};
    },

    fetch: function fetch(method, path, params, options) {
        var boundary,
            i,
            xhr,
            that = this,
            now = new Date().getTime(),
            fetchHandler = new FetchHandler(),
            keyCache = this._getKeyCache(method, path, params),
            url = this.protocol + '://' + this.host + ':' + this.port + path;

        options = options || {};
        if (options.cache > 0) {
            if (keyCache in this._cache && this._cache[keyCache].expire > now) {
                setTimeout(function () {
                    fetchHandler.onSuccess(that._cache[keyCache].data);
                }, options.delay || 0);
                return fetchHandler;
            }
        }

        xhr = new XMLHttpRequest();
        xhr.timeout = 120000; // time in milliseconds
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                var contentType = xhr.getResponseHeader('content-type');
                try {
                    if (contentType && contentType.indexOf('application/json') > -1) {
                        xhr.responseJson = JSON.parse(xhr.responseText);
                    }
                    for (i in that.interceptors) {
                        that.interceptors[i].response(xhr);
                    }
                    if (xhr.status >= 200 && xhr.status < 400) {
                        if (xhr.responseJson) {
                            if (xhr.responseJson.status === 1) {
                                fetchHandler.onSuccess(xhr.responseJson);

                                // cache data in seconds
                                if (options.cache > 0) {
                                    that._cache[keyCache] = {
                                        data: xhr.responseJson,
                                        expire: now + options.cache * 1000
                                    };
                                }
                            } else {
                                fetchHandler.onError(xhr);
                            }
                        } else {
                            cc.log('Iplay Http [response error]: no response');
                        }
                    } else {
                        fetchHandler.onError(xhr);
                    }
                } catch (err) {
                    cc.log('Iplay Http [response error]: ' + xhr.responseText);
                    cc.log(err);
                }
            }
        };
        for (i in that.interceptors) {
            that.interceptors[i].request.apply(null, arguments);
        }

        function send() {
            if (method === 'GET') {
                xhr.open(method, url + '?' + Utils.String.param(params), true, that.auth_user, that.auth_pass);
                xhr.send();
            } else {
                xhr.open(method, url, true, that.auth_user, that.auth_pass);
                if (that._hasFileUpload(params)) {
                    boundary = that._generateBoundary();
                    xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);
                    xhr.sendAsBinary(that._buildMessage(params, boundary));
                } else {
                    xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
                    xhr.send(Utils.String.param(params));
                }
            }
        }
        if (options.delay > 0) {
            setTimeout(send, options.delay);
        } else {
            send();
        }
        return fetchHandler;
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"ItemDaiLy":[function(require,module,exports){
"use strict";
cc._RFpush(module, '346f4PTE9hD67eitWOwOoUj', 'ItemDaiLy');
// scripts\components\dai_ly\ItemDaiLy.js

var PlatformImplement = require('PlatformImplement');

cc.Class({
    'extends': cc.Component,

    properties: {
        facebookNode: cc.Node
    },

    chuyenPi: function chuyenPi() {
        // not implement
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.chuyenPi);
    },

    updateData: function updateData(daiLyData) {
        if (daiLyData.fb_url) {
            this.facebookNode.on(cc.Node.EventType.TOUCH_END, function () {
                PlatformImplement.openWebUrl(daiLyData.fb_url);
            });
        } else {
            this.facebookNode.removeFromParent();
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"PlatformImplement":"PlatformImplement"}],"ItemEvent":[function(require,module,exports){
"use strict";
cc._RFpush(module, '12b9aLUaapMpauW0iloXyIP', 'ItemEvent');
// scripts\components\event\ItemEvent.js

cc.Class({
    'extends': cc.Component,

    properties: {
        titleLabel: cc.Label,
        contentLabel: cc.Label,
        timeLabel: cc.Label,
        eventTypeNode: cc.Node,
        fromToLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    closeDetailMessage: function closeDetailMessage() {
        // not implement, let other hook
    },

    updateData: function updateData(item) {
        this.item = item;
        this.titleLabel.string = item.subject;
        this.eventTypeNode.active = item.event_type === 'NEW' ? true : false;
        if (this.contentLabel) {
            this.contentLabel.string = item.content;
        }
        if (this.timeLabel) {
            this.timeLabel.string = item.created_time.replace(' ', '\n');
        }
        if (this.fromToLabel) {
            this.fromToLabel.string = 'Từ ngày ' + item.from_time + ' đến ngày ' + item.to_time;
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"ItemInapp":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'afbd3WWyHpPGpNxhEZ6hNyG', 'ItemInapp');
// scripts\components\nap_xien\ItemInapp.js

cc.Class({
    "extends": cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {}

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"ItemMessage":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a141bY2Gc1B7Lr8SnmNklgL', 'ItemMessage');
// scripts\components\message_box\ItemMessage.js

var MessageBoxCache = require('MessageBoxCache');

cc.Class({
    'extends': cc.Component,

    properties: {
        timeLabel: cc.Label,
        indexLabel: cc.Label,
        titleLabel: cc.Label,
        userLabel: cc.Label,
        contentLabel: cc.Label,
        deleteButton: cc.Button
    },

    // use this for initialization
    onLoad: function onLoad() {},

    deleteMessage: function deleteMessage() {
        // not implement, let other hook
    },

    replyToUser: function replyToUser() {
        // not implement, let other hook
    },

    closeDetailMessage: function closeDetailMessage() {
        // not implement, let other hook
    },

    updateData: function updateData(message, keyStorage) {
        var user_key = keyStorage.indexOf('ongoing') > 0 ? 'from' : 'to';
        this.keyStorage = keyStorage;
        this.messageId = message.msgid;
        this.titleLabel.string = message.subject;
        this.userLabel.string = message[user_key];

        if (this.deleteButton) {
            this.deleteButton.node.active = user_key === 'to' ? false : true;
        }
        if (this.contentLabel) {
            this.timeLabel.string = message.created_time;
            this.contentLabel.string = message.body || '';
        } else {
            this.timeLabel.string = message.created_time.replace(' ', '\n');
        }
        this.indexLabel.string = MessageBoxCache.getIndexMessage(keyStorage, message.msgid) + 1;
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"MessageBoxCache":"MessageBoxCache"}],"ItemTextMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, '329b0k8IfNPQZSTrH7BsBCH', 'ItemTextMiniPoker');
// scripts\components\games\mini_poker\ItemTextMiniPoker.js

cc.Class({
    "extends": cc.Component,

    properties: {},

    onLoad: function onLoad() {
        this.node.position = cc.v2(0, 0);
    },

    setColor: function setColor(color) {
        this.node.color = color;
    },

    setText: function setText(text) {
        this.node.getComponent(cc.Label).string = text;
    }
});

cc._RFpop();
},{}],"ItemThe":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7c7efwrEXxPLot50PPbXaWS', 'ItemThe');
// scripts\components\nap_xien\ItemThe.js

var UrlImage = require('UrlImage');

cc.Class({
    'extends': cc.Component,

    properties: {
        tcaoImage: UrlImage
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(data) {
        this.tcaoImage.loadImage(data.img);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"UrlImage":"UrlImage"}],"ItemTinNhan":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'af09fMhNNNLma5inLf2tsLP', 'ItemTinNhan');
// scripts\components\nap_xien\ItemTinNhan.js

var CommonConstant = require('CommonConstant'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        vndLabel: cc.Label,
        ipLabel: cc.Label,
        sampleLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(data) {
        this.vndLabel.string = Utils.Number.format(data.fee) + ' VND';
        this.ipLabel.string = Utils.Number.format(data.gold_value) + ' ' + CommonConstant.CurrencyType.Ip.DISPLAY_NAME;
        this.sampleLabel.string = data.sms_sample;
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"CommonConstant":"CommonConstant","Utils":"Utils"}],"ItemTopUser":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4ce22fTrLhKOIhg1Jvz/iF/', 'ItemTopUser');
// scripts\components\top_users\ItemTopUser.js

var UrlImage = require('UrlImage'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        avatarImage: UrlImage,
        numberLabel: cc.Label,
        usernameRichText: cc.RichText,
        scoreLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(index, itemData) {
        var username_text = itemData.username.split('(');
        this.numberLabel.string = index;
        this.avatarImage.loadImage(itemData.avatar);
        this.usernameRichText.string = '<color=#FFD600>' + username_text[0].trim() + '</color>';
        if (username_text.length > 1) {
            if (username_text[0].length < 26) {
                this.usernameRichText.string += '\n';
            } else {
                this.usernameRichText.string += ' ';
            }
            this.usernameRichText.string += '<size=24>' + username_text[1].trim().replace(')', '') + '</size>';
        }
        this.scoreLabel.string = Utils.Number.format(itemData.experience || itemData.score);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"UrlImage":"UrlImage","Utils":"Utils"}],"ItemTopWinGame":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1afe6CV4dZC3rkHaWQgnHH/', 'ItemTopWinGame');
// scripts\components\games\top_win_game\ItemTopWinGame.js

var UrlImage = require('UrlImage'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        avatarImage: UrlImage,
        usernameLabel: cc.Label,
        scoreLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(itemData) {
        var matches = itemData.username.match(/^([^\(]+)\s*(?:\((.*)\)\s*)?$/),
            username = (matches[1] || '').trim(),
            MAX_USERNAME_LENGTH = 13,
            USERNAME_SUFFIX = '...';

        if (username.length > MAX_USERNAME_LENGTH) {
            username = username.substr(0, MAX_USERNAME_LENGTH - USERNAME_SUFFIX.length) + USERNAME_SUFFIX;
        }

        this.avatarImage.loadImage(itemData.avatar);

        this.shortName = username;
        this.longName = itemData.username;

        this.shortScore = Utils.Number.abbreviate(itemData.score);
        this.longScore = Utils.Number.format(itemData.score);

        this.scoreLabelFontSize = this.scoreLabel.fontSize;

        this.useShortInfo();
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    useShortInfo: function useShortInfo() {
        this.usernameLabel.string = this.shortName;

        this.scoreLabel.fontSize = this.scoreLabelFontSize * 0.9;
        this.scoreLabel.string = this.shortScore;
    },

    useLongInfo: function useLongInfo() {
        this.usernameLabel.string = this.longName;

        this.scoreLabel.fontSize = this.scoreLabelFontSize;
        this.scoreLabel.string = this.longScore;
    }
});

cc._RFpop();
},{"UrlImage":"UrlImage","Utils":"Utils"}],"ItemVatPham":[function(require,module,exports){
"use strict";
cc._RFpush(module, '98941TB8lZOGYuU9Ehcc+WY', 'ItemVatPham');
// scripts\components\doi_thuong\ItemVatPham.js

var CommonConstant = require('CommonConstant'),
    UrlImage = require('UrlImage'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        imgVatPham: UrlImage,
        nameLabel: cc.Label,
        moneyLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(data) {
        this.nameLabel.string = data.name;
        this.moneyLabel.string = Utils.Number.format(data.amount) + ' ' + CommonConstant.CurrencyType.findByName(data.currency).DISPLAY_NAME;
        if (this.imgVatPham) {
            this.imgVatPham.loadImage(data.url);
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"CommonConstant":"CommonConstant","UrlImage":"UrlImage","Utils":"Utils"}],"LichSuDoi":[function(require,module,exports){
"use strict";
cc._RFpush(module, '092a9gx3AdO7q2YDLwq9Zee', 'LichSuDoi');
// scripts\components\doi_thuong\LichSuDoi.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemLichSuPrefab: cc.Prefab,
        lichSuTheContainerNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    getLichSuThe: function getLichSuThe() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.DOI_THUONG_CARDS_HISTORY, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }).success(function (respDone) {
            var lichSuTheNode,
                i,
                col1,
                col2,
                col3,
                col4,
                cards = respDone.data;
            that.lichSuTheContainerNode.removeAllChildren();
            for (i = 0; i < cards.length; i += 1) {
                lichSuTheNode = cc.instantiate(that.itemLichSuPrefab);
                col1 = cards[i].created_time.replace(' ', '\n');
                col2 = cards[i].card_serial;
                col3 = cards[i].card_pin;
                col4 = cards[i].card_type + '\n' + cards[i].card_amount;
                lichSuTheNode.getComponent('RowTable').updateData(col1, col2, col3, col4);
                that.lichSuTheContainerNode.addChild(lichSuTheNode);
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","Url":"Url"}],"LiengConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2018ctzpttCzb5OSQGOdlog', 'LiengConstant');
// scripts\games\lieng\LiengConstant.js

var Utils = require('Utils');

module.exports = {
    GameType: {
        FIVE_CARDS: {
            ID: 0,
            NUMBER_OF_CARDS: 5
        },
        SEVEN_CARDS: {
            ID: 1,
            NUMBER_OF_CARDS: 7
        },

        findById: function findById(gameTypeId) {
            return Utils.Object.findObject(this, 'ID', gameTypeId);
        }
    },

    Action: {
        BET: 1,
        RAISE: 2,
        ALL_IN: 3,
        ALL_HAND: 31,
        CALL: 4,
        CHECK: 5,
        FOLD: 6,
        CHANGE_STATE: 7,
        CHANGE_TURN: 8,
        BUY_PRIVATE_MONEY: 9,
        BUY_PRIVATE_MONEY_REQUIRED: 10,
        END_TURN: 11,
        BET_1_2: 12,
        CUT_OFF_MONEY_POKER: 12,
        BET_1_4: 13,
        BET_X2: 14,
        CHOOSE_PUBLIC_CARD: 15
    },

    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        FINALIZING: 6,
        FINISH: 7,
        ROUND: 8
    },

    GameStatePoker: {
        PREFLOP: 8,
        FLOP: 9,
        TURN: 10,
        RIVER: 11
    },

    PlayerState: {
        NONE: 0,
        IN_TURN: 1,
        WAITING_FOR_TURN: 2,
        FOLDED: 3,
        ALL_IN: 4,
        OFF_MONEY: 5
    },

    Event: {
        START_TIME: 'in_game.xito.start_time',
        USER_BET: 'in_game.xito.user_bet',
        CHANGE_STATE: 'in_game.xito.change_state',
        CHANGE_TURN: 'in_game.xito.change_turn',
        UPDATE_MONEY: 'in_game.xito.update_money',
        SHOW_CARD_OPEN: 'in_game.xito.show_card_open',
        DRAW_CARD: 'in_game.xito.draw_card',
        FINISH_GAME: 'in_game.xito.finish_game',
        UPDATE_GAME: 'in_game.xito.update_game',
        REFRESH_GAME: 'in_game.xito.refresh_game',
        SHOW_BUY_CHIP: 'in_game.poker.show_buy_chip',
        HIDE_BUY_CHIP_BUTTON: 'in_game.poker.hide_buy_chip_button'
    },

    TimeoutId: {
        SHOW_COMMUNITY_CARDS: 'TIMEOUT_SHOW_COMMUNITY_CARDS'
    },

    Effect: {
        TO: 0,
        THEO: 1,
        NHUONG_TO: 2,
        UP_BO: 3,
        CHOI_TAT_TAY: 4,
        TO_12: 5,
        TO_14: 6,
        TO_X2: 7,
        TO_TAT_CA: 8,
        DANG_DOI: 9

    }

};

cc._RFpop();
},{"Utils":"Utils"}],"LiengGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd14fdGdG+FNhaKwWJXL0V0f', 'LiengGameManager');
// scripts\games\lieng\LiengGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    LiengConstant = require('LiengConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    LiengGameManager;

LiengGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this._setGameState(LiengConstant.GameState.NONE);

        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaittingDealCard, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.NEW_MATCH.ID, this.restartGame, this);

        // các action của game play
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.BET, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.ALL_IN, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.CALL, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.CHECK, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.FOLD, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.RAISE, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.CHANGE_STATE, this.onChangeStateGame, this);
        this.eventDispatchers.playCmd.addEventListener(LiengConstant.Action.CHANGE_TURN, this.onChangeTurn, this);
    },

    // ============================================================
    // Send API
    // ============================================================
    bet: function bet(betting, moneyBetting) {
        if (moneyBetting) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(betting),
                money: NetworkManager.SmartFox.type.long(moneyBetting)
            });
        } else {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(betting)
            });
        }
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.currency = params.data.currency;
        this.roomBetting = params.data.betting;
        this._setGameState(params.data.gameState);

        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.UPDATE_GAME, params);
        this.onUpdateHand();
    },

    onUpdateHand: function onUpdateHand() {
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.DRAW_CARD);
    },

    onPlayerBetting: function onPlayerBetting(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.USER_BET, params);
    },

    onWaittingDealCard: function onWaittingDealCard(params) {
        this._setGameState(params.allData.gameState);
        var dt = 0;
        if (params.__execInfo__) {
            dt = params.__execInfo__.dt;
        }
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.START_TIME, params.data.time - dt);
    },

    onChangeStateGame: function onChangeStateGame(params) {
        this.currentRound = params.allData.currentRound;
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.CHANGE_STATE, params);
        this.onUpdateHand();
    },

    onChangeTurn: function onChangeTurn(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.CHANGE_TURN, params);
    },

    onFinishGame: function onFinishGame(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.FINISH_GAME, params);
    },

    restartGame: function restartGame() {
        this.eventDispatchers.local.dispatchEvent(LiengConstant.Event.REFRESH_GAME);
    },

    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
        }
    }
});

// ============================================================
// Action API
// ============================================================

module.exports = LiengGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","LiengConstant":"LiengConstant","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"Loading":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0f573VTnJtKYp3ulE7H0BI/', 'Loading');
// scripts\ui\Loading.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.stopPropagationOnNode = Utils.Node.stopPropagation(this.node);
    },

    onDisable: function onDisable() {
        if (this.stopPropagationOnNode) {
            this.stopPropagationOnNode();
            this.stopPropagationOnNode = null;
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"Utils":"Utils"}],"Lobby":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'eb089qYTdRLk5d/MXZymigt', 'Lobby');
// scripts\components\games\lobby\Lobby.js

var GameManager = require('GameManager'),
    NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant'),
    BaseGameOptionModal = require('BaseGameOptionModal'),
    AudioManager = require('AudioManager'),
    UiManager = require('UiManager'),
    EventDispatcher = require('EventDispatcher'),
    GameManagerConstant = require('GameManagerConstant'),
    TopPanelOutGameWrapper = require('TopPanelOutGameWrapper'),
    PlatformImplement = require('PlatformImplement'),
    Url = require('Url'),
    Utils = require('Utils'),
    TOP_WIN_GAME_ANIMATION = 'TopWinGamePanel',
    TOP_WIN_GAME_REVERSED_ANIMATION = 'TopWinGamePanelReversed';

cc.Class({
    'extends': TopPanelOutGameWrapper,

    properties: {
        gameNameLabel: cc.Label,

        ipRoomTypeNode: cc.Node,
        xuRoomTypeNode: cc.Node,

        bettingSectionNode: cc.Node,
        bettingItemContainer: cc.Node,
        bettingItemListScrollView: cc.ScrollView,
        ipBettingItemTemplateNode: cc.Node,
        xuBettingItemTemplateNode: cc.Node,

        fakeBettingSectionNode: cc.Node,
        fakeCenterInBettingSectionNode: cc.Node,
        joinRoomLoadingSection: cc.Node,

        getBettingsLoadingSection: cc.Node,

        rightPanelNode: cc.Node,
        topWinGameContainerNode: cc.Node,
        topWinGameScrollView: cc.ScrollView,
        itemTopWinGamePrefab: cc.Prefab,

        chatLogScrollView: cc.ScrollView,
        chatLogLabel: cc.RichText,

        chatEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {
        TopPanelOutGameWrapper.prototype.onLoad.call(this);

        var gameConfigs = GameManager.getLobbyGameRuntimeConfigs(),
            self = this;
        if (!gameConfigs) {
            return;
        }

        this.game = gameConfigs.game;
        this.room = gameConfigs.room;

        this.bettingSectionNodePosition = this.bettingSectionNode.position;

        this.gameNameLabel.string = this.game && this.game.name || '';
        this.chatLogLabel.string = '';

        this.activeCurrency = null;
        this.bettingValuesByCurrencyMap = null;
        this.bettingItemContainer.removeAllChildren();
        GameManager.getBettingValues(this.game.gameId, (function (response) {
            if (!this.isValid) {
                return;
            }

            var bettingValuesByCurrencies = response && response.bettingValues,
                bettingValuesByCurrency,
                i;
            if (bettingValuesByCurrencies) {
                this.bettingValuesByCurrencyMap = {};
                for (i = 0; i < bettingValuesByCurrencies.length; i += 1) {
                    bettingValuesByCurrency = bettingValuesByCurrencies[i];
                    if (bettingValuesByCurrency) {
                        this.bettingValuesByCurrencyMap[bettingValuesByCurrency.currency] = bettingValuesByCurrency.bettingValues;
                    }
                }
                this.getBettingsLoadingSection.active = false;
                this.showPiBettings();
            }
        }).bind(this));

        this.getTopWinGame();

        this.onPublicMessageBinding = this.onPublicMessage.bind(this);
        NetworkManager.SmartFox.onPublicMessage(this.onPublicMessageBinding);

        this.clickedBettingBtn = null;
        this.cloneClickedBettingBtn = null;

        this.topWinGameAnimationData = {
            name: TOP_WIN_GAME_REVERSED_ANIMATION,
            isPlaying: false,
            timeoutId: null,
            duration: this.node.getComponent(cc.Animation).getClips()[1].duration,
            touchMove: false
        };

        this.topWinGameScrollView.node.on(cc.Node.EventType.TOUCH_MOVE, function () {
            self.topWinGameAnimationData.touchMove = true;
        });

        [this.topWinGameScrollView.node, this.rightPanelNode].forEach(function (node) {
            node.on(cc.Node.EventType.MOUSE_ENTER, function () {
                PlatformImplement.setCursorToHand();
            });
            node.on(cc.Node.EventType.MOUSE_LEAVE, function () {
                PlatformImplement.setCursorToNormal();
            });
        });

        EventDispatcher.addEventListener(GameManagerConstant.Event.JOIN_GAME, this.onFinishJoinGame, this);
    },

    onDestroy: function onDestroy() {
        if (this.clickedBettingBtn) {
            this.clickedBettingBtn.stopAllActions();
        }
        if (this.cloneClickedBettingBtn) {
            this.cloneClickedBettingBtn.stopAllActions();
        }
        if (this.bettingSectionNode) {
            this.bettingSectionNode.stopAllActions();
        }

        if (this.topWinGameAnimationData.timeoutId) {
            clearTimeout(this.topWinGameAnimationData.timeoutId);
            this.topWinGameAnimationData.timeoutId = null;
        }

        NetworkManager.SmartFox.offPublicMessage(this.onPublicMessageBinding);

        EventDispatcher.removeEventListener(GameManagerConstant.Event.JOIN_GAME, this.onFinishJoinGame, this);
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    _showBettingsByCurrency: function _showBettingsByCurrency(currency) {
        AudioManager.instance.playButtonClick();

        if (this.activeCurrency !== currency) {
            var self = this,
                bettingItemTemplateNode,
                activeRoomTypeBtn,
                inactiveRoomTypeBtn,
                animation;
            if (currency === CommonConstant.CurrencyType.Xu.NAME) {
                bettingItemTemplateNode = this.xuBettingItemTemplateNode;
                activeRoomTypeBtn = this.xuRoomTypeNode;
                inactiveRoomTypeBtn = this.ipRoomTypeNode;
            } else {
                bettingItemTemplateNode = this.ipBettingItemTemplateNode;
                activeRoomTypeBtn = this.ipRoomTypeNode;
                inactiveRoomTypeBtn = this.xuRoomTypeNode;
            }

            if (activeRoomTypeBtn) {
                animation = activeRoomTypeBtn.getComponent(cc.Animation);
                if (animation) {
                    animation.play();
                }
            }
            if (inactiveRoomTypeBtn) {
                animation = inactiveRoomTypeBtn.getComponent(cc.Animation);
                if (animation) {
                    animation.stop();
                }
                var label = inactiveRoomTypeBtn.getComponentInChildren(cc.Label);
                if (label) {
                    label.node.runAction(cc.scaleTo(0.1, 1));
                }
                inactiveRoomTypeBtn.getComponentsInChildren(cc.Sprite).forEach(function (comp) {
                    if (comp.node !== inactiveRoomTypeBtn) {
                        comp.node.active = false;
                    }
                });
            }

            this.activeCurrency = currency;
            this._runAnimationHideBettingSection(function () {
                var preShowAnimation = self.bettingItemContainer.getChildren().length > 0;
                self.bettingItemContainer.removeAllChildren();
                if (self.bettingValuesByCurrencyMap) {
                    var bettingValues = self.bettingValuesByCurrencyMap[currency],
                        bettingItem,
                        betting,
                        i;
                    if (bettingValues) {
                        for (i = 0; i < bettingValues.length; i += 1) {
                            betting = bettingValues[i];
                            (function (betting) {
                                bettingItem = cc.instantiate(bettingItemTemplateNode);
                                bettingItem.active = true;
                                bettingItem.getComponentInChildren(cc.Label).string = Utils.Number.abbreviate(betting.value);
                                if (betting.isActive) {
                                    bettingItem.on(cc.Node.EventType.TOUCH_END, function () {
                                        var selfNode = this;
                                        AudioManager.instance.playButtonClick();

                                        if (self.game) {
                                            self.hideTopWinGamePanel(function () {
                                                var gameOptionModalPrefabLink = self.game.CONFIG.GAME_OPTION_MODAL_PREFAB,
                                                    gameId = self.game.gameId,
                                                    gameConfigs = {
                                                    currency: NetworkManager.SmartFox.type.utfString(self.activeCurrency),
                                                    isSolo: NetworkManager.SmartFox.type.bool(self.game.isSolo),
                                                    betting: NetworkManager.SmartFox.type.long(betting.value)
                                                };
                                                // open game option modal then enter game later
                                                if (gameOptionModalPrefabLink) {
                                                    UiManager.openModalByName(gameOptionModalPrefabLink, function (modal) {
                                                        modal.getComponent(BaseGameOptionModal).init(gameId, gameConfigs, function (_gameConfigs, enterGameFn) {
                                                            self._runLoadingAnimation(self, selfNode, enterGameFn);
                                                        });
                                                    });
                                                }
                                                // enter game directly
                                                else {
                                                        self._runLoadingAnimation(self, selfNode, function () {
                                                            GameManager.enterGame(gameId, gameConfigs);
                                                        });
                                                    }
                                            });
                                        }
                                    }, bettingItem);
                                } else {
                                    bettingItem.opacity = 100;
                                    bettingItem.getComponent(cc.Button).interactable = false;
                                }
                                self.bettingItemContainer.addChild(bettingItem);
                            })(betting);
                        }
                        self.bettingItemListScrollView.scrollToTop();
                        self._runAnimationShowBettingSection(preShowAnimation);
                    }
                }
            });
        }
    },

    _runLoadingAnimation: function _runLoadingAnimation(self, clickedBettingBtn, onFinishMovement) {
        this._stopLoadingAnimation();
        var cloneNode = cc.instantiate(clickedBettingBtn),
            centerPos = self.fakeBettingSectionNode.convertToNodeSpaceAR(self.fakeCenterInBettingSectionNode.convertToWorldSpace(cc.v2(0, 0))),
            posTmp = self.fakeBettingSectionNode.convertToNodeSpaceAR(clickedBettingBtn.convertToWorldSpace(cc.v2(0, 0))),
            pos = cc.v2(posTmp.x + cloneNode.width / 2, posTmp.y + cloneNode.height / 2),
            animation = cc.sequence(cc.callFunc(function () {
            self.bettingSectionNode.active = false;
            self.joinRoomLoadingSection.active = true;
            cloneNode.scale = 1;
            cloneNode.parent = self.fakeBettingSectionNode;
            cloneNode.position = pos;
        }), cc.moveTo(0.2, centerPos), cc.delayTime(1), cc.callFunc(function () {
            Utils.Director.preloadScene(self.game.CONFIG.SCENE, function () {
                if (!subAnimation.__isStopped) {
                    cloneNode.runAction(subAnimation);
                }
            });
        })),
            subAnimation = cc.sequence(cc.callFunc(function () {
            if (Utils.Type.isFunction(onFinishMovement)) {
                onFinishMovement();
            }
        }), cc.delayTime(GameManager.JOIN_GAME_TIMEOUT / 1000), cc.callFunc(function () {
            self.bettingSectionNode.active = true;
            self.joinRoomLoadingSection.active = false;
            if (cloneNode) {
                cloneNode.destroy();
            }
            clickedBettingBtn.runAction(cc.sequence(cc.fadeOut(0.3), cc.fadeIn(0.5)));
        }));
        cloneNode.targetOff(cloneNode);
        cloneNode.getComponent('ButtonScaler').destroy();
        cloneNode.runAction(animation);
        this.clickedBettingBtn = clickedBettingBtn;
        this.cloneClickedBettingBtn = cloneNode;
        this.subAnimation = subAnimation;
    },

    _stopLoadingAnimation: function _stopLoadingAnimation() {
        this.bettingSectionNode.active = true;
        this.joinRoomLoadingSection.active = false;
        if (this.cloneClickedBettingBtn) {
            this.cloneClickedBettingBtn.stopAllActions();
            this.cloneClickedBettingBtn.destroy();
            this.cloneClickedBettingBtn = null;
        }
        if (this.clickedBettingBtn) {
            this.clickedBettingBtn.runAction(cc.sequence(cc.fadeOut(0.3), cc.fadeIn(0.5)));
            this.clickedBettingBtn = null;
        }
        if (this.subAnimation) {
            this.subAnimation.__isStopped = true;
            this.subAnimation = null;
        }
    },

    onFinishJoinGame: function onFinishJoinGame(params) {
        if (params && params.gameId === this.game.gameId && !params.isJoining) {
            this._stopLoadingAnimation();
        }
    },

    _runAnimationShowBettingSection: function _runAnimationShowBettingSection(preShowAnimation) {
        var self = this,
            children = self.bettingSectionNode.getChildren(),
            child = children && children[0],
            moveToLowerAnimation = cc.spawn([
        // cc.moveTo(0, cc.v2(self.bettingSectionNodePosition.x, self.bettingSectionNodePosition.y - self.bettingSectionNode.height / 4)),
        cc.fadeOut(0)]),
            moveToInitialPositionAnimation = cc.sequence(
        // cc.moveTo(0.2, self.bettingSectionNodePosition),
        cc.fadeIn(0.2));
        self.bettingSectionNode.stopAllActions();
        if (preShowAnimation) {
            self.bettingSectionNode.runAction(cc.sequence(moveToLowerAnimation, moveToInitialPositionAnimation));
        } else {
            if (child) {
                child.active = false;
            }
            self.bettingSectionNode.runAction(cc.sequence(moveToLowerAnimation, cc.callFunc(function () {
                if (child) {
                    child.active = true;
                }
            }), moveToInitialPositionAnimation));
        }
    },

    _runAnimationHideBettingSection: function _runAnimationHideBettingSection(onFinish) {
        var finishAnimation = cc.callFunc(function () {
            if (Utils.Type.isFunction(onFinish)) {
                onFinish();
            }
        });
        this.bettingSectionNode.stopAllActions();
        if (this.bettingItemContainer.getChildren().length > 0) {
            this.bettingSectionNode.runAction(cc.sequence(cc.spawn([
            // cc.moveTo(0.1, cc.v2(this.bettingSectionNodePosition.x, this.bettingSectionNodePosition.y - this.bettingSectionNode.height / 3)),
            cc.fadeOut(0.1)]), finishAnimation));
        } else {
            this.bettingSectionNode.runAction(cc.sequence(finishAnimation));
        }
    },

    showXuBettings: function showXuBettings() {
        this._showBettingsByCurrency(CommonConstant.CurrencyType.Xu.NAME);
    },

    showPiBettings: function showPiBettings() {
        this._showBettingsByCurrency(CommonConstant.CurrencyType.Ip.NAME);
    },

    backToHall: function backToHall() {
        NetworkManager.SmartFox.leaveRoom(this.room.id);
        Utils.Director.loadScene(CommonConstant.Scene.HALL);
    },

    getTopWinGame: function getTopWinGame() {
        var self = this;
        NetworkManager.Http.fetch('GET', Url.Http.TOP_WIN_GAME, {
            game_id: self.game.gameId
        }, {
            cache: 29 * 60,
            delay: 800
        }).success(function (topResp) {
            if (!self.isValid) {
                return;
            }

            var topItemNode,
                topComponent,
                topSprite,
                topItems = topResp.data,
                i;
            self.topWinGameContainerNode.removeAllChildren();
            for (i = 0; i < topItems.length; i += 1) {
                topItemNode = cc.instantiate(self.itemTopWinGamePrefab);
                topComponent = topItemNode.getComponent('ItemTopWinGame');
                topComponent.updateData(topItems[i]);
                topSprite = topItemNode.getComponent(cc.Sprite);
                topSprite.enabled = i % 2 === 0;
                self.topWinGameContainerNode.addChild(topItemNode);
            }
            self.topWinGameScrollView.scrollToTop();
        });
    },

    onPublicMessage: function onPublicMessage(event) {
        var roomId = event && event.room && event.room.id,
            senderName = event && event.sender && event.sender.name,
            message;
        if (this.room.id === roomId && senderName) {
            message = event.message;
            this._addHistoryItem(senderName, message);
        }
    },

    _addHistoryItem: function _addHistoryItem(name, message) {
        var sep = this.chatLogLabel.string ? '\n' : '',
            wrappedName = '<color=#02bbff>' + name + '</color>',
            stringChat = sep + wrappedName + ': ' + message;
        this.chatLogLabel.string += stringChat;
        if (this.chatLogLabel.node.height < this.chatLogScrollView.node.height - 12) {
            this.chatLogScrollView.scrollToTop();
        } else {
            this.chatLogScrollView.scrollToBottom();
        }
    },

    sendChatMessage: function sendChatMessage() {
        var message = this.chatEditBox.string;
        this.chatEditBox.string = '';
        NetworkManager.SmartFox.sendPublicMessageRequest(message, this.room.id);
    },

    toggleTopWinGamePanel: function toggleTopWinGamePanel() {
        if (!this.topWinGameAnimationData.touchMove) {
            this._runTopWinGamePanelAnimation(this.topWinGameAnimationData.name === TOP_WIN_GAME_ANIMATION ? TOP_WIN_GAME_REVERSED_ANIMATION : TOP_WIN_GAME_ANIMATION);
        }
        this.topWinGameAnimationData.touchMove = false;
    },

    showTopWinGamePanel: function showTopWinGamePanel(callback) {
        this._runTopWinGamePanelAnimation(TOP_WIN_GAME_ANIMATION, callback);
    },

    hideTopWinGamePanel: function hideTopWinGamePanel(callback) {
        this._runTopWinGamePanelAnimation(TOP_WIN_GAME_REVERSED_ANIMATION, callback);
    },

    _runTopWinGamePanelAnimation: function _runTopWinGamePanelAnimation(name, callback) {
        if (this.topWinGameAnimationData.isPlaying || this.topWinGameAnimationData.name === name) {
            if (callback) {
                callback();
            }
            return;
        }

        var animation = this.node.getComponent(cc.Animation),
            self = this;
        if (animation) {
            if (name === TOP_WIN_GAME_REVERSED_ANIMATION) {
                this.topWinGameContainerNode.getComponentsInChildren('ItemTopWinGame').forEach(function (comp) {
                    comp.useShortInfo();
                });
            } else {
                this.topWinGameContainerNode.getComponentsInChildren('ItemTopWinGame').forEach(function (comp) {
                    comp.useLongInfo();
                });
            }
            this.topWinGameAnimationData.name = name;
            this.topWinGameAnimationData.isPlaying = true;
            animation.play(name);
            this.topWinGameAnimationData.timeoutId = setTimeout(function () {
                self.topWinGameAnimationData.isPlaying = false;
                if (callback) {
                    callback();
                }
            }, this.topWinGameAnimationData.duration);
        }
    }
});

cc._RFpop();
},{"AudioManager":"AudioManager","BaseGameOptionModal":"BaseGameOptionModal","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","GameManager":"GameManager","GameManagerConstant":"GameManagerConstant","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","TopPanelOutGameWrapper":"TopPanelOutGameWrapper","UiManager":"UiManager","Url":"Url","Utils":"Utils"}],"MauBinhConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1fc64H/ndFG9bOyvkPN6VkQ', 'MauBinhConstant');
// scripts\games\mau_binh\MauBinhConstant.js

module.exports = {
    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_DEALING: 2,
        DEALING: 3,
        ORDER_CARDS: 4,
        PLAYING: 5,
        FINALIZING: 6,
        FINISH: 7,
        COMPARE_1: 8,
        COMPARE_2: 9,
        COMPARE_3: 10
    },

    Action: {
        ORDER_HANDS: 2,
        ORDER_CARDS: 4,
        WAITING_ORDER_CARDS: 5,
        COMPARE_CHI_MOT: 6,
        COMPARE_CHI_HAI: 7,
        COMPARE_CHI_BA: 8,
        NOTIFY_THANG_TRANG: 9,
        NOTIFY_BINH_LUNG: 10,
        FINISH_ORDER_CARDS: 11
    },

    PlayerState: {
        WAITING: 0,
        READY: 1,
        IN_TURN: 2,
        OUT_TURN: 3,
        ORDER_CARDS: 4,
        WAITING_FOR_TURN: 5,
        FINISH: 6
    },

    Event: {
        GAME_PREPARE: 'in_game.mau_binh.prepare',
        GAME_UPDATE_HAND: 'in_game.mau_binh.update_hand',
        GAME_WATING_PLAYER: 'in_game.mau_binh.wating_player',
        GAME_PLAYER_REMOVE: 'in_game.mau_binh.player_remove',
        GAME_PLAYER_ADD: 'in_game.mau_binh.player_add',
        GAME_USER_FINISH_ORDER: 'in_game.mau_binh.finish_order',
        GAME_ORDER_CARD: 'in_game.mau_binh.start',
        GAME_COMPARE_CHI: 'in_game.mau_binh.compare_chi',
        GAME_UPDATE: 'in_game.mau_binh.game_update',
        GAME_FINISH: 'in_game.mau_binh.finish',
        GAME_NOTIFY_THANG_TRANG: 'in_game.mau_binh.thang_trang',
        GAME_NOTIFY_BINH_LUNG: 'in_game.mau_binh.binh_lung'
    },

    Chi: {
        NONE: {
            ID: -1,
            NAME: 'None'
        },
        MAU_THAU: {
            ID: 0,
            NAME: 'Mậu Thầu'
        },
        DOI: {
            ID: 1,
            NAME: 'Đôi'
        },
        THU: {
            ID: 2,
            NAME: 'Thú'
        },
        SAM: {
            ID: 3,
            NAME: 'Sám cô'
        },
        SANH: {
            ID: 4,
            NAME: 'Sảnh'
        },
        THUNG: {
            ID: 5,
            NAME: 'Thùng'
        },
        CU_LU: {
            ID: 6,
            NAME: 'Cù Lũ'
        },
        TU_QUY: {
            ID: 7,
            NAME: 'Tứ Quý'
        },
        THUNG_PHA_SANH: {
            ID: 8,
            NAME: 'Thùng Phá Sảnh'
        },
        LUC_PHE_BON: {
            ID: 9,
            NAME: 'Lục Phé Bôn'
        },
        BA_CAI_SANH: {
            ID: 10,
            NAME: 'Ba Sảnh'
        },
        BA_CAI_THUNG: {
            ID: 1,
            NAME: 'Ba Thùng'
        },
        SANH_RONG: {
            ID: 12,
            NAME: 'Sảnh Rồng'
        },
        BINH_LUNG: {
            ID: 13,
            NAME: 'Binh Lủng'
        }
    }
};

cc._RFpop();
},{}],"MauBinhGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '553dcapKW5GpJ4gVYPt+f3n', 'MauBinhGameManager');
// scripts\games\mau_binh\MauBinhGameManager.js

var Utils = require('Utils'),
    BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    MauBinhConstant = require('MauBinhConstant'),
    NetworkManager = require('NetworkManager'),
    MauBinhGameManager;

MauBinhGameManager = Utils.Class({

    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this.DELAYED_COMMANDS = [SmartFoxConstant.Command.MESSAGE.ID, SmartFoxConstant.Command.PLAY.ID, SmartFoxConstant.Command.FINISH_GAME.ID, SmartFoxConstant.Command.DEAL_CARD.ID, SmartFoxConstant.Command.TURN.ID, SmartFoxConstant.Command.WAITING_DEAL_CARD.ID];

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAY.ID, this.onPlay, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_HAND.ID, this.onUpdateHand, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAYER_REMOVED.ID, this.onPlayerRemove, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAYER_ADDED.ID, this.onPlayerAdd, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWattingDealing, this);
    },

    onPlayerRemove: function onPlayerRemove(params) {
        this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_PLAYER_REMOVE, params);
    },

    onPlayerAdd: function onPlayerAdd(params) {
        this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_PLAYER_ADD, params);
    },

    onWattingDealing: function onWattingDealing(params) {
        // cc.log('## onWattingDealing');
        this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_PREPARE, params);
        this.gameState = MauBinhConstant.GameState.WAITING_DEALING;
    },

    onUpdateHand: function onUpdateHand(params) {
        // cc.log('## onUpdateHand');
        this.gameState = MauBinhConstant.GameState.ORDER_CARDS;
        this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_UPDATE_HAND, params);
    },

    onPlay: function onPlay(params) {
        // cc.log('## onPlay');
        // cc.log(params);
        switch (params.action) {
            case MauBinhConstant.Action.ORDER_CARDS:
                this.gameState = MauBinhConstant.GameState.ORDER_CARDS;
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_ORDER_CARD, params);
                break;
            case MauBinhConstant.Action.FINISH_ORDER_CARDS:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_USER_FINISH_ORDER, params);
                break;
            case MauBinhConstant.Action.COMPARE_CHI_MOT:
                this.gameState = MauBinhConstant.GameState.COMPARE_1;
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_COMPARE_CHI, params);
                break;
            case MauBinhConstant.Action.COMPARE_CHI_HAI:
                this.gameState = MauBinhConstant.GameState.COMPARE_2;
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_COMPARE_CHI, params);
                break;
            case MauBinhConstant.Action.COMPARE_CHI_BA:
                this.gameState = MauBinhConstant.GameState.COMPARE_3;
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_COMPARE_CHI, params);
                break;
            case MauBinhConstant.Action.NOTIFY_THANG_TRANG:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_NOTIFY_THANG_TRANG, params);
                break;
            case MauBinhConstant.Action.NOTIFY_BINH_LUNG:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_NOTIFY_BINH_LUNG, params);
                break;
            case MauBinhConstant.Action.WAITING_ORDER_CARDS:
                // cc.log('WAITING_ORDER_CARDS');
                break;
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        // cc.log('## onUpdateGame');
        // cc.log(params);
        this.gameState = params.gameState;
        switch (this.gameState) {
            case MauBinhConstant.GameState.WAITING_FOR_PLAYER:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_WATING_PLAYER, params);
                break;
            case MauBinhConstant.GameState.WAITING_DEALING:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_PREPARE, params);
                break;
            case MauBinhConstant.GameState.COMPARE_1:
            case MauBinhConstant.GameState.COMPARE_2:
            case MauBinhConstant.GameState.COMPARE_3:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_COMPARE_CHI, params);
                break;
            case MauBinhConstant.GameState.DEALING:
            case MauBinhConstant.GameState.PLAYING:
                break;
            case MauBinhConstant.GameState.ORDER_CARDS:
                this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_ORDER_CARD, params);
                break;
        }
    },

    onFinishGame: function onFinishGame(params) {
        this.eventDispatchers.local.dispatchEvent(MauBinhConstant.Event.GAME_FINISH, params);
    },

    sendRequestOrderCard: function sendRequestOrderCard(cardsId, isFinish) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(MauBinhConstant.Action.ORDER_CARDS),
            cards: NetworkManager.SmartFox.type.byteArray(cardsId),
            isFinish: NetworkManager.SmartFox.type.bool(isFinish)
        });
    },

    sendRequestStartGame: function sendRequestStartGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.DEAL_CARD.ID)
        });
    }
});

module.exports = MauBinhGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","MauBinhConstant":"MauBinhConstant","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"MessageBoxCache":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5b080Ecq/5JFZT7MpaSbO4h', 'MessageBoxCache');
// scripts\components\message_box\MessageBoxCache.js

var AuthUser = require('AuthUser');

var MessageBoxCache = {
    _cache: null,

    CACHE_KEY_STORAGE: 'mess_cache',
    USER_KEY: '_user',
    MAX_ITEMS: 100,

    initCache: function initCache(key) {
        if (!this._cache) {
            this._cache = JSON.parse(cc.sys.localStorage.getItem(this.CACHE_KEY_STORAGE)) || {};
        }
        if (this._cache[this.USER_KEY] !== AuthUser.username) {
            this.resetCache();
            this._cache[this.USER_KEY] = AuthUser.username;
        }
        this._cache[key] = this._cache[key] || [];
    },
    saveCache: function saveCache() {
        cc.sys.localStorage.setItem(this.CACHE_KEY_STORAGE, JSON.stringify(this._cache));
    },
    resetCache: function resetCache() {
        this._cache = {};
        cc.sys.localStorage.removeItem(this.CACHE_KEY_STORAGE);
    },

    addMessages: function addMessages(key, messages) {
        var i, j, allowAdd;
        this.initCache(key);
        for (j = 0; j < messages.length; j += 1) {
            allowAdd = true;
            for (i = 0; i < this._cache[key].length; i += 1) {
                if (this._cache[key][i].msgid === messages[j].msgid) {
                    allowAdd = false;
                    break;
                }
            }
            if (allowAdd) {
                this._cache[key].push(messages[j]);
            }
        }
        this._cache[key].sort(function (m1, m2) {
            return m2.created_time.localeCompare(m1.created_time);
        });
        this._cache[key] = this._cache[key].slice(0, this.MAX_ITEMS);
        this.saveCache(key);
    },

    getMessages: function getMessages(key) {
        this.initCache(key);
        return this._cache[key];
    },

    updateMessage: function updateMessage(key, message) {
        this.initCache(key);
        for (var i = 0; i < this._cache[key].length; i += 1) {
            if (this._cache[key][i].msgid === message.msgid) {
                cc.js.mixin(this._cache[key][i], message);
                break;
            }
        }
        this.saveCache(key);
    },

    getIndexMessage: function getIndexMessage(key, messageId) {
        for (var i = 0; i < this._cache[key].length; i += 1) {
            if (this._cache[key][i].msgid === messageId) {
                return i;
            }
        }
    },

    removeMessage: function removeMessage(key, messageId) {
        this.initCache(key);
        for (var i = 0; i < this._cache[key].length; i += 1) {
            if (this._cache[key][i].msgid === messageId) {
                this._cache[key].splice(i, 1);
                break;
            }
        }
        this.saveCache(key);
    }
};

module.exports = MessageBoxCache;

cc._RFpop();
},{"AuthUser":"AuthUser"}],"MessageBox":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0ecacsuzFhI1ZZxsQ3kuggz', 'MessageBox');
// scripts\components\message_box\MessageBox.js

var Url = require('Url'),
    TabView = require('TabView'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    MessageBoxCache = require('MessageBoxCache'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemMessageDetailPrefab: cc.Prefab,
        messageTabView: TabView,

        itemInboxPrefab: cc.Prefab,
        ongoingContainerNode: cc.Node,

        itemSentPrefab: cc.Prefab,
        outgoingContainerNode: cc.Node,

        userToEditBox: cc.EditBox,
        contentEditBox: cc.EditBox,
        titleEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.clearMessageEditor();
        this.itemMessageDetailNode = cc.instantiate(this.itemMessageDetailPrefab);
    },

    fetchMessages: function fetchMessages(typeMessage, itemPrefab, containerNode) {
        var that = this;
        // type: 'ongoing', 'outgoing'
        NetworkManager.Http.fetch('GET', Url.Http.MESSAGE_BOX, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            type: typeMessage
        }, {
            delay: 500
        }).success(function (respDone) {
            var i,
                messages,
                keyStorage = 'mess_' + typeMessage;
            MessageBoxCache.addMessages(keyStorage, respDone.data);
            messages = MessageBoxCache.getMessages(keyStorage);
            containerNode.removeAllChildren();
            for (i = 0; i < messages.length; i += 1) {
                that._initMessageNode(itemPrefab, containerNode, messages[i], keyStorage);
            }
            if (typeMessage === 'ongoing') {
                AuthUser.unread_mess_count = 0;
                EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_UNREAD_MESS_COUNT);
            }
        });
    },

    _initMessageNode: function _initMessageNode(itemPrefab, containerNode, msgData, keyStorage) {
        var that = this,
            itemInbox = cc.instantiate(itemPrefab);
        containerNode.addChild(itemInbox);
        itemInbox.getComponent('ItemMessage').updateData(msgData, keyStorage);
        itemInbox.on(cc.Node.EventType.TOUCH_END, function () {
            if (that.itemMessageDetailNode.parent) {
                that.itemMessageDetailNode.removeFromParent(false);
            }
            containerNode.parent.addChild(that.itemMessageDetailNode);
            var itemMessageComp = that.itemMessageDetailNode.getComponent('ItemMessage');
            if (!msgData.body) {
                NetworkManager.Http.fetch('GET', Url.Http.DETAIL_MESSAGE_BOX, {
                    username: AuthUser.username,
                    message_id: msgData.msgid,
                    accesstoken: AuthUser.accesstoken
                }).success(function (respDone) {
                    itemMessageComp.updateData(respDone.data, keyStorage);
                    MessageBoxCache.updateMessage(keyStorage, respDone.data);
                });
            } else {
                itemMessageComp.updateData(msgData, keyStorage);
            }
            itemMessageComp.deleteMessage = function () {
                UiManager.openConfirmModal('Bạn có chắc muốn xóa tin nhắn này không?', {
                    oke_fn: function oke_fn() {
                        MessageBoxCache.removeMessage(keyStorage, msgData.msgid);
                        itemInbox.removeFromParent();
                        itemMessageComp.closeDetailMessage();
                    }
                });
            };
            itemMessageComp.replyToUser = function () {
                that.userToEditBox.string = this.userLabel.string;
                that.messageTabView.activeByName('MessEditor');
                this.closeDetailMessage();
            };
            itemMessageComp.closeDetailMessage = function () {
                that.itemMessageDetailNode.runAction(cc.sequence([cc.fadeOut(0.1), cc.callFunc(function () {
                    that.itemMessageDetailNode.removeFromParent(false);
                })]));
            };
            that.itemMessageDetailNode.runAction(cc.fadeIn(0.1));
        }, itemInbox);
    },

    fetchOnGoingMessages: function fetchOnGoingMessages() {
        this.fetchMessages('ongoing', this.itemInboxPrefab, this.ongoingContainerNode);
    },

    fetchOutGoingMessages: function fetchOutGoingMessages() {
        this.fetchMessages('outgoing', this.itemSentPrefab, this.outgoingContainerNode);
    },

    sendMessage: function sendMessage(event) {
        if (this.titleEditBox.string === '' || this.contentEditBox.string === '' || this.userToEditBox.string === '') {
            UiManager.openModal('Bạn cần nhập đầy đủ thông tin gửi.');
        } else {
            if (this.userToEditBox.string === AuthUser.username) {
                UiManager.openModal('Tên người nhận không hợp lệ.');
                return;
            }
            var that = this;
            var toUser = this.userToEditBox.string,
                subjectInput = this.titleEditBox.string,
                bodyInput = this.contentEditBox.string;
            NetworkManager.Http.fetch('POST', Url.Http.MESSAGE_BOX, {
                from_user: AuthUser.username,
                to_user: toUser,
                subject: subjectInput,
                body: bodyInput,
                accesstoken: AuthUser.accesstoken
            }).success(function () {
                that.clearMessageEditor();
                that.messageTabView.activeByName('Sent');
                // UiManager.openModal('Bạn đã gửi tin nhắn thành công.');
            }).setWaitingButton(event.target);
        }
    },

    clearMessageEditor: function clearMessageEditor() {
        this.titleEditBox.string = '';
        this.userToEditBox.string = '';
        this.contentEditBox.string = '';
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"AuthUser":"AuthUser","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","MessageBoxCache":"MessageBoxCache","NetworkManager":"NetworkManager","TabView":"TabView","UiManager":"UiManager","Url":"Url"}],"MiniPokerConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f6055esZdhMMJE9Vbt8EcYq', 'MiniPokerConstant');
// scripts\games\mini_poker\MiniPokerConstant.js

module.exports = {
    Action: {
        ROTATE: 0,
        CHANGE_STATE: 5,
        UPDATE_MINI_POKER_JAR: 6
    },

    GameState: {
        NONE: 0,
        ROTATE: 1,
        FINALIZING: 2,
        FINISH: 3
    },

    PotType: {
        NONE: 0,
        DOI_J: 1,
        THU: 2,
        SAM: 3,
        SANH: 4,
        THUNG: 5,
        CU_LU: 6,
        TU_QUY: 7,
        THUNG_PHA_SANH: 8,
        THUNG_PHA_SANH_A: 9
    },

    Event: {
        TURN_PREPARE: 'in_game.mini_poker.prepare',
        TURN_START: 'in_game.mini_poker.start',
        TURN_UPDATE: 'in_game.mini_poker.update',
        TURN_FINISH: 'in_game.mini_poker.finish',
        GET_JAR_SUCCESS: 'in_game.mini_poker.get_jar',
        UPDATE_JAR: 'in_game.mini_poker.update_jar'
    },

    getPotName: function getPotName(potType) {
        var result = '';
        switch (potType) {
            case this.PotType.NONE:
                break;
            case this.PotType.DOI_J:
                result = 'Đôi J+';
                break;
            case this.PotType.THU:
                result = 'Thú';
                break;
            case this.PotType.SAM:
                result = 'Sám';
                break;
            case this.PotType.SANH:
                result = 'Sảnh';
                break;
            case this.PotType.THUNG:
                result = 'Thùng';
                break;
            case this.PotType.CU_LU:
                result = 'Cù Lũ';
                break;
            case this.PotType.TU_QUY:
                result = 'Tứ Quý';
                break;
            case this.PotType.THUNG_PHA_SANH:
                result = 'Thùng Phá Sảnh';
                break;
            case this.PotType.THUNG_PHA_SANH_A:
                result = 'Thùng Phá Sảnh A';
                break;
        }
        return result;
    }
};

cc._RFpop();
},{}],"MiniPokerGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3dfe2MJ3+tHJKYgYW3t+Etb', 'MiniPokerGameManager');
// scripts\games\mini_poker\MiniPokerGameManager.js

var Utils = require('Utils'),
    Url = require('Url'),
    BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    NetworkManager = require('NetworkManager'),
    MiniPokerConstant = require('MiniPokerConstant'),
    MiniPokerGameManager;

MiniPokerGameManager = Utils.Class({

    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this.DELAYED_COMMANDS = [SmartFoxConstant.Command.MESSAGE.ID];

        this.gameState = MiniPokerConstant.GameState.NONE;
        this.historyList = [];
        this.lastMoneyBet = 0;
        this.lastPotWin = 0;
        this.lastCurrency = '';

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(MiniPokerConstant.Action.CHANGE_STATE, this.onChangeStateGame, this);
        this.eventDispatchers.playCmd.addEventListener(MiniPokerConstant.Action.ROTATE, this.onStartGame, this);

        this.eventDispatchers.globalCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGameJar, this);

        //  Get Money Quy
        this._getMoneyQuy();
    },

    onUpdateGameJar: function onUpdateGameJar(params) {
        this.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.UPDATE_JAR, params);
    },

    sendStartGame: function sendStartGame(currency, money) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(MiniPokerConstant.Action.ROTATE),
            betting: NetworkManager.SmartFox.type.long(money),
            currency: NetworkManager.SmartFox.type.utfString(currency)
        });
        this.lastMoneyBet = money;
        this.lastCurrency = currency;
        // cc.log("SEND sendStartGame  currency " + currency + " money " + money);
    },

    onChangeStateGame: function onChangeStateGame(params) {
        this.gameState = params.gameState;
        if (params.gameState === MiniPokerConstant.GameState.ROTATE) {
            this.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.TURN_START, params);
            this.lastPotWin = params.potWin;
        } else if (params.gameState === MiniPokerConstant.GameState.NONE) {
            this.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.TURN_PREPARE, params);
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        this.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.TURN_UPDATE, params);
    },

    onFinishGame: function onFinishGame(params) {
        this.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.TURN_FINISH, params);
        var historyData = {
            time: Utils.Date.currentTime(),
            potWin: this.lastPotWin,
            moneyBet: this.lastMoneyBet,
            moneyExchange: params.player.moneyExchange,
            currency: this.lastCurrency
        };
        this.historyList.unshift(historyData);
        if (this.historyList.length > 60) {
            this.historyList.splice(this.historyList.length - 1, 1);
        }
    },

    _getMoneyQuy: function _getMoneyQuy() {
        var self = this;
        NetworkManager.Http.fetch('GET', Url.Http.MINI_POKER_GET_JAR, {}).success(function (results) {
            self.eventDispatchers.local.dispatchEvent(MiniPokerConstant.Event.GET_JAR_SUCCESS, results);
        }, {
            cache: 900
        });
    },

    destroy: function destroy() {
        this.$super.destroy.call(this);
    }

});

module.exports = MiniPokerGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","MiniPokerConstant":"MiniPokerConstant","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Url":"Url","Utils":"Utils"}],"MinigamePopup":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5ae81IT9LFJDYTscvXuaQYE', 'MinigamePopup');
// scripts\components\games\minigame\MinigamePopup.js

var GameItem = require('GameItem'),
    GameManager = require('GameManager'),
    GameConstant = require('GameConstant'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    TinhNangManager = require('TinhNangManager'),
    CommonConstant = require('CommonConstant'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        popupNode: cc.Node,
        minipokerGameItem: GameItem,

        taixiuGameItem: GameItem,
        taixiuTimeLeftLabel: cc.Label
    },

    start: function start() {
        this.node.zIndex = CommonConstant.ZINDEX.MINIGAME_POPUP;
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.popupNode.on(cc.Node.EventType.TOUCH_END, this.hide, this);
        this._initGames();
        this.onTinhNangNew();

        EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    onEnable: function onEnable() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.hide, this);
        this.stopPropagationOnPopupNode = Utils.Node.stopPropagation(this.popupNode);
    },

    onDisable: function onDisable() {
        if (this.stopPropagationOnPopupNode) {
            this.stopPropagationOnPopupNode();
            this.stopPropagationOnPopupNode = null;
        }
        this.node.off(cc.Node.EventType.TOUCH_END, this.hide, this);
    },

    // called every frame, uncomment this function to activate update callback
    update: function update() {
        this._updateTaiXiu();
    },

    init: function init(minigameQuickIcon) {
        this.minigameQuickIcon = minigameQuickIcon;
        this.minigameQuickIconSize = {
            width: minigameQuickIcon.node.width,
            height: minigameQuickIcon.node.height
        };
        this.show();
    },

    show: function show() {
        this._correctPositionToShow();

        var currentPosition = cc.v2(0, 0),
            animationTime = 0.2,
            afterAnimationTime = 0.15,
            animation = cc.sequence(cc.spawn([cc.scaleTo(animationTime, 1), cc.rotateBy(animationTime, -720), cc.moveTo(animationTime, currentPosition), cc.fadeIn(animationTime)]), cc.spawn([cc.scaleTo(afterAnimationTime, 0.8, 1.2), cc.moveBy(afterAnimationTime, 0, 120)]), cc.spawn([cc.scaleTo(afterAnimationTime, 1.5, 0.6), cc.moveBy(afterAnimationTime / 2, 0, -120)]), cc.scaleTo(animationTime, 1));
        this.popupNode.runAction(animation);
    },

    hide: function hide() {
        this._correctPositionToHide();

        var targetPosition = this._getMinigameQuickIconPosition(),
            self = this,
            animationTime = 0.2,
            animation = cc.sequence(cc.spawn([cc.scaleTo(animationTime, 0), cc.rotateBy(animationTime, 720), cc.moveTo(animationTime, targetPosition), cc.fadeIn(animationTime), cc.callFunc(function () {
            if (self.minigameQuickIcon) {
                self.minigameQuickIcon.show();
            }
        })]), cc.callFunc(function () {
            self.node.destroy();
        }));

        this.popupNode.runAction(animation);
    },

    onTinhNangNew: function onTinhNangNew() {
        this.taixiuGameItem.node.active = TinhNangManager.choPhep(GameConstant.TAI_XIU.ID);
        this.minipokerGameItem.node.active = TinhNangManager.choPhep(GameConstant.MINI_POKER.ID);
    },

    _correctPositionToShow: function _correctPositionToShow() {
        this.popupNode.stopAllActions();
        this.popupNode.scale = 0;
        this.popupNode.rotation = 0;
        this.popupNode.opacity = 0;
        this.popupNode.position = this._getMinigameQuickIconPosition();
        this.node.active = true;
    },

    _correctPositionToHide: function _correctPositionToHide() {
        this.popupNode.stopAllActions();
        this.popupNode.scale = 1;
        this.popupNode.rotation = 0;
        this.popupNode.opacity = 255;
        this.popupNode.position = cc.v2(0, 0);
        this.node.active = true;
    },

    _getMinigameQuickIconPosition: function _getMinigameQuickIconPosition() {
        var oldScale = this.popupNode.scale,
            oldPosition = this.popupNode.position,
            targetPosition;

        this.popupNode.active = false;
        this.popupNode.scale = 1;
        this.popupNode.position = cc.v2(0, 0);

        targetPosition = this.popupNode.convertToNodeSpace(this.minigameQuickIcon.node.convertToWorldSpace(cc.v2(0, 0)));
        targetPosition.x = targetPosition.x + this.minigameQuickIconSize.width / 2 - this.popupNode.width / 2;
        targetPosition.y = targetPosition.y + this.minigameQuickIconSize.height / 2 - this.popupNode.height / 2;

        this.popupNode.scale = oldScale;
        this.popupNode.position = oldPosition;
        this.popupNode.active = true;

        return targetPosition;
    },

    _initGames: function _initGames() {
        this._initGame(this.minipokerGameItem, GameConstant.MINI_POKER.CMD);
        this._initGame(this.taixiuGameItem, GameConstant.TAI_XIU.CMD);
    },

    _initGame: function _initGame(gameItem, gameCmd) {
        var gameGroup, game, i;
        for (i = 0; i < GameManager.GAME_GROUP_LIST.length; i += 1) {
            gameGroup = GameManager.GAME_GROUP_LIST[i];
            if (gameGroup && gameGroup.length > 0) {
                game = gameGroup[0];
                if (game && game.CONFIG && game.CONFIG.CMD === gameCmd) {
                    gameItem.init(gameGroup);
                    break;
                }
            }
        }
    },

    _updateTaiXiu: function _updateTaiXiu() {
        this._updateTaiXiuTimeLeft();
    },

    _updateTaiXiuTimeLeft: function _updateTaiXiuTimeLeft() {
        var gameRuntimeConfigs = GameManager.getGameRuntimeConfigs(GameConstant.TAI_XIU.CMD),
            gameManager = gameRuntimeConfigs && gameRuntimeConfigs.gameManager;
        if (gameManager) {
            this.taixiuTimeLeftLabel.string = gameManager.getFormattedCurrentTimeLeft();
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","GameItem":"GameItem","GameManager":"GameManager","TinhNangManager":"TinhNangManager","Utils":"Utils"}],"MinigameQuickIcon":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3b228l5gNBCXa/IiHZRetro', 'MinigameQuickIcon');
// scripts\components\games\minigame\MinigameQuickIcon.js

var UiManager = require('UiManager'),
    GameManager = require('GameManager'),
    GameConstant = require('GameConstant'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    TinhNangManager = require('TinhNangManager'),
    CommonConstant = require('CommonConstant'),
    Utils = require('Utils'),
    MINIGAME_POPUP_PREFAB = 'games/minigame/MinigamePopup',
    ACTIVE_OPACITY = 255,
    IDLE_OPACITY = 255 * 0.75,
    IDLE_TIMEOUT = 2000,
    SMALL_MOVE_DISTANCE = 50,
    BOUNDARY_PADDING = 10,
    MINIGAME_QUICK_ICON_POSITION_KEY = 'minigame_icon_pos';

cc.Class({
    'extends': cc.Component,

    properties: {
        taixiuTimeLeftNode: cc.Node,
        taixiuTimeLeftLabel: cc.Label
    },

    start: function start() {
        if (cc.sys.isBrowser) {
            this.node.zIndex = CommonConstant.ZINDEX.MINIGAME_QUICK_ICON;
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.MIN_SCALE = 100 / this.node.width;
        this.MAX_SCALE = 120 / this.node.width;

        this.blinkAnimation = this.node.getComponentInChildren(cc.Animation);

        this.heartBeatAction = cc.sequence(cc.scaleTo(1, this.MIN_SCALE), cc.scaleTo(1, this.MAX_SCALE)).repeatForever();

        this.touchStartTime = Date.now();
        this.mouseEnter = false;

        this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
        this.node.on(cc.Node.EventType.MOUSE_ENTER, function () {
            this.mouseEnter = true;
            this._cancelScheduleIdleState();
        }, this);
        this.node.on(cc.Node.EventType.MOUSE_LEAVE, function () {
            if (this.mouseEnter) {
                this._scheduleIdleState();
            }
            this.mouseEnter = false;
        }, this);

        var position = this._loadPosition();
        if (position) {
            this.node.position = position;
        }
        this.node.position = this._correctPosition(this.node.position);
        this._scheduleIdleState();
        this.onTinhNangNew();

        EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    onDestroy: function onDestroy() {
        this.node.destroy();
        UiManager.destroyModalByName(MINIGAME_POPUP_PREFAB);
        EventDispatcher.removeEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    // called every frame, uncomment this function to activate update callback
    update: function update() {
        this._updateTaiXiu();
    },

    onTinhNangNew: function onTinhNangNew() {
        this.taixiuTimeLeftNode.active = TinhNangManager.choPhep(GameConstant.TAI_XIU.ID);
    },

    onTouchStart: function onTouchStart() {
        this.touchStartTime = Date.now();
        this._cancelScheduleIdleState();
    },

    onTouchMove: function onTouchMove(event) {
        var location = event.getLocation();
        this.node.position = location;
    },

    onTouchEnd: function onTouchEnd(event) {
        var deltaTime = Date.now() - this.touchStartTime,
            startLocation = event.getStartLocation(),
            location = event.getLocation(),
            deltaX = location.x - startLocation.x,
            deltaY = location.y - startLocation.y,
            maxDelta = Math.max(Math.abs(deltaX), Math.abs(deltaY)),
            a = maxDelta / deltaTime,
            winSize = cc.winSize,
            xMin = 0,
            xMax = xMin + winSize.width,
            yMin = 0,
            yMax = yMin + winSize.height,
            animationTime = 0.2,
            self = this,
            action;

        if (a > 1.2) {
            switch (maxDelta) {
                case deltaX:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(xMax, this.node.y)));
                    break;

                case -deltaX:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(xMin, this.node.y)));
                    break;

                case deltaY:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(this.node.x, yMax)));
                    break;

                case -deltaY:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(this.node.x, yMin)));
                    break;
            }
        } else {
            var deltaXLeft = location.x - xMin,
                deltaXRight = xMax - location.x,
                deltaYTop = yMax - location.y,
                deltaYBottom = location.y - yMin,
                minDelta = Math.min(deltaXLeft, deltaXRight, deltaYTop, deltaYBottom);

            switch (minDelta) {
                case deltaXLeft:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(xMin, this.node.y)));
                    break;

                case deltaXRight:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(xMax, this.node.y)));
                    break;

                case deltaYTop:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(this.node.x, yMax)));
                    break;

                case deltaYBottom:
                    action = cc.moveTo(animationTime, this._correctPosition(cc.v2(this.node.x, yMin)));
                    break;
            }
        }

        if (action) {
            action.easing(cc.easeBounceInOut());
            this.node.runAction(cc.sequence(action, cc.callFunc(this._savePosition.bind(this))));
        }

        this._scheduleIdleState();

        if (Math.abs(deltaX) < SMALL_MOVE_DISTANCE && Math.abs(deltaY) < SMALL_MOVE_DISTANCE) {
            UiManager.openModalByName(MINIGAME_POPUP_PREFAB, function (newNode) {
                var comp = newNode.getComponent('MinigamePopup');
                if (comp) {
                    comp.init(self);
                    self.hide();
                }
            }, {
                isPersistent: true
            });
        }

        this.mouseEnter = false;
    },

    show: function show() {
        this._correctPositionToShow();

        var animationTime = 0.2,
            animation = cc.spawn([cc.scaleTo(animationTime, 1), cc.rotateBy(animationTime, -720), cc.fadeIn(animationTime)]);
        this.node.runAction(cc.sequence(animation, cc.callFunc(this._scheduleIdleState.bind(this))));
    },

    hide: function hide() {
        this._correctPositionToHide();

        var animationTime = 0.2,
            animation = cc.spawn([cc.scaleTo(animationTime, 0), cc.rotateBy(animationTime, 720), cc.fadeOut(animationTime)]);
        this.node.runAction(animation);
    },

    _getShortestBoundaryPosition: function _getShortestBoundaryPosition(position, size) {
        var winSize = cc.winSize,
            xMin = 0,
            xMax = xMin + winSize.width,
            yMin = 0,
            yMax = yMin + winSize.height,
            width = size ? size.width : this.node.width,
            halfWidth = width / 2,
            height = size ? size.height : this.node.height,
            halfHeight = height / 2,
            deltaXLeft = position.x - xMin,
            deltaXRight = xMax - position.x,
            deltaYTop = yMax - position.y,
            deltaYBottom = position.y - yMin,
            minDelta = Math.min(deltaXLeft, deltaXRight, deltaYTop, deltaYBottom),
            newPos = {
            x: position.x,
            y: position.y
        };

        switch (minDelta) {
            case deltaXLeft:
                newPos.x = xMin + halfWidth;
                break;

            case deltaXRight:
                newPos.x = xMax - halfWidth;
                break;

            case deltaYTop:
                newPos.y = yMax - halfHeight;
                break;

            case deltaYBottom:
                newPos.y = yMin + halfHeight;
                break;
        }

        return newPos;
    },

    _correctPosition: function _correctPosition(position, size) {
        var winSize = cc.winSize,
            xMin = 0,
            xMax = xMin + winSize.width,
            yMin = 0,
            yMax = yMin + winSize.height,
            width = size ? size.width : this.node.width,
            halfWidth = width / 2,
            height = size ? size.height : this.node.height,
            halfHeight = height / 2,
            xLeft = position.x - halfWidth,
            xRight = position.x + halfWidth,
            yTop = position.y + halfHeight,
            yBottom = position.y - halfHeight;

        if (xLeft < xMin) {
            xLeft = xMin + halfWidth;
        } else if (xRight > xMax) {
            xLeft = xMax - halfWidth;
        } else {
            xLeft = position.x;
        }

        if (yBottom < yMin) {
            yBottom = yMin + halfHeight;
        } else if (yTop > yMax) {
            yBottom = yMax - halfHeight;
        } else {
            yBottom = position.y;
        }

        return cc.v2(xLeft, yBottom);
    },

    _correctPositionToShow: function _correctPositionToShow() {
        this.node.stopAllActions();
        this.node.scale = 0;
        this.node.rotation = 0;
        this.node.opacity = 0;
    },

    _correctPositionToHide: function _correctPositionToHide() {
        this.node.stopAllActions();
        this.node.scale = 1;
        this.node.rotation = 0;
        this.node.opacity = 255;
    },

    _changeToIdleState: function _changeToIdleState() {
        this.node.opacity = IDLE_OPACITY;
        if (this.node.scale >= this.MIN_SCALE) {
            var self = this,
                oldWidth = this.node.width,
                oldHeight = this.node.height,
                newWidth = oldWidth * this.MAX_SCALE,
                newHeight = oldHeight * this.MAX_SCALE,
                halfNewWidth = newWidth / 2,
                halfNewHeight = newHeight / 2,
                winSize = cc.winSize,
                xMin = 0,
                xMax = xMin + winSize.width,
                yMin = 0,
                yMax = yMin + winSize.height,
                deltaWidth = oldWidth - newWidth,
                deltaHeight = oldHeight - newHeight,
                xLeft = this.node.x - deltaWidth / 2,
                xRight = this.node.x + deltaWidth / 2,
                yTop = this.node.y + deltaHeight / 2,
                yBottom = this.node.y - deltaHeight / 2,
                newSize = {
                width: newWidth,
                height: newHeight
            },
                newPos = this._correctPosition(this.node.position, newSize);

            newPos = this._getShortestBoundaryPosition(newPos, newSize);

            if (Math.abs(xMin - (xLeft - halfNewWidth)) < BOUNDARY_PADDING) {
                newPos.x = xLeft;
            } else if (Math.abs(xMax - (xRight + halfNewWidth)) < BOUNDARY_PADDING) {
                newPos.x = xRight;
            }

            if (Math.abs(yMax - (yTop + halfNewHeight)) < BOUNDARY_PADDING) {
                newPos.y = yTop;
            } else if (Math.abs(yMin - (yBottom - halfNewHeight)) < BOUNDARY_PADDING) {
                newPos.y = yBottom;
            }

            this.node.scale = this.MAX_SCALE;
            this.node.runAction(cc.sequence(cc.moveTo(0.3, newPos), cc.callFunc(function () {
                self.node.runAction(self.heartBeatAction);
            })));
        }

        if (this.blinkAnimation && this.blinkAnimation.isRunning()) {
            this.blinkAnimation.stop();
        }
    },

    _changeToActiveState: function _changeToActiveState() {
        try {
            this.node.stopAction(this.heartBeatAction);
            if (this.node.scale >= this.MIN_SCALE && this.node.scale <= this.MAX_SCALE) {
                var action = cc.spawn([cc.scaleTo(0.2, 1), cc.moveTo(0.2, this._correctPosition(this.node.position))]);
                this.node.runAction(action);
            }
        } catch (e) {}

        this.node.opacity = ACTIVE_OPACITY;
        if (this.blinkAnimation) {
            this.blinkAnimation.play();
        }
    },

    _scheduleIdleState: function _scheduleIdleState() {
        this._cancelScheduleIdleState();
        this._idleTimeoutId = setTimeout(this._changeToIdleState.bind(this), IDLE_TIMEOUT);
    },

    _cancelScheduleIdleState: function _cancelScheduleIdleState() {
        if (this._idleTimeoutId) {
            clearTimeout(this._idleTimeoutId);
            this._idleTimeoutId = null;
        }
        this._changeToActiveState();
    },

    _updateTaiXiu: function _updateTaiXiu() {
        this._updateTaiXiuTimeLeft();
    },

    _updateTaiXiuTimeLeft: function _updateTaiXiuTimeLeft() {
        var gameRuntimeConfigs = GameManager.getGameRuntimeConfigs(GameConstant.TAI_XIU.CMD),
            gameManager = gameRuntimeConfigs && gameRuntimeConfigs.gameManager;
        if (gameManager) {
            this.taixiuTimeLeftLabel.string = gameManager.getFormattedCurrentTimeLeft();
        }
    },

    _savePosition: function _savePosition() {
        cc.sys.localStorage.setItem(MINIGAME_QUICK_ICON_POSITION_KEY, JSON.stringify({
            x: this.node.x,
            y: this.node.y
        }));
    },

    _loadPosition: function _loadPosition() {
        try {
            var position = JSON.parse(cc.sys.localStorage.getItem(MINIGAME_QUICK_ICON_POSITION_KEY));
            if (position && Utils.Type.isDefined(position.x) && Utils.Type.isDefined(position.y)) {
                return position;
            }
        } catch (e) {
            return null;
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameConstant":"GameConstant","GameManager":"GameManager","TinhNangManager":"TinhNangManager","UiManager":"UiManager","Utils":"Utils"}],"Modal":[function(require,module,exports){
"use strict";
cc._RFpush(module, '46a24g7mcRAkqwsne3udd+0', 'Modal');
// scripts\ui\Modal.js

var Utils = require('Utils'),
    CommonConstant = require('CommonConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        backdrop: cc.Node,
        content: cc.Label
    },

    start: function start() {
        this.node.zIndex = CommonConstant.ZINDEX.MODAL;
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.stopPropagationOnBackdrop = Utils.Node.stopPropagation(this.backdrop);
        this.node.stopAllActions();
        this.node.setScale(0.3);
        this.node.runAction(cc.spawn([cc.scaleTo(0.3, 1).easing(cc.easeBackOut()), cc.fadeIn(0.3)]));
    },

    onDisable: function onDisable() {
        if (this.stopPropagationOnBackdrop) {
            this.stopPropagationOnBackdrop();
            this.stopPropagationOnBackdrop = null;
        }
    },

    closeCallback: function closeCallback() {
        // not implement
    },

    close: function close() {
        var node = this.node,
            animation = cc.spawn([cc.scaleTo(0.2, 0.3).easing(cc.easeBackIn()), cc.fadeOut(0.2)]);
        node.stopAllActions();

        function destroy() {
            node.destroy();
        }
        node.runAction(cc.sequence([animation, cc.callFunc(destroy)]));
        this.closeCallback();
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","Utils":"Utils"}],"MultiScreen":[function(require,module,exports){
"use strict";
cc._RFpush(module, '77b02udFzRMcbE0T3qHXJjE', 'MultiScreen');
// scripts\ui\MultiScreen.js

cc.Class({
    "extends": cc.Component,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        var size = cc.winSize;
        var ratio_design = cc.Canvas.instance.designResolution.width / cc.Canvas.instance.designResolution.height;
        var ratio_current_screen = size.width / size.height;
        if (ratio_current_screen <= ratio_design) {
            cc.Canvas.instance.fitHeight = false;
            cc.Canvas.instance.fitWidth = true;
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"MultiSelect":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'd1b5a236N1BeIDUrVARo52V', 'MultiSelect');
// scripts\ui\MultiSelect.js

cc.Class({
    'extends': cc.Component,

    properties: {
        maxSelect: 1,
        activeSprite: {
            'default': null,
            type: cc.SpriteFrame
        },
        normalSprite: {
            'default': null,
            type: cc.SpriteFrame
        },
        selectEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.selectedItems = [];

        var item,
            i,
            that = this;

        function select(event) {
            that.selectItem(event.target);
        }
        for (i = 0; i < this.node.children.length; i += 1) {
            item = this.node.children[i];
            item.on(cc.Node.EventType.TOUCH_END, select, item);
        }
        this.node.on('child-added', function (event) {
            event.detail.on(cc.Node.EventType.TOUCH_END, select, event.detail);
        });
    },

    selectItem: function selectItem(item) {
        var removeItem,
            selectedItems = this.selectedItems,
            index = selectedItems.indexOf(item);
        if (item.parent === this.node) {
            if (index < 0) {
                if (selectedItems.length >= this.maxSelect) {
                    removeItem = selectedItems.shift(); // pop first
                    this.onUnselect(removeItem);
                }
                selectedItems.push(item);
                this.onSelect(item);
            } else {
                selectedItems.splice(index, 1);
                this.onUnselect(item);
            }
            this.selectEvents.forEach(function (selectEvent) {
                selectEvent.emit([selectedItems]);
            });
        }
    },

    onSelect: function onSelect(item) {
        if (this.activeSprite) {
            item.getComponent(cc.Sprite).spriteFrame = this.activeSprite;
        } else {
            item.stopAllActions();
            item.runAction(cc.scaleTo(0.1, 1.25));
        }
    },

    onUnselect: function onUnselect(item) {
        if (this.normalSprite) {
            item.getComponent(cc.Sprite).spriteFrame = this.normalSprite;
        } else {
            item.stopAllActions();
            item.runAction(cc.scaleTo(0.1, 1));
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"NapIap":[function(require,module,exports){
"use strict";
cc._RFpush(module, '54b3ctQ+ShM0Lz8kT6hDRx8', 'NapIap');
// scripts\components\nap_xien\NapIap.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    SysConfig = require('SysConfig'),
    NetworkManager = require('NetworkManager'),
    PlatformImplement = require('PlatformImplement');

cc.Class({
    'extends': cc.Component,

    properties: {
        iapItemPrefab: cc.Prefab,
        iapScrollView: cc.ScrollView
    },

    onLoad: function onLoad() {
        PlatformImplement.eventDispatcher.addEventListener(PlatformImplement.Event.IAP_PURCHASE_FAIL, this._onIapPurchaseFail, this);
        PlatformImplement.eventDispatcher.addEventListener(PlatformImplement.Event.IAP_PURCHASE_SUCCESS, this._onIapPurchaseSuccess, this);
    },

    onEnable: function onEnable() {
        this.fetchIapType();
    },

    fetchIapType: function fetchIapType() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.IAP_TYPES, {
            username: AuthUser.username,
            provider: SysConfig.IAP_PROVIDER
        }, {
            cache: 900,
            delay: 500
        }).success(function (iapResp) {
            var iapItemNode,
                iapItems = iapResp.data;
            that.iapScrollView.content.removeAllChildren();
            for (var i = 0; i < iapItems.length; i += 1) {
                iapItemNode = cc.instantiate(that.iapItemPrefab);

                that.iapScrollView.content.addChild(iapItemNode);
            }
            that.iapScrollView.scrollToPercentHorizontal(0.5);
        });
    },

    onDestroy: function onDestroy() {
        PlatformImplement.eventDispatcher.removeEventListener(PlatformImplement.Event.IAP_PURCHASE_FAIL, this._onIapPurchaseFail, this);
        PlatformImplement.eventDispatcher.removeEventListener(PlatformImplement.Event.IAP_PURCHASE_SUCCESS, this._onIapPurchaseSuccess, this);
    },

    _onIapPurchaseFail: function _onIapPurchaseFail() {},

    _onIapPurchaseSuccess: function _onIapPurchaseSuccess(param) {
        NetworkManager.Http.fetch('POST', Url.Http.IAP_VERIFY, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            receipt: param.receipt,
            signature: param.signature
        });
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","SysConfig":"SysConfig","Url":"Url"}],"NapThe":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'ca92azwsylDwr9rzr4cdYQs', 'NapThe');
// scripts\components\nap_xien\NapThe.js

var NetworkManager = require('NetworkManager'),
    UiManager = require('UiManager'),
    AuthUser = require('AuthUser'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        tcaoScrollView: cc.ScrollView,
        tcaoItemPrefab: cc.Prefab,
        tcaoHintLabel: cc.Label,
        pinEditBox: cc.EditBox,
        serialEditBox: cc.EditBox
    },

    onEnable: function onEnable() {
        this.fetchTheCaoInfo();
    },

    fetchTheCaoInfo: function fetchTheCaoInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.THE_CAO_TYPES, {
            username: AuthUser.username
        }, {
            cache: 900,
            delay: 500
        }).success(function (tcaoResp) {
            var tcaoItemNode,
                icaoComponent,
                tcaoItems = tcaoResp.data;
            that.tcaoHintLabel.string = tcaoResp.data_hint;
            that.tcaoScrollView.content.removeAllChildren();
            for (var i = 0; i < tcaoItems.length; i += 1) {
                tcaoItemNode = cc.instantiate(that.tcaoItemPrefab);
                tcaoItemNode.cardType = tcaoItems[i].name;
                icaoComponent = tcaoItemNode.getComponent('ItemThe');
                icaoComponent.updateData(tcaoItems[i]);
                that.tcaoScrollView.content.addChild(tcaoItemNode);
            }
            that.tcaoScrollView.scrollToLeft();
        });
    },

    napTheCao: function napTheCao(event) {
        var cardType,
            selectComp = this.tcaoScrollView.content.getComponent('MultiSelect');
        if (selectComp.selectedItems.length < 1) {
            return UiManager.openModal('Xin vui lòng chọn loại thẻ cào.');
        }
        if (this.pinEditBox.string.length < 1) {
            return UiManager.openModal('Xin vui lòng nhập mã pin.');
        } else {
            cardType = selectComp.selectedItems[0].cardType;
            NetworkManager.Http.fetch('POST', Url.Http.NAP_THE_CAO, {
                username: AuthUser.username,
                accesstoken: AuthUser.accesstoken,
                card_type: cardType,
                pin: this.pinEditBox.string,
                serial: this.serialEditBox.string
            }).success(function () {
                UiManager.openModal('Xin chúc mừng, bạn đã nạp thẻ thành công.');
            }).setWaitingButton(event.target);
        }
    },

    selectCard: function selectCard(selectedCards) {
        if (selectedCards.length > 0) {
            var selectedCard = selectedCards[0];
            if (selectedCard.cardType === 'IP') {
                this.serialEditBox.node.active = false;
            } else {
                this.serialEditBox.node.active = true;
            }
        }
    },

    // use this for initialization
    onLoad: function onLoad() {}

});

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"NapTinNhan":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7a131i9Xr9MBY8cTR0nRDbZ', 'NapTinNhan');
// scripts\components\nap_xien\NapTinNhan.js

var PlatformImplement = require('PlatformImplement'),
    NetworkManager = require('NetworkManager'),
    AuthUser = require('AuthUser'),
    DropDown = require('DropDown'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        tongDaiDropDown: DropDown,
        tnItemPrefab: cc.Prefab,
        tnScrollView: cc.ScrollView
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.fetchTinNhanTypes();
    },

    fetchTinNhanTypes: function fetchTinNhanTypes() {
        var that = this,
            nhaMang = PlatformImplement.getNhaMang(),
            selectedTelco = this.tongDaiDropDown.getSelectedItem();
        NetworkManager.Http.fetch('GET', Url.Http.TIN_NHAN_TYPES, {
            username: AuthUser.username,
            telco: selectedTelco || nhaMang
        }, {
            cache: 900,
            delay: 500
        }).success(function (tnResp) {
            var tnItemNode,
                i,
                telco = tnResp.telco,
                tnItems = tnResp.data;
            that.tnScrollView.content.removeAllChildren();
            for (i = 0; i < tnItems.length; i += 1) {
                tnItemNode = cc.instantiate(that.tnItemPrefab);
                tnItemNode.getComponent('ItemTinNhan').updateData(tnItems[i]);
                that.tnScrollView.content.addChild(tnItemNode);
            }
            if (!selectedTelco) {
                that.tongDaiDropDown.clearAllItems();
                for (i = 0; i < telco.length; i += 1) {
                    that.tongDaiDropDown.addItem(telco[i], RegExp(telco[i], 'i').test(nhaMang));
                }
            }

            that.tnScrollView.scrollToPercentHorizontal(0.5);
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","DropDown":"DropDown","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","Url":"Url"}],"NapXu":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f21f6HkXeRGPab3wThiwH1M', 'NapXu');
// scripts\components\nap_xien\NapXu.js

var EventDispatcherConstant = require('EventDispatcherConstant'),
    EventDispatcher = require('EventDispatcher'),
    NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant'),
    UiManager = require('UiManager'),
    AuthUser = require('AuthUser'),
    Slider = require('Slider'),
    Utils = require('Utils'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        ipAmountLabel: cc.Label,
        ipLabel: cc.Label,
        ipSlider: Slider,

        xuAmountLabel: cc.Label,
        infoLabel: cc.Label,
        xuLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.ipLabel.string = 'Số dư ' + CommonConstant.CurrencyType.Ip.DISPLAY_NAME;
        this.xuLabel.string = 'Số ' + CommonConstant.CurrencyType.Xu.DISPLAY_NAME + ' nhận được';
        this.ipSlider.setDefaultValue(0, 0, 0);
        this.updateUserMoney();
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
    },

    onEnable: function onEnable() {
        this.fetchNapInfo();
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
    },

    updateUserMoney: function updateUserMoney() {
        var ipBalance = AuthUser.currencies[CommonConstant.CurrencyType.Ip.NAME].balance;
        this.ipAmountLabel.string = Utils.Number.format(ipBalance);
        this.xuAmountLabel.string = '';
        this.ipAmount = 0;
        if (this.napInfo) {
            if (this.napInfo.min_ip > ipBalance) {
                this.ipSlider.node.active = false;
                this.infoLabel.node.active = true;
                this.infoLabel.string = 'Để chuyển được sang ' + CommonConstant.CurrencyType.Xu.DISPLAY_NAME + ' thì số dư ' + CommonConstant.CurrencyType.Ip.DISPLAY_NAME + ' tối thiểu là ' + Utils.Number.format(this.napInfo.min_ip);
            } else {
                this.ipSlider.node.active = true;
                this.infoLabel.node.active = false;
                this.ipSlider.setDefaultValue(this.napInfo.min_ip, ipBalance, 0);
            }
        }
    },

    fetchNapInfo: function fetchNapInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.MONEY_EX, {}, {
            cache: 1800
        }).success(function (resp) {
            that.napInfo = resp.data;
            that.updateUserMoney();
        });
    },

    // call when user slide ip slider
    updateIPAmount: function updateIPAmount(slideComponent) {
        if (this.napInfo) {
            this.ipAmount = slideComponent.currentValue;
            this.xuAmountLabel.string = Utils.Number.format(Math.floor(this.ipAmount * this.napInfo.ip_to_xu));
        }
    },

    confirmNapXu: function confirmNapXu(event) {
        if (this.ipAmount > 0) {
            NetworkManager.Http.fetch('POST', Url.Http.MONEY_EX, {
                username: AuthUser.username,
                accesstoken: AuthUser.accesstoken,
                amount: this.ipAmount,
                currency_from: CommonConstant.CurrencyType.Ip.NAME,
                currency_to: CommonConstant.CurrencyType.Xu.NAME
            }).success(function () {
                UiManager.openModal('Xin chúc mừng, bạn đã chuyển thành công.');
            }).setWaitingButton(event.target);
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","NetworkManager":"NetworkManager","Slider":"Slider","UiManager":"UiManager","Url":"Url","Utils":"Utils"}],"NetworkManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '35751alSNxLAYT4BmsbR/Ll', 'NetworkManager');
// scripts\network\NetworkManager.js

var IplayHttp = require('IplayHttp'),
    SysConfig = require('SysConfig'),
    UiManager = require('UiManager'),
    SmartFox = require('SmartFox'),
    EventDispatcher = require('EventDispatcher'),
    PlatformImplement = require('PlatformImplement'),
    EventDispatcherConstant = require('EventDispatcherConstant');

var httpConfig = SysConfig.IplayHttp;

IplayHttp.init(httpConfig.HOST, httpConfig.PORT, httpConfig.PROTOCOL, httpConfig.AUTH_USER, httpConfig.AUTH_PASS);
IplayHttp.addInterceptor({
    request: function request(method, path, params) {
        // auto add 'cp' param to every request
        params.cp = SysConfig.CP;
    },
    response: function response(xhr) {
        if (xhr.status >= 200 && xhr.status < 400) {
            var antidosUrl = xhr.getResponseHeader('AntiDos');
            if (antidosUrl) {
                UiManager.openModal('Bạn vui lòng xác thực để có thể tiếp tục chơi game!', {
                    close_fn: function close_fn() {
                        PlatformImplement.openWebUrl(antidosUrl);
                    }
                });
            } else if (xhr.responseJson) {
                if (xhr.responseJson.status === 30) {
                    UiManager.openConfirmModal('Phiên đăng nhập của bạn đã hết hạn. Bạn có muốn thoát ra để đăng nhập lại không?', {
                        oke_fn: function oke_fn() {
                            PlatformImplement.returnLoginPage();
                        }
                    });
                } else if (xhr.responseJson.status !== 1) {
                    UiManager.openModal(xhr.responseJson.msg);
                }
            }
        } else {
            UiManager.openModal('Lỗi ' + xhr.status + ': ' + xhr.statusText);
        }
    }
});

EventDispatcher.addEventListener(EventDispatcherConstant.AUTH.LOGOUT, function () {
    IplayHttp.resetCache();
});

module.exports = {
    Http: IplayHttp,
    SmartFox: SmartFox
};

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","IplayHttp":"IplayHttp","PlatformImplement":"PlatformImplement","SmartFox":"SmartFox","SysConfig":"SysConfig","UiManager":"UiManager"}],"Pagination":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'aba18CuTRFC2oiIcw6qzgAL', 'Pagination');
// scripts\ui\Pagination.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        buttonTemplateNode: cc.Node,
        normalColor: cc.Color,
        activeColor: cc.Color,
        buttonListNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(pageListInfo, handler) {
        var pageList = pageListInfo.pageList || pageListInfo.page_list,
            jumpFirst = pageListInfo.jumpFirst || pageListInfo.jump_first,
            jumpLast = pageListInfo.jumpLast || pageListInfo.jump_last,
            currentPage = pageListInfo.currentPage || pageListInfo.current_page || 0,
            page,
            i;

        this.buttonListNode.removeAllChildren();

        if (jumpFirst) {
            this._addPageButton(false, {
                jumpFirst: jumpFirst
            }, handler);
        }

        for (i = 0; i < pageList.length; i += 1) {
            page = pageList[i];
            this._addPageButton(page === currentPage, {
                page: page
            }, handler);
        }

        if (jumpLast) {
            this._addPageButton(false, {
                jumpLast: jumpLast
            }, handler);
        }
    },

    _addPageButton: function _addPageButton(isCurrentPage, pageInfo, handler) {
        var node = cc.instantiate(this.buttonTemplateNode),
            nodeLabel = node.getComponentInChildren(cc.Label),
            page = pageInfo.page,
            self = this;

        if (pageInfo.jumpFirst) {
            page = '<<';
        } else if (pageInfo.jumpLast) {
            page = '>>';
        }
        nodeLabel.string = page;
        this._setButtonState(node, isCurrentPage);

        node.on(cc.Node.EventType.TOUCH_START, (function (pageInfo) {
            return function () {
                var children = self.buttonListNode.getChildren(),
                    child,
                    i;
                for (i = 0; i < children.length; i += 1) {
                    child = children[i];
                    if (child === this) {
                        self._setButtonState(child, true);
                    } else {
                        self._setButtonState(child, false);
                    }
                }
                if (Utils.Type.isFunction(handler)) {
                    handler(pageInfo);
                }
            };
        })(pageInfo), node);

        node.active = true;

        this.buttonListNode.addChild(node);
    },

    _setButtonState: function _setButtonState(buttonNode, isActive) {
        buttonNode.getComponentInChildren(cc.Label).node.color = isActive ? this.activeColor : this.normalColor;
    }
});

cc._RFpop();
},{"Utils":"Utils"}],"PhomConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e0e8fgbmsRLbJiVwEx0hsA4', 'PhomConstant');
// scripts\games\phom\PhomConstant.js

module.exports = {
    Action: {
        DISCARD: 0,
        TAKE_CARD: 1,
        ORDER_HAND: 2,
        PICK_CARD: 3,
        SENT_CARD: 4,
        SHOW_OFF: 5,
        AUTO_SHOW_OFF: 6,
        CHANGE_TURN: 7,
        U_PHOM: 8
    },
    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        PLAYING: 5,
        FINALIZING: 6,
        FINISH: 7
    },
    Finish: {
        U: 0,
        THUA_TINH_DIEM: 1,
        VE_NHI: 2,
        VE_BA: 3,
        VE_BET: 4,
        MOM: 5,
        AN_1_CAY: 6,
        AN_2_CAY: 7,
        AN_3_CAY: 8,
        AN_CHOT: 9,
        VE_NHAT: 10
    },
    PlayerState: {
        WAITING: 0,
        READY: 1,
        IN_TURN: 2,
        OUT_TURN: 3,
        WAITING_FOR_TURN: 4,
        FINISH: 5
    },
    InTurnState: {
        PICK_OR_TAKE_CARD: 0,
        DISCARD: 1,
        SHOW_OFF: 2,
        SEND: 3
    },
    Event: {
        START_GAME: 'in_game.phom.start_game',
        ADD_PLAYER: 'in_game.phom.add_player',
        REMOVE_PLAYER: 'in_game.phom.remove_player',
        UPDATE_PLAYER: 'in_game.phom.update_player',
        UPDATE_GAME: 'in_game.phom.update_game',
        UPDATE_MASTER: 'in_game.phom.update_master',
        UPDATE_HAND: 'in_game.phom.update_hand',
        DRAW_CARD: 'in_game.phom.draw_card',
        TIME_START: 'in_game.phom.time_start',
        CHANGE_TURN: 'in_game.phom.change_turn',
        DISCARD: 'in_game.phom.discard_response',
        PICK_CARD: 'in_game.phom.pick_card',
        TAKE_CARD: 'in_game.phom.take_card',
        SHOW_OFF: 'in_game.phom.show_off',
        AUTO_SHOW_OFF: 'in_game.phom.auto_show_off',
        SENT_CARD: 'in_game.phom.sent_card',
        SUBMIT_FAILT: 'in_game.phom.sumbit_fail',
        REFRESH_GAME: 'in_game.phom.refresh_game',
        WAITING_DEAL_CARD: 'in_game.phom.waiting_deal_card',
        FINISH_GAME: 'in_game.phom.finish_game'
    },

    Effect: {
        DANG_DANH: 0,
        DANG_HA: 1,
        DANG_BOC: 2,
        DANG_GUI: 3,
        MOM: 4,
        U: 5,
        NHAT: 6,
        NHI: 7,
        BA: 8,
        BET: 9,
        DEN_U: 10,
        TAI_LUOT: 11,
        U_KHONG_CA: 12,
        U_TRON: 13,
        DANG_DOI: 14
    },

    GetTypeAction: function GetTypeAction(action) {
        switch (action) {
            case 0:
                return 'discard';
            case 1:
                return 'takecard';
            case 2:
                return 'orderhand';
            case 3:
                return 'pickcard';
            case 4:
                return 'sentcard';
            case 5:
                return 'showoff';
            case 6:
                return 'autoshowoff';
            case 7:
                return 'changeturn';
            default:
                return action;
        }
    }

};

cc._RFpop();
},{}],"PhomGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1b1aeykCGtH3KYbjHTsYP74', 'PhomGameManager');
// scripts\games\phom\PhomGameManager.js

var BaseGameManager = require('BaseGameManager'),
    NetworkManager = require('NetworkManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    PhomConstant = require('PhomConstant'),
    Utils = require('Utils'),
    PhomGameManager;

PhomGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);
        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_HAND.ID, this.onUpdateHand, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.PLAY.ID, this.onPlay, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaitingDealCard, this);

        // các action của game play
        this.gameType = 1;
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.UPDATE_GAME, params);
    },

    onFinishGame: function onFinishGame(params) {
        this.gameState = PhomConstant.GameState.FINISH;
        this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.FINISH_GAME, params);
    },

    onPlay: function onPlay(params) {
        var action = params.action;
        this.gameState = PhomConstant.GameState.PLAYING;
        switch (action) {
            case PhomConstant.Action.DISCARD:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.DISCARD, params);
                break;
            case PhomConstant.Action.TAKE_CARD:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.TAKE_CARD, params);
                break;
            case PhomConstant.Action.PICK_CARD:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.PICK_CARD, params);
                break;
            case PhomConstant.Action.SENT_CARD:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.SENT_CARD, params);
                break;
            case PhomConstant.Action.SHOW_OFF:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.SHOW_OFF, params);
                break;
            case PhomConstant.Action.AUTO_SHOW_OFF:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.AUTO_SHOW_OFF, params);
                break;
            case PhomConstant.Action.CHANGE_TURN:
                this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.CHANGE_TURN, params);
                break;
        }
    },

    onUpdateHand: function onUpdateHand(params) {
        this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.UPDATE_HAND, params.allData);
    },

    onWaitingDealCard: function onWaitingDealCard(params) {
        this.gameState = PhomConstant.GameState.WAITING_FOR_NEW_GAME;
        this.eventDispatchers.local.dispatchEvent(PhomConstant.Event.WAITING_DEAL_CARD, params);
    },

    // ============================================================
    // Request API
    // ============================================================

    sendRequestStartGame: function sendRequestStartGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.DEAL_CARD.ID)
        });
    },

    requestSentCard: function requestSentCard(card, cards) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.SENT_CARD),
            card: NetworkManager.SmartFox.type.byte(card),
            cards: NetworkManager.SmartFox.type.byteArray(cards)
        });
    },

    requestTakeCard: function requestTakeCard() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.TAKE_CARD)
        });
    },

    requestShowOff: function requestShowOff(cards) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.SHOW_OFF),
            cards: NetworkManager.SmartFox.type.byteArray(cards)
        });
    },

    requestPickCard: function requestPickCard() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.PICK_CARD)
        });
    },

    requestDicard: function requestDicard(card) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.DISCARD),
            card: NetworkManager.SmartFox.type.byte(card.getId())
        });
    },

    requestUPhom: function requestUPhom() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PhomConstant.Action.U_PHOM)
        });
    }

});

module.exports = PhomGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","PhomConstant":"PhomConstant","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"PhomOptionModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, '6ad70xnoMVBCoYbOoLRZ6q1', 'PhomOptionModal');
// scripts\components\games\phom\PhomOptionModal.js

var BaseGameOptionModal = require('BaseGameOptionModal'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': BaseGameOptionModal,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    _playUGameType: function _playUGameType(isUTron) {
        this.gameConfigs = this.gameConfigs || {};
        this.gameConfigs.acceptUTron = NetworkManager.SmartFox.type.bool(isUTron);
        this.enterGame();
    },

    playUTronGameType: function playUTronGameType() {
        this._playUGameType(true);
    },

    playUThuongGameType: function playUThuongGameType() {
        this._playUGameType(false);
    }
});

cc._RFpop();
},{"BaseGameOptionModal":"BaseGameOptionModal","NetworkManager":"NetworkManager"}],"PhomUtils":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'a8cf1Fy/MlLI5fDVaCynoeY', 'PhomUtils');
// scripts\components\games\phom\PhomUtils.js

var Card = require('Card');

var getRandom = function getRandom(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

var mixArray = function mixArray(array) {
    var tmpCard, j;
    for (var i = 0; i < array.length; i += 1) {
        tmpCard = array[i];
        j = getRandom(i, array.length - 1);
        array[i] = array[j];
        array[j] = tmpCard;
    }
};

var generatePackCards = function generatePackCards() {
    var result = [];
    // var test = [0, 1, 2, 3, 4, 21, 34, 7, 8, 14, 16, 18, 20];
    // for (var i = 0; i < 12; i += 1) {
    //     result.push(Card.fromId(test[i]));
    // }
    for (var i = 0; i < 52; i += 1) {
        result.push(Card.fromId(i));
    }
    mixArray(result);
    return result.slice(0, 12);
    // return result;
};

var arrangePositionCards = function arrangePositionCards(cards, nodes, hasEffect, cardPrefab) {
    nodes.removeAllChildren();
    for (var i = 0; i < cards.length; i += 1) {
        var cardNew;
        cardNew = cc.instantiate(cardPrefab);
        var cardUIPhom = cardNew.getComponent('CardUIPhom');
        cardNew.parent = nodes;
        cardUIPhom.setCard(Card.fromId(cards[i].getId()));
        cardUIPhom.interactable = true;
        cardUIPhom.canMove = true;
        cardNew.position = cc.p(0, 0);
        if (hasEffect) {
            cardNew.setScaleX(0.1);
            cardNew.runAction(cc.scaleTo(0.3, 1));
        }
    }
};
var arrangeCardsOptimize = function arrangeCardsOptimize(cards, isDoi) {
    // var hasInterestedCard = [];
    // var notInterestedCard = [];
    // for (var i = 0; i < cards.length - 1; i += 1) {
    //     var check = false;
    //     for (var j = 0; j < cards.length; j += 1) {
    //         if (checkInterestedCard(cards[i], cards[j])) {
    //             check = true;
    //             break;
    //         }
    //     }
    //     if (check) {
    //         hasInterestedCard.push(cards[i]);
    //     } else {
    //         notInterestedCard.push(cards[i]);
    //     }
    // }
    // if (isDoi) {
    //     return arrangeCardsOptimizeWithDoi1(hasInterestedCard);
    // } else {
    //     return arrangeCardsOptimizeWithSanh1(hasInterestedCard);
    // }
    // return arrangeCardsOptimizeWithDoi1(hasInterestedCard);

    if (isDoi) {
        return arrangeCardsOptimizeWithDoi(cards);
    } else {
        return arrangeCardsOptimizeWithSanh(cards);
    }
    return arrangeCardsOptimizeWithDoi(cards);
};

// var arrangeCardsOptimizeWithDoi1 = function (cards) {

// };

// var arrangeCardsOptimizeWithSanh1 = function (cards) {

// };

// var checkInterestedCard = function (c1, c2) {
//     if (c1.rank.ID === c2.rank.ID) {
//         return true;
//     }
//     if (c1.suit.ID === c2.suit.ID) {
//         if (c1.rank.ID === c2.rank.ID - 1 || c1.rank.ID === c2.rank.ID - 2) {
//             return true;
//         }
//     }
//     return false;
// };

// sắp xếp theo độ ưu tiên đôi
var arrangeCardsOptimizeWithDoi = function arrangeCardsOptimizeWithDoi(cards) {
    // limit - index chứa phỏm
    var resultCards = cards.slice();
    var tmp,
        limit = 0;

    // thứ tự tối ưu: Phỏm(đôi)-> phỏm sảnh -> đôi + lẻ or sảnh -> sảnh lẻ
    // Đưa phỏm đôi -> sảnh lên đầu
    // Xếp ưu tiên đôi -> sảnh
    resultCards = arrangeCardsDecrease(resultCards);
    resultCards = arrangeCardsByDoi(resultCards);
    tmp = arrangeCardsByPhomDoiFirst(resultCards);
    resultCards = tmp[0];
    limit += tmp[1];

    if (limit >= resultCards.Count) {
        return resultCards;
    }

    // Sắp xếp lại sau khi đưa phỏm đôi lên đầu
    // sắp xếp giảm dần -> sắp xếp đôi
    // Sắp xếp đưa phỏm sảnh lên đầu
    resultCards = arrangeCardsDecreaseWithLimit(resultCards, limit);
    resultCards = arrangeCardsBySanhWithLimit(resultCards, limit);
    tmp = arrangeCardsByPhomSanhFirst(resultCards, limit);
    resultCards = tmp[0];
    limit += tmp[1];

    if (limit >= resultCards.Count) {
        return resultCards;
    }

    tmp = arrangePhomDoiWithSanh(resultCards, limit);
    limit += tmp[1];
    resultCards = tmp[0];
    if (limit >= resultCards.Count) {
        return resultCards;
    }

    // -- sau khi xếp phỏm đôi, sảnh lên đầu --
    // xếp ưu tiên đôi
    resultCards = arrangeCardsDecreaseWithLimit(resultCards, limit);
    resultCards = arrangeCardsByDoiWithLimit(resultCards, limit);

    //xêp ưu tiên sảnh sau khi ưu tiên đôi
    var tmpCards;
    tmpCards = getCardAloneChuaSanhWithLimit(resultCards, limit);
    if (tmpCards.length > 0) {
        tmpCards = arrangeCardsBySanh(tmpCards);
        resultCards = insertListAtLast(resultCards, tmpCards);
    }

    // xếp card lẻ k chứa sảnh với đôi
    tmpCards = getCardsFA(tmpCards);
    if (tmpCards.length > 0) {
        // đưa có lá bài lẻ chứa sảnh với đôi lên trên
        arrangeCardsByDoiSanh(resultCards, tmpCards, limit);
    }

    return resultCards;
};

var arrangeCardsOptimizeWithSanh = function arrangeCardsOptimizeWithSanh(cards) {

    var limit = 0;
    var tmp = 0;
    var resultCards = cards.slice();
    resultCards = arrangeCardsDecrease(resultCards);
    resultCards = arrangeCardsBySanh(resultCards);
    tmp = arrangeCardsByPhomSanhFirst(resultCards);
    limit += tmp[1];
    resultCards = tmp[0];
    if (limit >= resultCards.Count) {
        return resultCards;
    }

    // sắp xếp đưa phỏm đôi lên đầu
    resultCards = arrangeCardsDecreaseWithLimit(resultCards, limit);
    resultCards = arrangeCardsByDoiWithLimit(resultCards, limit);
    tmp = arrangeCardsByPhomDoiFirst(resultCards, limit);
    limit += tmp[1];
    resultCards = tmp[0];
    if (limit >= resultCards.Count) {
        return resultCards;
    }

    resultCards = arrangeCardsDecreaseWithLimit(resultCards, limit);
    resultCards = arrangeCardsBySanhWithLimit(resultCards, limit);

    // xêp ưu tiên sảnh sau khi ưu tiên đôi
    var tmpCards = getCardsAloneChuaDoiWithLimit(resultCards, limit);
    if (tmpCards && tmpCards.length > 0) {
        tmpCards = arrangeCardsByDoi(tmpCards);
        resultCards = insertListAtLast(resultCards, tmpCards);
    }
    tmpCards = getCardAloneChuaSanhWithLimit(tmpCards, 0);
    if (tmpCards && tmpCards.length > 0) {
        resultCards = arrangeCardsBySanhDoi(resultCards, tmpCards, limit);
    }
    return resultCards;
};

// sắp xếp theo tứ thự giảm dần
var arrangeCardsDecrease = function arrangeCardsDecrease(cards) {
    var tempCard;
    for (var i = 0; i < cards.length; i += 1) {
        for (var j = i + 1; j < cards.length; j += 1) {
            if (cards[i] && cards[j] && cards[i].getId() > cards[j].getId()) {
                tempCard = cards[i];
                cards[i] = cards[j];
                cards[j] = tempCard;
            }
        }
    }
    return cards.reverse();
};

// sắp xếp theo tứ thự giảm dần với limit
var arrangeCardsDecreaseWithLimit = function arrangeCardsDecreaseWithLimit(cards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    tmpCards = arrangeCardsDecrease(tmpCards);

    return insertListAtLast(cards, tmpCards);
};

// sắp xếp các bộ đội lên đầu
var arrangeCardsByDoi = function arrangeCardsByDoi(cards) {

    var resultCards = cards.slice();
    var index = cards.length - 1,
        delta = 0;

    while (index > 0) {
        if (cards[index].rank === cards[index - 1].rank) {
            resultCards.splice(index - 1 + delta, 2);
            resultCards.splice(0, 0, cards[index]);
            resultCards.splice(0, 0, cards[index - 1]);

            if (index - 2 < 0) {
                break;
            }
            if (cards[index].rank === cards[index - 2].rank) {
                resultCards.splice(index + delta, 1);
                resultCards.splice(0, 0, cards[index - 2]); // insert(index,value)

                if (index - 3 < 0) {
                    break;
                }
                if (cards[index].rank === cards[index - 3].rank) {

                    resultCards.splice(index + delta, 1); // remove at (index)
                    resultCards.splice(0, 0, cards[index - 3]);

                    delta += 4;
                    index -= 3;

                    continue;
                }

                delta += 3;
                index -= 2;

                continue;
            }
            delta += 2;
        }
        index -= 1;
    }
    return resultCards;
};

var arrangeCardsByDoiWithLimit = function arrangeCardsByDoiWithLimit(cards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    tmpCards = arrangeCardsByDoi(tmpCards);

    return insertListAtLast(cards, tmpCards);
};

// sắp xếp các quân bài theo sảnh k chứa các quân bài có bộ đôi
var arrangeCardsBySanh = function arrangeCardsBySanh(cards) {
    var index = 0;
    var tmpCards = [];
    while (index < cards.length - 1) {
        for (var i = index + 1; i < cards.length; i += 1) {
            if (cards[index].suit === cards[i].suit) {
                if (cards[index].rank.ID - 1 === cards[i].rank.ID || cards[index].rank.ID - 2 === cards[i].rank.ID) {
                    tmpCards = addItemAtLast(tmpCards, cards[index]);
                    tmpCards = addItemAtLast(tmpCards, cards[i]);
                    cards = moveItemInArray(cards, i, index + 1);
                    break;
                }
                continue;
            }
        }
        index += 1;
    }
    return insertListAtFirst(cards, tmpCards);
};

var arrangeCardsBySanhWithLimit = function arrangeCardsBySanhWithLimit(cards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    tmpCards = arrangeCardsBySanh(tmpCards);

    return insertListAtLast(cards, tmpCards);
};

// sắp xếp phỏm đôi có 4 lá chứa 1 card tạo đc phỏm sảnh
var arrangePhomDoiWithSanh = function arrangePhomDoiWithSanh(cards, limit) {
    var out = 0;
    if (limit < 4) {
        return [cards, out];
    }
    var tmpCards = cards.slice(0, limit);
    tmpCards = arrangeCardsDecrease(tmpCards);
    tmpCards = arrangeCardsByDoi(tmpCards);
    var tmp;
    tmp = arrangeCardsByPhomDoiFirst(tmpCards, tmp);
    if (tmp[1] < 4) {
        return [cards, out];
    }
    tmpCards = tmp[0];
    tmp = tmp[1];
    var compareCards = cards.slice(limit, cards.length);
    var index = 0;
    var check = [];
    while (index < tmp - 1) {
        if (tmpCards.length < index + 4) {
            break;
        }
        if (isPhomDoi(tmpCards.slice(index, index + 4))) {
            var xCards = tmpCards.slice(index, index + 4);

            for (var i = 0; i < xCards.length; i += 1) {
                check = [];
                check = getCardsPhomSanhByCard(xCards[i], compareCards);
                if (check.length > 2) {
                    tmpCards.splice(index + 1, 1);
                    out = check.length - 1;
                    tmpCards = insertListAtFirst(tmpCards, check);
                    break;
                }
            }
        }
        index += 3;
    }
    cards = insertListAtFirst(cards, tmpCards);
    return [cards, out];
};

// di chuyển gần phỏm sảnh gần đôi trong phỏm
var arrangeCardsByDoiSanh = function arrangeCardsByDoiSanh(cards, otherCards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    var index = otherCards.length - 1;
    var max = tmpCards.length - otherCards.length;
    if (max < 2 || otherCards.length < 1) {
        return cards;
    }
    while (index >= 0) {
        for (var i = 0; i < max; i += 1) {
            if (is2CardBoSanh(otherCards[index], tmpCards[i]) || is2CardBoSanh(tmpCards[i], otherCards[index])) {
                tmpCards.splice(i + 1, 0, otherCards[index]);
                tmpCards.splice(max + index + 1, 1);
                max += 1;
                break;
            }
        }
        index -= 1;
    }
    return insertListAtLast(cards, tmpCards);
};

var arrangeCardsBySanhDoi = function arrangeCardsBySanhDoi(cards, otherCards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    var index = otherCards.length - 1;
    var max = tmpCards.length - otherCards.length;
    if (max < 2 || otherCards.length < 1) {
        return cards;
    }

    while (index >= 0) {
        for (var i = 0; i < max; i += 1) {
            if (is2CardBoDoi(otherCards[index], tmpCards[i])) {
                tmpCards.splice(i + 1, 0, otherCards[index]);
                tmpCards.splice(max + index + 1, 1);
                index -= 1;
                max += 1;
                break;
            }
        }
        index -= 1;
    }
    return insertListAtLast(cards, tmpCards);
};

// lấy phỏm sảnh lá theo card
var getCardsPhomSanhByCard = function getCardsPhomSanhByCard(card, cards) {
    var tmpCards;
    cards.push(card);
    cards = arrangeCardsDecreaseWithLimit(cards, 0);
    cards = arrangeCardsBySanh(cards, 0);
    tmpCards = arrangeCardsByPhomSanhFirst(cards, 0);

    if (tmpCards[1] < 3) {
        return [];
    }
    cards = tmpCards[0].slice(0, tmpCards[1]);
    return cards;
};

// lấy ra các quân bài lẻ k chứa đôi
var getCardAloneChuaSanh = function getCardAloneChuaSanh(cards) {
    if (cards.length < 2) {
        return cards;
    }
    for (var i = cards.length - 1; i > 0; i -= 1) {
        if (cards[i].rank === cards[i - 1].rank) {
            if (i + 1 < cards.length) {
                return cards.slice(i + 1, cards.length);
            }
        }
    }
    return cards;
};

var getCardAloneChuaSanhWithLimit = function getCardAloneChuaSanhWithLimit(cards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    return getCardAloneChuaSanh(tmpCards);
};

// lấy các quân bài lẻ k chứa sảnh
var getCardsAloneChuaDoi = function getCardsAloneChuaDoi(cards) {
    if (cards.length) {
        return cards;
    }
    for (var i = cards.length - 2; i > 0; i -= 1) {
        if (is2CardBoSanh(cards[i - 1], cards[i])) {
            return cards.slice(i + 1, cards.length - 2);
        }
    }
    return cards;
};

var getCardsAloneChuaDoiWithLimit = function getCardsAloneChuaDoiWithLimit(cards, limit) {
    var tmpCards = cards.slice(limit, cards.length);
    return getCardsAloneChuaDoi(tmpCards);
};

// lấy ra các quân bài lẻ k chứa đôi. k chua sanh
var getCardsFA = function getCardsFA(cards) {
    if (cards.length < 2) {
        return cards;
    }
    for (var i = cards.length - 2; i > 0; i -= 1) {
        if (is2CardBoSanh(cards[i], cards[i - 1])) {
            return cards.slice(i + 1, cards.length - 2);
        }
    }
    return cards;
};

// sắp xếp các phỏm đôi lên đầu tiên
var arrangeCardsByPhomDoiFirst = function arrangeCardsByPhomDoiFirst(cards) {
    var tmpCards = cards.slice();
    var checkCards = [];
    var index = cards.length - 1;
    var limit = 0;

    while (index > 1) {
        if (checkCards.length > 0) {
            checkCards = [];
        }
        if (index > 2) {
            checkCards.push(cards[index]);
            checkCards.push(cards[index - 1]);
            checkCards.push(cards[index - 2]);
            checkCards.push(cards[index - 3]);

            if (isPhomDoi(checkCards)) {
                checkCards.reverse();
                tmpCards = insertListAtFirst(tmpCards, checkCards);
                index -= 4;
                limit += 4;
                continue;
            } else {
                checkCards = [];
            }
        }
        checkCards.push(cards[index]);
        checkCards.push(cards[index - 1]);
        checkCards.push(cards[index - 2]);

        if (isPhomDoi(checkCards)) {
            checkCards.reverse();
            tmpCards = insertListAtFirst(tmpCards, checkCards);
            index -= 3;
            limit += 3;
            continue;
        }
        index -= 1;
    }
    return [tmpCards, limit];
};

//  sắp xêp đưa các phỏm sảnh lên đầu
var arrangeCardsByPhomSanhFirst = function arrangeCardsByPhomSanhFirst(cards, limit) {
    var tmpCards = cards.slice();
    var checkCards = [];
    var index = cards.length - 1;
    limit = 0;
    while (index > 1) {
        if (checkCards.length > 0) {
            checkCards = [];
        }
        checkCards.push(cards[index]);
        for (var i = index; i > 0; i -= 1) {
            if (cards[i].suit.ID !== cards[i - 1].suit.ID) {
                break;
            }
            if (cards[i].rank.ID + 1 === cards[i - 1].rank.ID) {
                checkCards.push(cards[i - 1]);
                continue;
            }
            break;
        }
        if (isPhomSanh(checkCards)) {
            tmpCards = insertListAtFirst(tmpCards, checkCards);
            limit += checkCards.length;
            index -= checkCards.length;
            continue;
        }
        index -= 1;
    }
    return [tmpCards, limit];
};

//chèn 1 cardsA vào cardsB  ở vị trí đầu tiên - sao cho mảng mới k có item nào trùng nhau
var insertListAtFirst = function insertListAtFirst(cardsA, cardsB) {
    cardsA.splice.apply(cardsA, [0, 0].concat(cardsB));
    for (var i = 0; i < cardsB.length; i += 1) {
        for (var j = cardsB.length; j < cardsA.length; j += 1) {
            if (cardsB[i].getId() === cardsA[j].getId()) {
                cardsA.splice(j, 1);
                break;
            }
        }
    }
    return cardsA;
};

// chèn 1 cardsA vào cardsB ở vị trí cuối - sao cho mảng mới k có item nào trùng nhau
var insertListAtLast = function insertListAtLast(cardsA, cardsB) {
    cardsA.splice.apply(cardsA, [cardsA.length, 0].concat(cardsB));
    for (var i = 0; i < cardsB.length; i += 1) {
        for (var j = 0; j < cardsA.length - cardsB.length; j += 1) {
            if (cardsB[i].getId() === cardsA[j].getId()) {
                cardsA.splice(j, 1);
                break;
            }
        }
    }
    return cardsA;
};

//move item trong list
var moveItemInArray = function moveItemInArray(cards, oldIndex, newIndex) {
    var tmp = Card.fromId(cards[oldIndex].getId());
    cards.splice(oldIndex, 1);
    cards.splice(newIndex, 0, tmp);
    return cards;
};

// thêm 1 item vào array vào cuối sao cho duy nhất id trong array
var addItemAtLast = function addItemAtLast(cards, card) {
    var tmp = card;
    for (var i = 0; i < cards.length; i += 1) {
        if (cards[i].getId() === tmp.getId()) {
            cards.splice(i, 1);
            break;
        }
    }
    cards.push(tmp);
    return cards;
};

// kiểm tra cards có phải là phỏm đôi k
var isPhomDoi = function isPhomDoi(cards) {
    if (cards.length < 3 || cards.length > 4) {
        return false;
    }
    if (cards[0].rank === cards[1].rank && cards[0].rank === cards[2].rank) {

        if (cards.length > 3) {
            if (cards[0].rank === cards[3].rank) {
                return true;
            }
            return false;
        }
        return true;
    }
    return false;
};

// check phỏm sảnh(xếp theo giảm dần )
var isPhomSanh = function isPhomSanh(cards) {
    if (cards.length < 3) {
        return false;
    }
    cards = arrangeCardsDecrease(cards);
    for (var i = 1; i < cards.length - 1; i += 1) {
        if (cards[i - 1].suit !== cards[i].suit || cards[i].suit !== cards[i + 1].suit) {
            return false;
        }
        if (cards[i].rank.ID - 1 !== cards[i + 1].rank.ID || cards[i - 1].rank.ID - 1 !== cards[i].rank.ID) {
            return false;
        }
    }
    return true;
};

// check 2 card có pải là gần phỏm sanh
var is2CardBoSanh = function is2CardBoSanh(cardsA, cardsB) {
    if (cardsA.suit !== cardsB.suit) {
        return false;
    }
    if (cardsA.rank.ID - 1 === cardsB.rank.ID || cardsA.rank.ID - 2 === cardsB.rank.ID) {
        return true;
    }
    return false;
};

// check 2 card có pải là gần phỏm doi
var is2CardBoDoi = function is2CardBoDoi(cardsA, cardsB) {
    if (cardsA.rank.ID !== cardsB.rank.ID) {
        return false;
    }
    return true;
};

module.exports = {

    MixArray: mixArray,
    GetRandom: getRandom,
    GeneratePackCards: generatePackCards,
    ArrangeCardsDecrease: arrangeCardsDecrease,
    ArrangePositionCards: arrangePositionCards,
    ArrangeCardsOptimize: arrangeCardsOptimize
};

cc._RFpop();
},{"Card":"Card"}],"PlatformImplement":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1fffe3D7vJCIaNlIIj/4XjB', 'PlatformImplement');
// scripts\lib\PlatformImplement.js

module.exports = {

    uploadFile: function uploadFile(options, callback) {
        var input = document.createElement('input');
        input.type = 'file';

        options = options || {};
        if (options.accept) {
            input.accept = options.accept;
        }

        input.addEventListener('change', function (event) {
            var reader = new FileReader(),
                fileUpload;
            reader.onload = function (evt) {
                callback({
                    fileName: fileUpload.name,
                    fileType: fileUpload.type,
                    value: evt.target.result
                });
            };
            fileUpload = event.target.files[0];
            reader.readAsBinaryString(fileUpload);
        });
        input.click();
    },

    openWebUrl: function openWebUrl(url) {
        window.open(url, '_blank');
    },

    callNumberPhone: function callNumberPhone(number) {
        var element = document.createElement('a'),
            temp = window.onbeforeunload;
        element.href = 'tel:' + number;
        window.onbeforeunload = null;
        element.click();
        window.onbeforeunload = temp;
    },

    guiTinNhan: function guiTinNhan(number, content) {
        function iOSversion() {
            if (/iP(hone|od|ad)/.test(navigator.platform)) {
                var v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
            }
            return [];
        }

        var cont_ch = '?',
            iosVersion = iOSversion(),
            temp = window.onbeforeunload,
            element = document.createElement('a');

        if (iosVersion[0] >= 8) {
            cont_ch = '&';
        } else if (iosVersion[0] > 1) {
            cont_ch = 'j';
        }
        element.href = 'sms:' + number + cont_ch + 'body=' + encodeURIComponent(content);
        window.onbeforeunload = null;
        element.click();
        window.onbeforeunload = temp;
    },

    getNhaMang: function getNhaMang() {
        return 'VIETTEL';
    },

    /**
     * Return to login page when accesstoken is expired
     */
    returnLoginPage: function returnLoginPage() {
        window.onbeforeunload = null;
        window.location.href = '/login';
    },

    displayLogoutMessage: function displayLogoutMessage(message) {
        if (message) {
            window.alert(message);
        }
    },

    logoutUser: function logoutUser() {
        function deleteAllCookies() {
            var cookies = document.cookie.split(';'),
                cookie,
                eqPos,
                name,
                i;
            for (i = 0; i < cookies.length; i += 1) {
                cookie = cookies[i];
                eqPos = cookie.indexOf('=');
                name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
                document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;';
            }
        }
        deleteAllCookies();
    },

    setCursorToNormal: function setCursorToNormal() {
        this._changeCursor('auto');
    },

    setCursorToHand: function setCursorToHand() {
        this._changeCursor('pointer');
    },

    _changeCursor: function _changeCursor(name) {
        var canvasList = document.getElementsByTagName('canvas'),
            canvas = canvasList && canvasList[0];
        if (canvas) {
            canvas.style.cursor = name;
        }
    }
};

cc._RFpop();
},{}],"PlayerConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8d2beqTHNRG2Zh+bRrvKcZ+', 'PlayerConstant');
// scripts\games\common\player\PlayerConstant.js

module.exports = {
    Event: {
        UPDATE_MONEY: 'player.update_money'
    }
};

cc._RFpop();
},{}],"PlayerUIMauBinh":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0f74amSVbFAeLwENc0xXOhp', 'PlayerUIMauBinh');
// scripts\components\games\mau_binh\PlayerUIMauBinh.js

var Card = require('Card'),
    Utils = require('Utils'),
    CardUI = require('CardUI'),
    PlayerUI = require('PlayerUI'),
    AuthUser = require('AuthUser'),
    MauBinhConstant = require('MauBinhConstant'),
    CardLayoutMauBinh = require('CardLayoutMauBinh');

cc.Class({
    'extends': cc.Component,

    properties: {
        lblMoneyChi: cc.Label,
        lblChiType: cc.Label,
        cardLayout: CardLayoutMauBinh,
        xepXongNode: cc.Node,
        cardPrefab: cc.Prefab
    },

    setGamePlay: function setGamePlay(gamePlay) {
        this.gamePlay = gamePlay;
    },

    onLoad: function onLoad() {
        // Time Effect Swap
        this.timeEffectSwap = Utils.Number.random(2, 5);

        // Reset
        this._resetFirstTime();
    },

    update: function update(dt) {
        // Swap Effect
        if (this.state === MauBinhConstant.PlayerState.IN_TURN) {
            this.time += dt;
            if (this.time >= this.timeEffectSwap) {
                var user = this.node.getComponent(PlayerUI).player;
                if (user && user.data.username !== AuthUser.username) {
                    this.timeEffectSwap = Utils.Number.random(2, 5);
                    this.time = 0;
                    this.cardLayout.createEffectSwapCard();
                }
            }
            if (this.runEffectCountDown) {
                this.runEffectCountDown = false;
                var currentTime = new Date().getTime();
                var timeRemain = this.timeOut - (currentTime - this.startTime);
                if (timeRemain > 0) {
                    this.node.getComponent(PlayerUI).setCountDown(timeRemain);
                }
            }
        }
    },

    showCardLayout: function showCardLayout(active, sortCardLayoutActive) {
        this._resetFirstTime();
        this.isSapHam = false;
        this.isThangTrang = false;
        this.cardAvatar.active = false;
        this.cardLayout.layoutCard.active = false;
        if (active) {
            if (sortCardLayoutActive) {
                this.cardAvatar.active = true;
            } else {
                this.cardAvatar.active = false;
                this.cardLayout.showAllLayout();
            }
        }
    },

    reset: function reset() {
        // Reset
        this.isActive = false;
        this.isSapHam = false;
        this.isThangTrang = false;
        this.isOpenChi = [false, false, false];

        // Remove Effect
        var playerUI = this.node.getComponent(PlayerUI);
        playerUI.clearCountDown();
        playerUI.removeWinEffect();
        playerUI.removeLoseEffect();
        playerUI.removeDrawEffect();

        // Reset Cardd Layout
        // Card Layout
        this.xepXongNode.active = false;

        // Reset Card
        this.cardLayout.reset();

        // Reset Result 3 Chi
        this.lblChiType.string = '';
        this.lblMoneyChi.string = '';

        // Hide Card
        if (this.cardAvatar) {
            this.cardAvatar.active = false;
        }
    },

    setState: function setState(state, timeOut, isFinish) {
        this._resetFirstTime();
        this.state = state;
        this.startTime = new Date().getTime();
        this.timeOut = timeOut;
        this.node.getComponent(PlayerUI).clearCountDown();
        if (state === MauBinhConstant.PlayerState.IN_TURN) {
            this.isActive = true;
            this.runEffectCountDown = true;
            this.xepXongNode.active = false;
            if (isFinish) {
                this.setState(MauBinhConstant.PlayerState.FINISH);
            }
        } else if (state === MauBinhConstant.PlayerState.FINISH) {
            this.isActive = true;
            this.runEffectCountDown = false;
            this.xepXongNode.active = true;
            this.xepXongNode.getComponentInChildren(cc.Label).string = 'XẾP XONG';
        } else if (state === MauBinhConstant.PlayerState.WAITING) {
            this.isActive = false;
            this.xepXongNode.active = true;
            this.xepXongNode.getComponentInChildren(cc.Label).string = 'ĐANG ĐỢI';
        }
    },

    unfoldChi: function unfoldChi(index, hand, hasEffect) {
        this._resetFirstTime();
        if (this.isOpenChi[index]) {
            return;
        }

        // Show
        this.isOpenChi[index] = true;
        var cardUIList = this.cardLayout.layoutCardList[index].getComponentsInChildren(CardUI);
        for (var i = 0; i < cardUIList.length; i += 1) {
            cardUIList[i].setCard(Card.fromId(hand[i]));
            var cardNode = cardUIList[i].node;
            cardNode.stopAllActions();
            cardNode.scale = 1;
            if (!hasEffect) {
                cardUIList[i].unfoldNode.active = true;
                cardUIList[i].foldNode.active = false;
            } else {
                cardUIList[i].foldNode.active = true;
                cardNode.runAction(cc.sequence(cc.scaleTo(0.2, 0, 1), cc.callFunc((function () {
                    this.getChildByName('Fold').active = false;
                }).bind(cardNode)), cc.scaleTo(0.2, 1, 1)));
            }
        }
    },

    setOpenAllCards: function setOpenAllCards(cards) {
        this.isOpenChi = [false, false, false];
        for (var i = 0; i < 3; i += 1) {
            var hand = cards.slice(i * 5, i * 5 + (i >= 2 ? 3 : 5));
            this.unfoldChi(i, hand, false);
        }
    },

    setOpenAllChiCards: function setOpenAllChiCards(chiInfo) {
        // cc.log('setOpenAllChiCards');
        this.isOpenChi = [false, false, false];
        for (var i = 0; i < chiInfo.length; i += 1) {
            this.unfoldChi(i, chiInfo[i].hand, false);
        }
    },

    compareChi: function compareChi(gameAction, gameState, player, actions, isInForcus) {
        // cc.log(player);
        var inFocus = isInForcus === true;
        this._resetFirstTime();
        this.cardLayout.resetPosition();
        this.xepXongNode.active = false;
        this.cardAvatar.active = false;
        this.isActive = player.isActive;
        this.state = MauBinhConstant.PlayerState.ORDER_CARDS;
        if (player.isThangTrang) {
            return;
        }
        var i,
            index = 0;
        if (player.isBinhLung && player.cards) {
            this.setOpenAllCards(player.cards);
        }

        // Check If Non Active
        this.showCardLayout(this.isActive, false);
        if (gameAction === MauBinhConstant.Action.COMPARE_CHI_MOT || gameState === MauBinhConstant.GameState.COMPARE_1) {
            index = 0;
            this.node.getComponent(PlayerUI).clearCountDown();
        } else if (gameAction === MauBinhConstant.Action.COMPARE_CHI_HAI || gameState === MauBinhConstant.GameState.COMPARE_2) {
            index = 1;

            // Open Chi 1 Neu Chua Mo
            if (!this.isOpenChi[0]) {
                this.unfoldChi(0, player.chiInfo[0].hand, false);
            }
        } else if (gameAction === MauBinhConstant.Action.COMPARE_CHI_BA || gameState === MauBinhConstant.GameState.COMPARE_3) {
            index = 2;

            // Open Chi 1, 2 Neu Chua Mo
            if (!this.isOpenChi[0]) {
                this.unfoldChi(0, player.chiInfo[0].hand, false);
            }
            if (!this.isOpenChi[1]) {
                this.unfoldChi(1, player.chiInfo[1].hand, false);
            }
        }

        // Show Black Card Binh Lung
        this.cardLayout.showBinhLung(player.isBinhLung);

        // Unfold Card
        var hasEffect = !(inFocus || player.isBinhLung);
        this.unfoldChi(index, player.chiInfo[index].hand, hasEffect);

        // Chi Type
        if (player.isBinhLung) {
            this.lblChiType.node.scale = 1;
            this.lblChiType.string = 'Binh Lủng';
        } else {
            this.lblChiType.node.scale = 0;
            this.lblChiType.node.stopAllActions();
            if (!inFocus) {
                this.lblChiType.node.runAction(cc.scaleTo(0.8, 1));
            } else {
                this.lblChiType.node.scale = 1;
            }
            this.lblChiType.string = player.chiInfo[index].type;
        }

        // Calculate Money Exchange
        if (!inFocus && actions) {
            var moneyExchange = 0;
            for (i = 0; i < actions.length; i += 1) {
                var sourcePlayer = actions[i].sourcePlayer,
                    targetPlayer = actions[i].targetPlayer,
                    userName = this.node.getComponent(PlayerUI).player.data.username;
                if (userName === sourcePlayer) {
                    moneyExchange -= actions[i].moneyExchange;
                    this.isSapHam = actions[i].isSapHam;
                }
                if (userName === targetPlayer) {
                    moneyExchange += actions[i].moneyExchange;
                }
            }

            // Show Money Exchange
            this.showMoneyEffect(moneyExchange);
        }

        // Hide Chi Other
        if (!player.isBinhLung && !player.isThangTrang) {
            for (var j = 0; j < 3; j += 1) {
                var active = j === index;
                this.cardLayout.layoutCardList[j].active = active;
                this.isOpenChi[j] = active;
            }
        }
    },

    showMoneyEffect: function showMoneyEffect(money) {
        this.lblMoneyChi.node.color = cc.Color.YELLOW;
        this.lblMoneyChi.string = (money >= 0 ? '+' : '') + Utils.Number.abbreviate(money);
        var x = this.node.x > 0 ? -90 : 90;
        var y = 30;
        this.lblMoneyChi.node.position = new cc.Vec2(x, y);
        this.lblMoneyChi.node.stopAllActions();
        this.lblMoneyChi.node.opacity = 255;
        var action = cc.spawn(cc.moveBy(3, cc.p(0, 90)), cc.fadeTo(3, 0));
        action.easing(cc.easeQuadraticActionOut());
        this.lblMoneyChi.node.runAction(action);

        // Main User
        var user = this.node.getComponent(PlayerUI).player;
        if (!this.gamePlay || user.data.username !== AuthUser.username) {
            return;
        }
        if (money >= 0) {
            this.gamePlay.audioManager.playChickenWin();
        } else {
            this.gamePlay.audioManager.playLost();
        }
    },

    setThangTrang: function setThangTrang(params) {
        // cc.log('set Thang trang');
        // cc.log(params);
        this.isThangTrang = true;
        this.cardLayout.showAllLayout();
        this.cardLayout.foldAllCard();
        this.setOpenAllCards(params.hand);
        this.cardLayout.imgThangTrang.active = true;
        this.cardLayout.imgThangTrang.getComponentInChildren(cc.Label).string = params.type;
    },

    setResult: function setResult(player, moneyExchange) {
        // cc.log('setResult');
        // cc.log(player);
        this._resetFirstTime();
        this.isActive = player.isActive;
        this.xepXongNode.active = false;

        // If Not Active
        if (!player.isActive) {
            return;
        }

        // Show All Chi
        this.cardLayout.showAllLayout();
        this.cardLayout.foldAllCard();
        this.setOpenAllChiCards(player.chiInfo);

        // Hide Effect 3 Chi
        this.lblChiType.string = '';
        this.lblMoneyChi.string = '';

        // Show Result
        var isMainUser = player.username === AuthUser.username;
        if (moneyExchange > 0) {
            this.node.getComponent(PlayerUI).setWinEffect(moneyExchange);
            if (this.gamePlay && isMainUser) {
                this.gamePlay.audioManager.playWin();
            }
        } else if (moneyExchange === 0) {
            this.node.getComponent(PlayerUI).setDrawEffect(moneyExchange);
            if (this.gamePlay && isMainUser) {
                this.gamePlay.audioManager.playWin();
            }
        } else {
            this.node.getComponent(PlayerUI).setLoseEffect(moneyExchange);
            if (this.gamePlay && isMainUser) {
                this.gamePlay.audioManager.playLose();
            }
        }
        if (player.isBinhLung) {
            this.lblChiType.string = 'Binh Lủng';
        }
        if (this.isSapHam) {
            this.cardLayout.imgThuaSapHam.active = true;
        }
    },

    _resetFirstTime: function _resetFirstTime() {
        this.time = 0;
        if (this.callResetFisrtTime) {
            return;
        }
        this.callResetFisrtTime = true;

        // Label Money Chi
        this.lblMoneyChi.node.active = true;

        // Set Position Card Layout
        if (this.node.x > 0) {
            this.lblChiType.node.x = -184;
        } else {
            this.lblChiType.node.x = 180;
        }

        // Var
        this.isOpenChi = [false, false, false];

        // Card
        var posX = -130;
        if (this.node.x < 0) {
            posX = 130;
        }
        this.cardAvatar = cc.instantiate(this.cardPrefab);
        this.cardAvatar.scale = 0.5;
        this.cardAvatar.x = posX;
        this.cardAvatar.active = false;
        this.node.addChild(this.cardAvatar);

        // Reset
        this.reset();

        // Check Run Effect Count Down
        this.runEffectCountDown = false;
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","Card":"Card","CardLayoutMauBinh":"CardLayoutMauBinh","CardUI":"CardUI","MauBinhConstant":"MauBinhConstant","PlayerUI":"PlayerUI","Utils":"Utils"}],"PlayerUIPhomCurrent":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2d3a6zla7hKb6GejtMzVxFz', 'PlayerUIPhomCurrent');
// scripts\components\games\phom\PlayerUIPhomCurrent.js

var PlayerUIPhom = require('PlayerUIPhom'),
    Card = require('Card'),
    PhomUtils = require('PhomUtils');

cc.Class({
    'extends': PlayerUIPhom,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {
        PlayerUIPhom.prototype.onLoad.call(this);
    },

    onUpdateHand: function onUpdateHand(data) {
        PlayerUIPhom.prototype.onUpdateHand.call(this, data);
    },

    onRefreshGame: function onRefreshGame(data) {
        PlayerUIPhom.prototype.onRefreshGame.call(this, data);
    },

    drawOnPortDanh: function drawOnPortDanh(data) {
        PlayerUIPhom.prototype.drawOnPortDanh.call(this, data);
    },

    drawOnPortDeal: function drawOnPortDeal(data) {
        this.portCardDealNode.removeAllChildren();

        var cardNew;
        for (var i = 0; i < data.length; i += 1) {
            cardNew = cc.instantiate(this.cardPrefab);
            cardNew.parent = this.portCardDealNode;

            if (cardNew.getComponent('CardUIPhom')) {
                cardNew = cardNew.getComponent('CardUIPhom');
                cardNew.setCard(Card.fromId(data[i]));
            }
        }
    },

    drawOnPortAn: function drawOnPortAn(data) {
        if (data.length < 1) {
            return;
        }
        this.portCardAnNode.removeAllChildren();
        var childDeal = this.portCardDealNode.children;
        for (var index = 0; index < data.length; index += 1) {
            for (var i = 0; i < childDeal.length; i += 1) {
                if (childDeal[i].getComponent('CardUIPhom')) {
                    var tmp = childDeal[i].getComponent('CardUIPhom');
                    if (data[index] === tmp.card.getId()) {
                        tmp.hoverAnNode.active = true;
                        break;
                    }
                }
            }
        }
    },

    drawOnPortShow: function drawOnPortShow(data) {
        PlayerUIPhom.prototype.drawOnPortShow.call(this, data);
    },

    clearStateAction: function clearStateAction() {
        PlayerUIPhom.prototype.clearStateAction.call(this);
    },

    onXepLaiBai: function onXepLaiBai() {
        this.myCards = this.getMyCards();
        this.myCards = PhomUtils.ArrangeCardsOptimize(this.myCards, true);
        PhomUtils.ArrangePositionCards(this.myCards, this.portCardDealNode);
    },

    getMyCards: function getMyCards() {
        var result = [];
        var child = this.portCardDealNode.children;
        for (var i = 0; i < child.length; i += 1) {
            if (child[i].getComponent('CardUIPhom')) {
                result.push(child[i].getComponent('CardUIPhom').card);
            }
        }
        return result;
    },

    getCardTouched: function getCardTouched() {
        var child = this.portCardDealNode.children;
        for (var i = 0; i < child.length; i += 1) {
            if (child[i].getComponent('CardUIPhom')) {
                if (child[i].getComponent('CardUIPhom').isTouched) {
                    return child[i].getComponent('CardUIPhom').card;
                }
            }
        }
        return null;
    },

    setStateCardInShowOff: function setStateCardInShowOff(data) {
        var listCards = [];
        for (var i = 0; i < data.length; i += 1) {
            for (var j = 0; j < data[i].length; j += 1) {
                listCards.push(data[i][j]);
            }
        }

        var child = this.portCardDealNode.children;
        for (var index = 0; index < listCards.length; index += 1) {
            for (var k = 0; k < child.length; k += 1) {
                if (child[k].getComponent('CardUIPhom')) {
                    if (child[k].getComponent('CardUIPhom').card.getId() === listCards[index]) {
                        child[k].getComponent('CardUIPhom').setMoveCardUpDown(true);
                        break;
                    }
                }
            }
        }
    },

    onSentCard: function onSentCard() {},

    onShowOffCard: function onShowOffCard() {},

    onTakeCard: function onTakeCard() {},

    onDiscard: function onDiscard(cardId) {
        var self = this;
        var child = this.portCardDealNode.children;
        var cardNode;
        for (var i = 0; i < child.length; i += 1) {
            if (child[i].getComponent('CardUIPhom')) {
                cardNode = child[i].getComponent('CardUIPhom');
                if (cardNode.card.getId() === cardId) {
                    cardNode = child[i];
                    break;
                }
            }
        }
        if (!cardNode) {
            return;
        }
        cardNode.node.setSiblingIndex(99);

        var sequenceAction = cc.sequence(cc.callFunc(function () {
            cc.scaleTo(self.TIME_MOVE_CARD, 0.6);
        }), cc.moveTo(self.TIME_MOVE_CARD, self.portCardDanhNode), cc.callFunc(function () {
            cardNode.node.parent = self.portCardDanhNode;
            cardNode.buttonOnCard.interactable = false;
            cardNode.node.scale = 1;
        }));
        cardNode.node.runAction(sequenceAction);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"Card":"Card","PhomUtils":"PhomUtils","PlayerUIPhom":"PlayerUIPhom"}],"PlayerUIPhom":[function(require,module,exports){
"use strict";
cc._RFpush(module, '98b5a4CFE9KypFF/RuZha8m', 'PlayerUIPhom');
// scripts\components\games\phom\PlayerUIPhom.js

var Card = require('Card'),
    PlayerUITLMN = require('PlayerUITLMN'),
    PhomConstant = require('PhomConstant'),
    AuthUser = require('AuthUser'),
    Utils = require('Utils'),
    PhomUtils = require('PhomUtils');

cc.Class({
    'extends': PlayerUITLMN,

    properties: {
        portCardShowNode: {
            'default': [],
            type: cc.Node
        },
        portCardAnNode: cc.Node,
        buttonGuiList: {
            'default': [],
            type: cc.Button
        },
        pointLabel: cc.Label,
        KHOANG_CACH_QUAN_BAI: {
            'default': 55,
            override: true,
            visible: false
        },
        CONSTANT_X: {
            'default': 0,
            override: true,
            visible: false
        },
        CONSTANT_Y: {
            'default': 0,
            override: true,
            visible: false
        },
        CONSTANT_ROTATION: {
            'default': 0,
            override: true,
            visible: false
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        PlayerUITLMN.prototype.onLoad.call(this);
        this.phomList = [];
        this._isSanhFirst = false;
    },

    setStateAction: function setStateAction(act) {
        this.action = act;
        switch (act) {
            case PhomConstant.Action.DISCARD:
                this.setEffect(PhomConstant.Effect.DANG_DANH);
                break;

            case PhomConstant.Action.PICK_CARD:
                this.setEffect(PhomConstant.Effect.DANG_BOC);
                break;
            case PhomConstant.Action.SHOW_OFF:
                this.setEffect(PhomConstant.Effect.DANG_HA);
                break;
            case PhomConstant.Action.SENT:
                this.setEffect(PhomConstant.Effect.DANG_GUI);
                break;
        }
    },

    setStateInTurn: function setStateInTurn(inTurnState) {
        switch (inTurnState) {
            case PhomConstant.InTurnState.DISCARD:
                this.setEffect(PhomConstant.Effect.DANG_DANH);
                this.action = PhomConstant.Action.DISCARD;
                break;
            case PhomConstant.InTurnState.PICK_OR_TAKE_CARD:
                this.setEffect(PhomConstant.Effect.DANG_BOC);
                this.action = PhomConstant.Action.PICK_CARD;
                break;
            case PhomConstant.InTurnState.SHOW_OFF:
                this.setEffect(PhomConstant.Effect.DANG_HA);
                this.action = PhomConstant.Action.SHOW_OFF;
                break;
            case PhomConstant.InTurnState.SEND:
                this.setEffect(PhomConstant.Effect.DANG_GUI);
                this.action = PhomConstant.Action.SENT;
                break;
        }
    },

    onUpdateGame: function onUpdateGame() {
        this.onRefreshGame(false);
    },

    onRefreshGame: function onRefreshGame(isFinish, detail) {
        if (this.player) {
            if (this.player.data.handSize > 0 && !isFinish) {
                if (this.player.data.username === AuthUser.username) {
                    cc.log('sađâsdaaaaaaaâ');
                    if (this.player.data.cards) {
                        var child = this.cardHold.children;
                        var check = false;
                        for (var k = 0; k < child.length; k += 1) {
                            var cardUIPhom = child[k].getComponent('CardUIPhom');
                            check = false;
                            if (cardUIPhom && cardUIPhom.card) {
                                for (var j = 0; j < this.player.data.cards.length; j += 1) {
                                    if (cardUIPhom.card.getId() === this.player.data.cards[j]) {
                                        check = true;
                                        break;
                                    }
                                }
                            }
                            if (!check) {
                                break;
                            }
                        }
                        if (!check || child.length !== this.player.data.cards.length) {
                            this.reDrawPort(this.cardHold, this.player.data.cards, true, true, true);
                        }

                        if (detail) {
                            if (detail.isPlayerTakeCard) {
                                this.onXepLaiBai(false);
                            } else if (detail.isPickCardPhom && this.checkRefCard(detail.cardId)) {
                                this.onXepLaiBai(false);
                            }
                        } else {
                            this.onXepLaiBai(false);
                        }
                    }
                } else {
                    this.backCardNode.active = true;
                }
            }

            this.reDrawPort(this.portCardTrash, this.player.data.trash, false, false);
            if (!isFinish) {
                if (this.player.data.username !== AuthUser.username) {
                    if (this.player.data.phomList.length > 0) {
                        Utils.Node.destroyAllChildrenInNode(this.portCardAnNode);
                    } else {
                        this.reDrawPort(this.portCardAnNode, this.player.data.takenCards, false, true);
                    }
                } else {
                    // this.reDrawPort(this.portCardAnNode, this.player.data.takenCards, false, true, true);
                }
            }

            for (var i = 0; i < this.portCardShowNode.length; i += 1) {
                this.reDrawPort(this.portCardShowNode[i], this.player.data.phomList[i], false, false);
            }
        }
    },

    clearAll: function clearAll() {
        Utils.Node.destroyAllChildrenInNode(this.portCardAnNode);
        Utils.Node.destroyAllChildrenInNode(this.portCardTrash);
        Utils.Node.destroyAllChildrenInNode(this.cardHold);
        for (var i = 0; i < this.portCardShowNode.length; i += 1) {
            Utils.Node.destroyAllChildrenInNode(this.portCardShowNode[i]);
        }
        if (this.backCardNode) {
            this.backCardNode.active = false;
        }
        if (this.phomList) {
            this.phomList = [];
        }
        for (var j = 0; j < this.buttonGuiList.length; j += 1) {
            this.buttonGuiList[j].node.active = false;
        }
        this.pointLabel.string = '';
        this.clearEffects();
    },

    hideGuiButtons: function hideGuiButtons() {
        for (var j = 0; j < this.buttonGuiList.length; j += 1) {
            this.buttonGuiList[j].node.active = false;
        }
    },

    reDrawPort: function reDrawPort(node, array, interactable, isTakenCard, canMove) {
        var i;
        node.getComponent(cc.Layout).enabled = true;
        // if (isTakenCard) {
        //     if (this.player.data.username === AuthUser.username) {
        //         for (i = 0; i < array.length; i += 1) {
        //             var takenCardUIPhom = this.findCard(array[i], node);
        //             if (takenCardUIPhom) {
        //                 takenCardUIPhom.hoverAnNode.active = true;
        //                 takenCardUIPhom.interactable = true;
        //                 takenCardUIPhom.canMove = true;
        //             }
        //         }
        //         return;
        //     }
        // }

        // Utils.Node.destroyAllChildrenInNode(node);
        node.removeAllChildren();
        if (array) {
            for (i = 0; i < array.length; i += 1) {
                var cardNew = cc.instantiate(this.cardPrefab);
                var cardUIPhom = cardNew.getComponent('CardUIPhom');
                cardUIPhom.setCard(Card.fromId(array[i]));
                cardNew.parent = node;
                cardNew.position = cc.p(0, 0);
                cardUIPhom.interactable = interactable;
                cardUIPhom.canMove = canMove;
                if (isTakenCard) {
                    if (this.player.data.username === AuthUser.username) {
                        for (var j = 0; j < this.player.data.takenCards.length; j += 1) {
                            if (array[i] === this.player.data.takenCards[j]) {
                                cardUIPhom.hoverAnNode.active = true;
                                break;
                            }
                        }
                    } else {
                        cardUIPhom.hoverAnNode.active = true;
                    }
                }
            }
        }
    },

    onSentCard: function onSentCard(cardId, cards, sourcePlayerUIPhom) {
        if (!sourcePlayerUIPhom) {
            return;
        }
        for (var i = 0; i < cards.length; i += 1) {
            for (var j = 0; j < this.phomList.length; j += 1) {
                if (cards[i] === this.phomList[j].cardId) {
                    this.initEffectCard([cardId], this.portCardShowNode[this.phomList[j].index], sourcePlayerUIPhom.cardHold, sourcePlayerUIPhom);
                    return;
                }
            }
        }
        if (this.backCardNode) {
            if (this.player.data.handSize <= 0) {
                this.backCardNode.active = false;
            } else {
                if (this.numberCardLabel) {
                    this.numberCardLabel.string = this.player.data.handSize;
                }
            }
        }
    },

    onShowOffCard: function onShowOffCard(phomList) {
        // var self = this;
        if (phomList) {
            var index = 0;
            if (this.portCardShowNode[0].children.length > 0) {
                index = 1;
            }
            if (this.portCardShowNode[1].children.length > 0) {
                index = 2;
            }
            for (var j = 0; j < phomList.length; j += 1) {
                var cards = phomList[j];
                if (cards) {
                    var check = false;
                    for (var k = 0; k < this.phomList.length; k += 1) {
                        if (cards[0] === this.phomList[k].cardId) {
                            check = true;
                            break;
                        }
                    }
                    if (check) {
                        continue;
                    }
                    this.initEffectCard(cards, this.portCardShowNode[index], this.cardHold, this);
                    if (this.portCardAnNode !== this.cardHold) {
                        Utils.Node.destroyAllChildrenInNode(this.portCardAnNode);
                        // this.portCardAnNode.removeAllChildren();
                    }
                    this.phomList.push({
                        cardId: cards[0],
                        index: j
                    });
                    index += 1;
                }
            }
            if (this.backCardNode) {
                if (this.player.data.handSize <= 0) {
                    this.backCardNode.active = false;
                } else {
                    if (this.numberCardLabel) {
                        this.numberCardLabel.string = this.player.data.handSize;
                    }
                }
            }
        }
    },

    onPickCard: function onPickCard(cardId) {
        var self = this;
        var data = this.player && this.player.data;
        if (data) {
            var card = cc.instantiate(this.cardPrefab);
            card.setScale(0.5, 0.5);
            card.parent = this.dealerNode;
            var x = this.node.x,
                y = this.node.y + 20,
                pos2InWorld = card.parent.convertToWorldSpace(card.position);
            if (this.player.data.username === AuthUser.username) {
                this.cardHold.getComponent(cc.Layout).enabled = false;
                card.parent = this.cardHold;
                card.position = this.cardHold.convertToNodeSpace(pos2InWorld);
                card.setScale(0.7);
                var number = this.cardHold.childrenCount;
                var width = card.width;
                y = 0;
                x = number * (width + this.cardHold.getComponent(cc.Layout).spacingX);
            } else {
                card.parent = this.backCardNode;
                card.position = this.backCardNode.convertToNodeSpace(pos2InWorld);
                card.zIndex = 2;
                y = 0;
                x = 0;
            }
            var action = cc.sequence(cc.spawn(cc.moveTo(0.5, cc.p(x, y)), cc.rotateTo(0.5, 135)), cc.callFunc(function () {
                // card.zIndex = 1;
                card.rotation = 0;
                if (this.player.data.username === AuthUser.username) {
                    this.cardHold.getComponent(cc.Layout).enabled = true;
                } else {
                    card.position = cc.p(0, 0);
                    card.parent = this.cardHold;
                }
                // card.zIndex = 1;
                card.setSiblingIndex(this.cardHold.childrenCount);
                if (card.getComponent('CardUIPhom')) {
                    var cardUIPhom = card.getComponent('CardUIPhom');
                    cardUIPhom.setCard(Card.fromId(cardId));
                    cardUIPhom.interactable = true;
                    cardUIPhom.canMove = true;
                }
                if (cardId === null) {
                    card.destroy();
                }
            }, this), cc.scaleTo(0.1, 1), cc.callFunc(function () {
                var check = false;
                var foundCard = self.findCard(cardId, self.portCardTrash);
                if (foundCard) {
                    check = true;
                }
                if (data.cards) {

                    for (var i = 0; i < data.cards.length; i += 1) {
                        if (cardId === data.cards[i]) {
                            check = true;
                            break;
                        }
                    }

                    if (!check) {
                        card.destroy();
                    }
                }
                self.node.emit('refresh_game', { isPickCardPhom: true, cardId: cardId });
            }, this));
            action.easing(cc.easeQuadraticActionOut());
            card.runAction(action);
        }
    },

    onTakeCard: function onTakeCard(cardId) {
        var foundCard = this.findCard(cardId, this.portCardAnNode);
        if (foundCard) {
            foundCard.setCard(Card.fromId(cardId));
            if (this.player.data.username === AuthUser.username) {
                foundCard.interactable = true;
            } else {
                foundCard.interactable = false;
            }
            foundCard.hoverAnNode.active = true;
            return;
        }
    },

    setStateCardInShowOff: function setStateCardInShowOff(phomList) {
        if (phomList) {
            for (var j = 0; j < phomList.length; j += 1) {
                var cards = phomList[j];
                if (cards) {
                    for (var i = 0; i < cards.length; i += 1) {
                        var card = this.findCard(cards[i], this.cardHold);
                        if (card) {
                            card.interactable = true;
                            card.onButtonTouch();
                        }
                    }
                }
            }
        }
    },

    showGuiButtonInPhoms: function showGuiButtonInPhoms(cardId, cards, gameManager) {
        var self = this;
        for (var i = 0; i < cards.length; i += 1) {
            for (var j = 0; j < this.phomList.length; j += 1) {
                if (cards[i] === this.phomList[j].cardId) {
                    this.buttonGuiList[j].node.active = true;
                    this.buttonGuiList[j].node.on(cc.Node.EventType.TOUCH_START, function () {
                        self.sendPhom(cardId, cards, gameManager);
                    });
                    return;
                }
            }
        }
    },

    sendPhom: function sendPhom(cardId, cards, gameManager) {
        gameManager.requestSentCard(cardId, cards);
    },

    // Hiệu ứng bị ăn
    effectTakenCard: function effectTakenCard(targetPlayerUIPhom, cardId) {
        this.initEffectCard([cardId], targetPlayerUIPhom.portCardAnNode, this.portCardTrash, this, true, targetPlayerUIPhom);
    },

    showRankAndMoneyExchange: function showRankAndMoneyExchange(moneyExchange, action, isU, isUDen) {
        this.clearCountDown();
        this.clearEffects();

        this.showMoneyExchange(moneyExchange);
        if (isUDen) {
            this.addEffect(PhomConstant.Effect.DEN_U);
        } else if (isU) {
            this.setEffect(PhomConstant.Effect.U);
        } else {
            switch (action) {
                case PhomConstant.Finish.VE_NHI:
                    this.addEffect(PhomConstant.Effect.NHI);
                    break;
                case PhomConstant.Finish.VE_BA:
                    this.addEffect(PhomConstant.Effect.BA);
                    break;
                case PhomConstant.Finish.VE_BET:
                    this.addEffect(PhomConstant.Effect.BET);
                    break;
                case PhomConstant.Finish.MOM:
                    this.addEffect(PhomConstant.Effect.MOM);
                    break;
                case PhomConstant.Finish.VE_NHAT:
                    this.addEffect(PhomConstant.Effect.NHAT);
                    break;
                case PhomConstant.Finish.U:
                    this.addEffect(PhomConstant.Effect.BET);
                    break;
            }
        }
    },

    findAndDeleteCard: function findAndDeleteCard(cardId, node) {
        if (node) {
            var childs = node.children;
            for (var i = 0; i < childs.length; i += 1) {
                var cardUIPhom = childs[i].getComponent('CardUIPhom');
                if (cardUIPhom) {
                    if (cardUIPhom.card && cardUIPhom.card.getId() === cardId) {
                        cardUIPhom.node.destroy();
                        return true;
                    }
                }
            }
        }
        return false;
    },

    onXepLaiBai: function onXepLaiBai() {
        var self = this;
        this.cardUIPhomList = [];
        this.myCards = this.getMyCards();
        var orderedCards = PhomUtils.ArrangeCardsOptimize(this.myCards, this._isSanhFirst);

        var layout = this.cardHold.getComponent(cc.Layout);
        layout.enabled = false;
        var spacingX = this.cardHold.getComponent(cc.Layout).spacingX;
        for (var i = 0; i < orderedCards.length; i += 1) {
            for (var j = 0; j < this.cardUIPhomList.length; j += 1) {
                if (orderedCards[i].getId() === this.cardUIPhomList[j].card.getId()) {
                    var width = this.cardUIPhomList[j].node.width;
                    var x = width / 2;
                    this.cardUIPhomList[j].node.runAction(cc.sequence(cc.moveTo(self.TIME_MOVE_CARD, cc.p(x + i * (spacingX + width), self.cardUIPhomList[j].node.y)), cc.callFunc(function () {
                        layout.enabled = true;
                    })));
                    this.cardUIPhomList[j].node.setSiblingIndex(i);
                }
            }
        }
    },

    getMyCards: function getMyCards() {
        var result = [];
        var child = this.cardHold.children;
        for (var i = 0; i < child.length; i += 1) {
            var cardUIPhom = child[i].getComponent('CardUIPhom');
            var check = false;
            if (cardUIPhom) {
                for (var j = 0; j < this.player.data.cards.length; j += 1) {
                    if (cardUIPhom.card.getId() === this.player.data.cards[j]) {
                        check = true;
                        break;
                    }
                }
                if (check) {
                    result.push(cardUIPhom.card);
                    this.cardUIPhomList.push(cardUIPhom);
                } else {
                    cardUIPhom.node.destroy();
                }
            }
        }
        return result;
    },

    checkRefCard: function checkRefCard(cardId) {
        for (var i = 0; i < this.player.data.cards.length; i += 1) {
            if (cardId !== this.player.data.cards[i]) {
                var a1 = Math.floor(cardId / 4),
                    a2 = Math.floor(this.player.data.cards[i] / 4),
                    b1 = cardId % 4,
                    b2 = this.player.data.cards[i] % 4;
                if (a1 === a2 || b1 === b2 && (Math.abs(a1 - a2) === 1 || Math.abs(a1 - a2) === 2)) {
                    return true;
                }
            }
        }
        return false;
    },

    khoangCach2Diem: function khoangCach2Diem(p1, p2) {
        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","Card":"Card","PhomConstant":"PhomConstant","PhomUtils":"PhomUtils","PlayerUITLMN":"PlayerUITLMN","Utils":"Utils"}],"PlayerUITLMN":[function(require,module,exports){
"use strict";
cc._RFpush(module, '11f6869P89Fj49sHooPfUUt', 'PlayerUITLMN');
// scripts\components\games\tlmn\PlayerUITLMN.js

var Card = require('Card'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    PlayerUI = require('PlayerUI');

cc.Class({
    'extends': PlayerUI,

    properties: {
        cardHold: cc.Node,
        portCardTrash: cc.Node,
        backCardNode: cc.Node,
        moneyExchangeLabel: cc.Label,
        numberCardLabel: cc.Label,
        cardPrefab: cc.Prefab,
        dealerNode: cc.Node,
        TIME_MOVE_CARD: {
            'default': 1.5,
            visible: false
        },
        KHOANG_CACH_QUAN_BAI: {
            'default': 55,
            visible: false
        },
        CONSTANT_X: {
            'default': 100,
            visible: false
        },
        CONSTANT_Y: {
            'default': 50,
            visible: false
        },
        CONSTANT_ROTATION: {
            'default': 0,
            visible: false
        },
        Hold: cc.Node
    },

    // use this for initialization
    // onLoad: function () {
    //     PlayerUI.prototype.onLoad.call(this);
    // },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    onUpdateHand: function onUpdateHand(cards, handSize, canMove) {
        Utils.Node.destroyAllChildrenInNode(this.cardHold);
        // this.cardHold.removeAllChildren();
        if (handSize > 0) {
            this.drawOnPortDeal(cards, handSize, canMove);
        }
    },

    drawOnPortDeal: function drawOnPortDeal(cards, handSize, canMove) {
        var card,
            count = 0,
            time = 0.5,
            timeDelay = 0.06,
            rotation = 0,
            i = 0,
            indexSibling = 1;
        this.numberCard = 0;
        for (i = 0; i < handSize; i += 1) {
            card = cc.instantiate(this.cardPrefab);
            card.setScale(0.4, 0.4);
            // card.zIndex = indexZ;
            card.parent = this.dealerNode;

            count += 1;
            indexSibling += 1;
            var cardId;
            if (cards) {
                cardId = cards[i];
            } else {
                cardId = null;
            }

            this.hieuUngChiaBai(card, time, timeDelay * count, rotation, indexSibling, cardId, handSize, canMove);
        }
        if (handSize > 0 && this.backCardNode) {
            this.backCardNode.active = true;
            if (this.numberCardLabel) {
                this.numberCardLabel.string = 0;
            }
        }
    },

    hieuUngChiaBai: function hieuUngChiaBai(card, time, timeDelay, rotation, index, cardId, handSize, canMove) {
        var self = this;
        card.stopAllActions();

        var chiaBaiAction = cc.sequence(cc.delayTime(timeDelay), cc.spawn(cc.moveTo(time, cc.p(self.Hold.x, self.Hold.y)), cc.rotateTo(time, rotation)), cc.callFunc(function () {
            self.numberCard += 1;
            if (self.numberCard > handSize) {
                self.numberCard = handSize;
            }
            if (self.numberCardLabel) {
                self.numberCardLabel.string = self.numberCard;
            }
        }, this), cc.delayTime(time / 2), cc.callFunc(function () {
            if (self.player && this.cardHold.childrenCount >= handSize) {
                card.destroy();
                return;
            }
            card.rotation = 0;
            card.position = cc.p(0, 0);
            card.parent = this.cardHold;
            card.setSiblingIndex(index);
            if (card.getComponent('CardUIPhom')) {
                var cardUIPhom = card.getComponent('CardUIPhom');
                cardUIPhom.canMove = canMove;
                cardUIPhom.setCard(Card.fromId(cardId));
                cardUIPhom.interactable = true;
            }
            if (cardId === null || self.findCard(cardId, self.portCardTrash)) {
                card.destroy();
            }
        }, this), cc.scaleTo(0.1, 1));
        chiaBaiAction.easing(cc.easeQuadraticActionOut());
        card.runAction(chiaBaiAction);
    },

    onDiscard: function onDiscard(cards) {
        if (cards) {
            this.initEffectCard(cards, this.portCardTrash, this.cardHold, this);
            if (this.backCardNode) {
                if (this.player.data.handSize <= 0) {
                    this.backCardNode.active = false;
                }
                if (this.numberCardLabel) {
                    this.numberCardLabel.string = this.player.data.handSize;
                }
            }
        }
    },

    initEffectCard: function initEffectCard(cards, desNode, sourceNode, sourcePlayer, isTakeCardPhom, playerTakeCardPhom) {
        if (cards) {
            var randomX = Math.random();
            var randomY = Math.random();
            randomX = (randomX < 0.5 ? -randomX : randomX) * this.CONSTANT_X;
            randomY = (randomY < 0.5 ? -randomY : randomY) * this.CONSTANT_Y;
            var randomRotation = Math.random();
            randomRotation *= (randomRotation < 0.5 ? -randomRotation : randomRotation) * this.CONSTANT_ROTATION;
            if (desNode && desNode.getComponent(cc.Layout)) {
                desNode.getComponent(cc.Layout).enabled = false;
                randomY = 0;
                randomRotation = 0;
                var check = desNode.anchorX === 0 ? 1 : -1;
                var number = check === 1 ? desNode.childrenCount : 0;
                var defaultCard = cc.instantiate(this.cardPrefab);
                var width = defaultCard.width;
                defaultCard.destroy();
                randomX = check * (width / 2 + number * (width + desNode.getComponent(cc.Layout).spacingX));
            }
            randomRotation = 0;
            for (var i = 0; i < cards.length; i += 1) {
                var cardNew = null;
                var cardId = cards[i];
                var cardUIPhom = this.findCard(cardId, sourceNode);
                var isMyCard = false;
                if (cardUIPhom) {
                    cardNew = cardUIPhom.node;
                    isMyCard = true;
                }
                if (!cardNew) {
                    cardNew = cc.instantiate(this.cardPrefab);
                    if (sourcePlayer.backCardNode) {
                        cardNew.parent = sourcePlayer.backCardNode;
                        cardNew.position = cc.p(0, 0);
                    } else {
                        cardNew.parent = sourceNode;
                        cardNew.position = cc.p(0, 0);
                    }
                }
                var pos2InWorld;
                pos2InWorld = cardNew.parent.convertToWorldSpace(cardNew.position);
                cardNew.parent = desNode;
                if (desNode) {
                    cardNew.position = desNode.convertToNodeSpace(pos2InWorld);
                    cardNew.setSiblingIndex(desNode.childrenCount);
                    this.effectCard(cardNew, i, randomX, randomY, randomRotation, desNode, isMyCard, cardId, isTakeCardPhom, playerTakeCardPhom);
                }
                cardNew.getComponent('CardUIPhom').interactable = false;
                // cardNew.zIndex = 1;
            }
            if (this.numberCardLabel) {
                this.numberCardLabel.string = this.player.data.handSize;
            }
        }
    },

    effectCard: function effectCard(cardNew, index, randomX, randomY, randomRotation, desNode, isMyCard, cardId, isTakeCardPhom, playerTakeCardPhom) {
        var self = this;
        cardNew.stopAllActions();
        var action = cc.sequence(cc.spawn(cc.moveTo(self.TIME_MOVE_CARD, cc.p(randomX + index * this.KHOANG_CACH_QUAN_BAI, randomY)), cc.rotateTo(self.TIME_MOVE_CARD, randomRotation)), cc.callFunc(function () {
            // if (!isMyCard) {
            //     cardNew.setScaleX(0, 1);
            // }
            // cardNew.runAction(cc.scaleTo(0.2, 1));
            cardNew.getComponent('CardUIPhom').setCard(Card.fromId(cardId));
            var isPlayerTakeCard = false;
            if (isTakeCardPhom) {
                cardNew.getComponent('CardUIPhom').hoverAnNode.active = true;
                if (self.player.data.username === AuthUser.username) {
                    cardNew.getComponent('CardUIPhom').interactable = true;
                    cardNew.getComponent('CardUIPhom').canMove = true;
                } else {
                    cardNew.getComponent('CardUIPhom').interactable = false;
                }
                if (playerTakeCardPhom.player.data.username === AuthUser.username) {
                    isPlayerTakeCard = true;
                }
                // self.onXepLaiBai(true);
            }
            if (desNode.getComponent(cc.Layout)) {
                desNode.getComponent(cc.Layout).enabled = true;
            }
            // self.onRefreshGame(false);
            self.node.emit('refresh_game', { isPlayerTakeCard: isPlayerTakeCard });
        }));
        action.easing(cc.easeQuarticActionOut());
        cardNew.runAction(action);
    },

    onRefreshGame: function onRefreshGame() {},

    findCard: function findCard(cardId, node) {
        if (node) {
            var childs = node.children;
            for (var i = 0; i < childs.length; i += 1) {
                var cardUIPhom = childs[i].getComponent('CardUIPhom');
                if (cardUIPhom) {
                    if (cardUIPhom.card && cardUIPhom.card.getId() === cardId) {
                        return cardUIPhom;
                    }
                }
            }
        }
        return null;
    },

    getCardTouched: function getCardTouched() {
        var childs = this.cardHold.children;
        var cards = [];
        for (var i = 0; i < childs.length; i += 1) {
            var cardUIPhom = childs[i].getComponent('CardUIPhom');
            if (cardUIPhom) {
                if (cardUIPhom.isTouched) {
                    cards.push(cardUIPhom);
                }
            }
        }
        return cards;
    },

    clearAll: function clearAll() {
        Utils.Node.destroyAllChildrenInNode(this.cardHold);
        // this.cardHold.removeAllChildren();
        this.clearCountDown();
        if (this.backCardNode) {
            this.backCardNode.active = false;
        }

        this.clearEffects();
    },

    showAllCards: function showAllCards(cards) {
        Utils.Node.destroyAllChildrenInNode(this.cardHold);
        // this.cardHold.removeAllChildren();
        if (this.portCardAnNode) {
            Utils.Node.destroyAllChildrenInNode(this.portCardAnNode);
            // this.portCardAnNode.removeAllChildren();
        }
        if (this.backCardNode) {
            this.backCardNode.active = false;
        }
        for (var i = 0; i < cards.length; i += 1) {
            var cardNew = cc.instantiate(this.cardPrefab);
            cardNew.parent = this.cardHold;
            cardNew.getComponent('CardUIPhom').setCard(Card.fromId(cards[i]));
            cardNew.getComponent('CardUIPhom').interactable = false;
            cardNew.setScale(0, 1);
            cardNew.runAction(cc.scaleTo(0.3, 1));
        }
    },

    showTrashCard: function showTrashCard(cards) {
        var card;
        var randomX = Math.random();
        var randomY = Math.random();
        randomX = (randomX < 0.5 ? -randomX : randomX) * this.CONSTANT_X;
        randomY = (randomY < 0.5 ? -randomY : randomY) * this.CONSTANT_Y;
        var randomRotation = Math.random();
        randomRotation *= (randomRotation < 0.5 ? -randomRotation : randomRotation) * this.CONSTANT_ROTATION;
        for (var i = 0; i < cards.length; i += 1) {
            card = cc.instantiate(this.cardPrefab);
            card.parent = this.portCardTrash;
            var cardUIPhom = card.getComponent('CardUIPhom');
            cardUIPhom.setCard(Card.fromId(cards[i]));
            cardUIPhom.interactable = false;
            card.position = cc.p(randomX + i * this.KHOANG_CACH_QUAN_BAI, randomY);
            card.rotation = randomRotation;
        }
    },

    showMoneyExchange: function showMoneyExchange(moneyExchange) {
        this.moneyExchangeLabel.node.y = 30;
        this.moneyExchangeLabel.node.opacity = 255;
        this.moneyExchangeLabel.node.active = true;
        if (moneyExchange > 0) {
            this.moneyExchangeLabel.string = '+' + Utils.Number.abbreviate(moneyExchange);
        } else {
            this.moneyExchangeLabel.string = Utils.Number.abbreviate(moneyExchange);
        }
        this.moneyExchangeLabel.node.stopAllActions();
        this.moneyExchangeLabel.node.runAction(this.moneyExchangeAction);
    },

    onRefresh: function onRefresh() {
        var touchedCards = this.getCardTouched();
        Utils.Node.destroyAllChildrenInNode(this.cardHold);
        // this.cardHold.removeAllChildren();
        this.cardHold.getComponent(cc.Layout).enabled = true;
        if (this.player.data.cards) {
            var cards = this.player.data.cards;
            for (var i = 0, j = 0; i < cards.length; i += 1) {
                var cardNew = cc.instantiate(this.cardPrefab);
                var cardUIPhom = cardNew.getComponent('CardUIPhom');
                cardUIPhom.setCard(Card.fromId(cards[i]));
                cardNew.parent = this.cardHold;
                cardNew.position = cc.p(0, 0);
                cardUIPhom.interactable = true;
                if (touchedCards && touchedCards[j] && touchedCards[j].card.getId() === cards[i]) {
                    // cardUIPhom.onButtonTouch(true);
                    cardUIPhom.isTouched = true;
                    cardUIPhom.node.setPosition(0, cardUIPhom.posYFirst + cardUIPhom.DELTA_Y_TOUCHED);
                    j += 1;
                }
            }
        } else {
            if (this.backCardNode && this.player.data.handSize) {
                this.backCardNode.active = true;
                this.numberCardLabel.string = this.player.data.handSize;
            }
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","Card":"Card","PlayerUI":"PlayerUI","Utils":"Utils"}],"PlayerUIXiTo":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7bd4cN9xFVHU6Y+P7+jwsND', 'PlayerUIXiTo');
// scripts\components\games\xito\PlayerUIXiTo.js

var CardUI = require('CardUI'),
    GameConstant = require('GameConstant'),
    Card = require('Card');
cc.Class({
    'extends': cc.Component,

    properties: {
        cardsHold: {
            'default': [],
            type: CardUI
        },
        callMoneyLabel: cc.Label,
        callMoneyNode: cc.Node,
        cardsResultLabel: cc.Label,
        holdNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.trashCards = [];
    },

    getNumberActiveChildren: function getNumberActiveChildren() {
        var count = 0;
        for (var i = 0; i < this.cardsHold.length; i += 1) {
            if (this.cardsHold[i].node.active) {
                count += 1;
            }
        }
        return count;
    },

    fold: function fold() {
        for (var i = 0; i < this.cardsHold.length; i += 1) {
            this.cardsHold[i].fold();
            this.cardsHold[i].node.position = cc.p(this.cardsHold[i].node.x, 0);
        }
    },

    currentPlayerFold: function currentPlayerFold() {
        for (var i = 0; i < this.cardsHold.length; i += 1) {
            if (this.cardsHold[i].node.active) {
                this.cardsHold[i].showTransparentBlackNode(true);
                this.cardsHold[i].node.position = cc.p(this.cardsHold[i].node.x, 0);
            }
        }
    },

    hideAllCards: function hideAllCards(activeOnly) {
        for (var i = 0; i < this.cardsHold.length; i += 1) {
            this.cardsHold[i].showTransparentBlackNode(false);
            this.cardsHold[i].node.position = cc.p(this.cardsHold[i].node.x, 0);
            this.cardsHold[i].node.active = false;
            // this.cardsHold[i].node.stopAllActions();
            // this.cardsHold[i].node.setScale(1);
            if (!activeOnly) {
                this.cardsHold[i].fold();
            }
        }
    },

    deactiveAllCards: function deactiveAllCards() {
        this.hideAllCards(false);
        this.cardsResultLabel.string = '';
        if (this.trashCards) {
            for (var j = 0; j < this.trashCards.length; j += 1) {
                this.trashCards[j].destroy();
            }
        }
        this.trashCards = [];
    },

    showAllCards: function showAllCards(cards, bestCards, bestCardsType, gameCmd, delayTime) {
        if (gameCmd !== GameConstant.POKER.CMD) {
            if (cards) {
                for (var i = 0; i < cards.length; i += 1) {
                    var cardScript = this.cardsHold[i].getComponent('CardUI');
                    cardScript.fold();
                    this.cardsHold[i].node.stopAllActions();
                    this.cardsHold[i].node.active = true;
                    this.cardsHold[i].node.setScale(1);
                    this.cardsHold[i].showTransparentBlackNode(true);
                    cardScript.setCard(Card.fromId(cards[i]));
                    if (bestCards) {
                        for (var j = 0; j < bestCards.length; j += 1) {
                            if (cards[i] === bestCards[j]) {
                                this.cardsHold[i].showTransparentBlackNode(false);
                                this.cardsHold[i].node.runAction(cc.moveTo(0.1, cc.p(this.cardsHold[i].node.x, 30)));
                                break;
                            }
                        }
                    }
                }
            }
            if (bestCardsType) {
                this.cardsResultLabel.string = bestCardsType.toUpperCase();
            }
        } else {
            this.showAllCardsPoker(cards, bestCards, bestCardsType, delayTime);
        }
    },

    showAllCardsPoker: function showAllCardsPoker(cards, bestCards, bestCardsType, delayTime) {
        for (var j = 0; j < this.trashCards.length; j += 1) {
            this.trashCards[j].destroy();
        }
        this.trashCards = [];
        if (cards) {
            for (var i = 0; i < cards.length; i += 1) {
                this.cardsHold[i].node.active = false;
                this.cardsHold[i].fold();
                var card = cc.instantiate(this.cardsHold[i].node);
                var cardScript = card.getComponent('CardUI');
                card.parent = this.cardsHold[i].node.parent.parent;
                card.x = i === 0 ? -17 : 17;
                card.y = 10;
                card.rotation = 0;
                card.setScale(0, 0.55);
                cardScript.setCard(Card.fromId(cards[i]));
                card.active = true;
                // card.stopAllActions();
                card.runAction(cc.sequence(cc.scaleTo(0.5, 0.55), cc.delayTime(delayTime), cc.removeSelf()));
                this.trashCards.push(card);
            }
        }
        if (bestCardsType) {
            this.cardsResultLabel.string = bestCardsType.toUpperCase();
        }
    },

    findCard: function findCard(cardId) {
        for (var i = 0; i < this.cardsHold.length; i += 1) {
            var cardScript = this.cardsHold[i].getComponent('CardUI');

            if (cardScript.card && cardScript.card.getId() === cardId) {
                return this.cardsHold[i];
            }
        }
    }
});

cc._RFpop();
},{"Card":"Card","CardUI":"CardUI","GameConstant":"GameConstant"}],"PlayerUI":[function(require,module,exports){
"use strict";
cc._RFpush(module, '15458hBSZhEhY4yBNZfQwrR', 'PlayerUI');
// scripts\components\games\ui\PlayerUI.js

var UrlImage = require('UrlImage'),
    Utils = require('Utils'),
    PlayerConstant = require('PlayerConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        emptyNode: cc.Node,
        nonEmptyNode: cc.Node,

        // effects: [win, draw, lose]
        defaultEffectTemplatesPrefab: cc.Prefab,
        effectTemplateNodeList: {
            'default': [],
            type: cc.Node
        },
        backEffectListNode: cc.Node,
        frontEffectListNode: cc.Node,

        countDownContainerNode: cc.Node,
        countDownSprite: cc.Sprite,

        avatarImage: UrlImage,
        usernameLabel: cc.Label,
        balanceLabel: cc.Label,

        chatCalloutDuration: 5000,

        normalUsernameColor: cc.Color,
        mainUsernameColor: cc.Color,

        normalCountDownColor: new cc.Color(0, 255, 0, 255)
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.TIME_EFFECT_MONEY_EXCHANGE = 3;
        this.TIME_EFFECT_MONEY_EXCHANGE_FADE_OUT = 0.3;
        this.moneyExchangeAction = cc.spawn(cc.moveBy(this.TIME_EFFECT_MONEY_EXCHANGE, cc.p(0, 90)), cc.sequence(cc.delayTime(this.TIME_EFFECT_MONEY_EXCHANGE - this.TIME_EFFECT_MONEY_EXCHANGE_FADE_OUT), cc.fadeTo(this.TIME_EFFECT_MONEY_EXCHANGE_FADE_OUT, 0)));
        this.moneyExchangeAction.easing(cc.easeQuadraticActionOut());

        // Chat Node
        this._initChatCallout();
    },

    onDestroy: function onDestroy() {
        this.clearCountDown();
        this.clearChatMessage();
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    /**
     * Set player.
     *
     * @param {Player} player player object, if null, remove player
     */
    setPlayer: function setPlayer(player) {
        if (this.player === player) {
            return;
        }

        this.setUpCountdownNode();

        this.player = player;
        if (this.player && this.player.data) {
            this.emptyNode.active = false;
            this.nonEmptyNode.active = true;

            if (this.player.data.avatar) {
                var widget = this.avatarImage.node.getComponent(cc.Widget);
                widget.isAlignOnce = false;
                this.avatarImage.loadImage(this.player.data.avatar);
            }

            this.usernameLabel.node.color = this.player.isMe() ? this.mainUsernameColor : this.normalUsernameColor;
            this.usernameLabel.string = this.player.data.displayName || this.player.data.username;

            this.onUpdateUserMoney();

            this.player.eventDispatcher.addEventListener(PlayerConstant.Event.UPDATE_MONEY, this.onUpdateUserMoney, this);
        } else {
            this.removePlayer();
        }
    },

    /**
     * Remove player.
     */
    removePlayer: function removePlayer() {
        if (this.player) {
            this.player.eventDispatcher.removeEventListener(PlayerConstant.Event.UPDATE_MONEY, this.onUpdateUserMoney, this);
            this.player = null;
        }

        this.emptyNode.active = true;
        this.nonEmptyNode.active = false;
        this.clearEffects();
    },

    /**
     * Remove player.
     */
    setUpCountdownNode: function setUpCountdownNode() {
        this.bgTimeCountDownNode = this.countDownContainerNode.getChildByName('BgTimeCountDown');
        this.countDownSprite.node.width = 163;
        this.countDownSprite.node.height = 163;
        this.starNode = this.countDownContainerNode.getChildByName('ImgLapLanh');
        this.starImage = this.starNode.getChildByName('Img');
        this.starImage.setPositionY(80);
    },

    /**
     * Set effect by index.
     *
     * @param {Number}  effectIndex   effect index
     * @param {Boolean} bringToFront  effect will be over balance label
     */
    setEffect: function setEffect(effectIndex, bringToFront) {
        this.clearEffects();
        this.addEffect(effectIndex, bringToFront);
    },

    /**
     * Add effect by index.
     *
     * @param {Number}  effectIndex   effect index
     * @param {Boolean} bringToFront  effect will be over balance label
     */
    addEffect: function addEffect(effectIndex, bringToFront) {
        this._addEffect(this.effectTemplateNodeList[effectIndex], bringToFront);
    },

    /**
     * Remove effect by index.
     *
     * @param {Number}  effectIndex effect index
     */
    removeEffect: function removeEffect(effectIndex) {
        var effectTemplate = this.effectTemplateNodeList[effectIndex],
            uuid = effectTemplate && effectTemplate.uuid;
        if (uuid) {
            this._removeEffect(uuid);
        }
    },

    /**
     * Clear all effects.
     */
    clearEffects: function clearEffects() {
        this.backEffectListNode.removeAllChildren();
        this.frontEffectListNode.removeAllChildren();
    },

    /**
     * Set time left count down.
     *
     * @param {Number} timeLeft time left amount in ms
     */
    setCountDown: function setCountDown(timeLeft) {
        if (timeLeft > 0 && this.player) {
            this.clearCountDown();
            this.countDownContainerNode.active = true;
            this.bgTimeCountDownNode.color = this.normalCountDownColor;
            this.countDownSprite.node.color = this.normalCountDownColor;
            this.countDownSprite.fillRange = 1;
            this.starNode.rotation = 0;
            this.starNode.active = true;
            this._stopTimestamp = Date.now() + timeLeft;
            this.countTime = 0;
            var INTERVAL = 25;
            this._countDownIntervalId = setInterval((function () {
                var t = this._stopTimestamp - Date.now();
                var color = this.countDownSprite.node.color;

                if (t >= 0) {
                    if (color.r < 255) {
                        color.r = 2 * (1 - t / timeLeft) * 255;
                        color.r = color.r > 255 ? 255 : color.r;
                        // this.bgTimeCountDownNode.color = color;
                        this.countDownSprite.node.color = color;
                    } else {
                        color.g = 2 * t / timeLeft * 255;
                        color.g = color.g < 0 ? 0 : color.g;
                        // this.bgTimeCountDownNode.color = color;
                        this.countDownSprite.node.color = color;
                    }
                    this.starImage.setScale(1);
                    this.starNode.rotation = (1 - t / timeLeft) * 360;
                    this.countTime += 1 - t / timeLeft;
                    if (this.countTime >= 2) {
                        this.starImage.runAction(cc.scaleTo(0.1, 0.5));
                        this.countTime = 0;
                    }
                    this.countDownSprite.fillRange = t / timeLeft;
                } else {
                    this.clearCountDown();
                }
            }).bind(this), INTERVAL);
        }
    },

    /**
     * Clear count down effect.
     */
    clearCountDown: function clearCountDown() {
        if (this._countDownIntervalId) {
            clearInterval(this._countDownIntervalId);
            this._countDownIntervalId = null;
            this.countDownSprite.fillRange = 0;
            this.countDownContainerNode.active = false;
        }
    },

    /**
     * Set chat callout message.
     *
     * @param {String} msg chat message
     */
    setChatMessage: function setChatMessage(msg) {
        if (this.chatCalloutDuration > 0 && this.player) {
            var maxLength = 82;
            if (msg.length > maxLength) {
                msg = msg.substring(0, maxLength) + '...';
            }
            this._initChatCallout();
            this.clearChatMessage();
            this.chatCalloutNode.active = true;
            this.chatCalloutNode.getComponentInChildren(cc.Label).string = msg;
            // Fix Bug Cocos Creator 1.3.1
            this.chatCalloutNode.getComponent(cc.Layout).resizeMode = cc.Layout.ResizeMode.CONTAINER;

            // Action
            this.chatCalloutNode.scale = 0;
            this.chatCalloutNode.runAction(cc.sequence(cc.scaleTo(0.1, this.chatCalloutNodeScale.x, this.chatCalloutNodeScale.y), cc.callFunc((function () {
                // Check y + height
                this.chatCalloutNode.y = 50;
                var size = cc.winSize;
                var wolrdPos = this.chatCalloutNode.convertToWorldSpaceAR(cc.v2());
                if (wolrdPos.y > size.height - this.chatCalloutNode.height) {
                    this.chatCalloutNode.y = 5;
                }
            }).bind(this))));
            this._chatIntervalId = setTimeout((function () {
                this.clearChatMessage();
            }).bind(this), this.chatCalloutDuration);
        }
    },

    /**
     * Clear chat callout message.
     */
    clearChatMessage: function clearChatMessage() {
        if (this._chatIntervalId) {
            clearInterval(this._chatIntervalId);
            this._chatIntervalId = null;
            this.chatCalloutNode.active = false;
        }
    },

    onUpdateUserMoney: function onUpdateUserMoney() {
        if (this.player) {
            this.balanceLabel.string = Utils.Number.abbreviate(this.player.data.money);
        }
    },

    // ============================================================
    // Default effects
    // ============================================================

    setFinishEffect: function setFinishEffect(money) {
        if (money > 0) {
            this.setWinEffect(money);
        } else if (money < 0) {
            this.setLoseEffect(money);
        } else {
            this.setDrawEffect();
        }
    },

    setWinEffect: function setWinEffect(money) {
        if (money > 0) {
            this.clearEffects();

            var node = this._addEffect(this._getDefaultEffectTemplateByName('Win'), true),
                winMoneyLabel;
            if (node) {
                winMoneyLabel = node.getComponentInChildren(cc.Label);
                if (winMoneyLabel) {
                    winMoneyLabel.node.zIndex = 10;
                    winMoneyLabel.string = '+' + Utils.Number.abbreviate(money);
                    var x = this.node.x > 0 ? -90 : 90;
                    var y = 30;
                    winMoneyLabel.node.position = new cc.Vec2(x, y);
                    winMoneyLabel.node.stopAllActions();
                    if (this.moneyExchangeAction) {
                        winMoneyLabel.node.runAction(this.moneyExchangeAction);
                    }
                }
            }
        }
    },

    setDrawEffect: function setDrawEffect() {
        this.clearEffects();
        this._addEffect(this._getDefaultEffectTemplateByName('Draw'));
    },

    setLoseEffect: function setLoseEffect(money) {
        if (money < 0) {
            this.clearEffects();

            var node = this._addEffect(this._getDefaultEffectTemplateByName('Lose')),
                loseMoneyLabel;
            if (node) {
                loseMoneyLabel = node.getComponentInChildren(cc.Label);
                if (loseMoneyLabel) {
                    loseMoneyLabel.node.zIndex = 10;
                    loseMoneyLabel.string = Utils.Number.abbreviate(money);
                    var x = this.node.x > 0 ? -90 : 90;
                    var y = 30;
                    loseMoneyLabel.node.position = new cc.Vec2(x, y);
                    loseMoneyLabel.node.stopAllActions();
                    if (this.moneyExchangeAction) {
                        loseMoneyLabel.node.runAction(this.moneyExchangeAction);
                    }
                }
            }
        }
    },

    removeWinEffect: function removeWinEffect() {
        this._removeDefaultEffectByName('Win');
    },

    removeDrawEffect: function removeDrawEffect() {
        this._removeDefaultEffectByName('Draw');
    },

    removeLoseEffect: function removeLoseEffect() {
        this._removeDefaultEffectByName('Lose');
    },

    _removeDefaultEffectByName: function _removeDefaultEffectByName(effectName) {
        var effectTemplate = this._getDefaultEffectTemplateByName(effectName),
            uuid = effectTemplate && effectTemplate.uuid;
        if (uuid) {
            this._removeEffect(uuid);
        }
    },

    _getDefaultEffectTemplateByName: function _getDefaultEffectTemplateByName(effectName) {
        if (!this.defaultEffectTemplatesNode) {
            this.defaultEffectTemplatesNode = cc.instantiate(this.defaultEffectTemplatesPrefab);
        }
        return this.defaultEffectTemplatesNode.getChildByName(effectName);
    },

    _addEffect: function _addEffect(effectTemplate, bringToFront) {
        if (effectTemplate) {
            var node = cc.instantiate(effectTemplate);
            node.active = true;
            node._effectTemplateUUID = effectTemplate.uuid;
            (bringToFront ? this.frontEffectListNode : this.backEffectListNode).addChild(node);
            return node;
        }
        return null;
    },

    _removeEffect: function _removeEffect(effectTemplateUUID) {
        this._removeEffectFrom(this.backEffectListNode, effectTemplateUUID);
        this._removeEffectFrom(this.frontEffectListNode, effectTemplateUUID);
    },

    _removeEffectFrom: function _removeEffectFrom(effectListNode, effectTemplateUUID) {
        var children = effectListNode.getChildren();
        Utils.Array.forEach(children, (function (child) {
            if (child._effectTemplateUUID === effectTemplateUUID) {
                effectListNode.removeChild(child);
            }
        }).bind(this));
    },

    _initChatCallout: function _initChatCallout() {
        if (!this.chatCalloutNode) {
            cc.loader.loadRes('games/ui/player/PlayerChat', (function (err, prefab) {
                this.chatCalloutNode = cc.instantiate(prefab);
                this.node.addChild(this.chatCalloutNode);

                // Reset Position
                if (this.node.x > 0) {
                    this.chatCalloutNode.x = -200;
                    this.chatCalloutNode.scaleX = 1;
                    this.chatCalloutNode.getComponentInChildren(cc.Label).node.scaleX = 1;
                } else {
                    this.chatCalloutNode.x = 200;
                    this.chatCalloutNode.scaleX = -1;
                    this.chatCalloutNode.getComponentInChildren(cc.Label).node.scaleX = -1;
                }

                // Get Scale
                this.chatCalloutNodeScale = {
                    x: this.chatCalloutNode.scaleX,
                    y: this.chatCalloutNode.scaleY
                };

                // Scale To 0
                this.chatCalloutNode.scale = 0;
            }).bind(this));
        }
    }

});

cc._RFpop();
},{"PlayerConstant":"PlayerConstant","UrlImage":"UrlImage","Utils":"Utils"}],"Player":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'fef7daKm5ZE2IwyMesXshNB', 'Player');
// scripts\games\common\player\Player.js

var Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    EventDispatcher = require('EventDispatcher'),
    PlayerConstant = require('PlayerConstant'),
    Player;

Player = Utils.Class({
    $$constructor: function $$constructor(playerData) {
        if (!Utils.Type.isObject(playerData)) {
            throw 'Cannot create a player with non-object data';
        }
        this.data = playerData;
        this.eventDispatcher = EventDispatcher.create();
    },

    $$static: {
        fromAuthUser: function fromAuthUser(currency) {
            if (AuthUser.username && currency) {
                var playerData = {
                    username: AuthUser.username,
                    displayName: AuthUser.display_name,
                    avatar: AuthUser.avatar,
                    currency: currency,
                    money: AuthUser.currencies[currency].balance
                };
                return new Player(playerData);
            }

            return null;
        }
    },

    isMe: function isMe(playerData) {
        if (playerData) {
            return this.data.username === playerData.username;
        }

        if (this.data) {
            return this.data.username === AuthUser.username;
        }

        return false;
    },

    update: function update(playerData) {
        if (this.isMe(playerData)) {
            this.setMoney(playerData.money);
            cc.js.mixin(this.data, playerData);
        }
    },

    setMoney: function setMoney(newMoney) {
        if (this.data.money !== newMoney) {
            this.data.money = newMoney;
            this.eventDispatcher.dispatchEvent(PlayerConstant.Event.UPDATE_MONEY);
        }
    }
});

module.exports = Player;

cc._RFpop();
},{"AuthUser":"AuthUser","EventDispatcher":"EventDispatcher","PlayerConstant":"PlayerConstant","Utils":"Utils"}],"PokerConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '26d60dJjjxOpJsVr/8Itdzz', 'PokerConstant');
// scripts\games\poker\PokerConstant.js

module.exports = {

    Action: {
        BET: 1,
        RAISE: 2,
        ALL_IN: 3,
        ALL_HAND: 31,
        CALL: 4,
        CHECK: 5,
        FOLD: 6,
        CHANGE_STATE: 7,
        CHANGE_TURN: 8,
        BUY_PRIVATE_MONEY: 9,
        BUY_PRIVATE_MONEY_REQUIRED: 10,
        END_TURN: 11,
        CUT_OFF_MONEY_POKER: 12,
        GET_BUY_PRIVATE_MONEY_INFO: 13
    },

    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        FINALIZING: 6,
        FINISH: 7,
        ROUND: 8
    },

    GameStatePoker: {
        PREFLOP: 8,
        FLOP: 9,
        TURN: 10,
        RIVER: 11
    },

    PlayerState: {
        NONE: 0,
        IN_TURN: 1,
        WAITING_FOR_TURN: 2,
        FOLDED: 3,
        ALL_IN: 4,
        OFF_MONEY: 5
    },

    Event: {
        START_TIME: 'in_game.xito.start_time',
        USER_BET: 'in_game.xito.user_bet',
        CHANGE_STATE: 'in_game.xito.change_state',
        CHANGE_TURN: 'in_game.xito.change_turn',
        UPDATE_MONEY: 'in_game.xito.update_money',
        SHOW_CARD_OPEN: 'in_game.xito.show_card_open',
        DRAW_CARD: 'in_game.xito.draw_card',
        FINISH_GAME: 'in_game.xito.finish_game',
        UPDATE_GAME: 'in_game.xito.update_game',
        REFRESH_GAME: 'in_game.xito.refresh_game',
        SHOW_BUY_CHIP: 'in_game.poker.show_buy_chip',
        HIDE_BUY_CHIP_BUTTON: 'in_game.poker.hide_buy_chip_button',
        CUT_OFF_MONEY_POKER: 'in_game.poker.cut_off_money'
    },

    TimeoutId: {
        SHOW_COMMUNITY_CARDS: 'TIMEOUT_SHOW_COMMUNITY_CARDS'
    },

    Effect: {
        TO: 0,
        THEO: 1,
        NHUONG_TO: 2,
        UP_BO: 3,
        CHOI_TAT_TAY: 4,
        DANG_DOI: 9

    }

};

cc._RFpop();
},{}],"PokerGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '24809FqTrRImYlZ5nKDZMsg', 'PokerGameManager');
// scripts\games\poker\PokerGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    PokerConstant = require('PokerConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    PokerGameManager;

PokerGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this._setGameState(PokerConstant.GameState.NONE);

        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.NEW_MATCH.ID, this.restartGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaittingDealCard, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_HAND.ID, this.onUpdateHand, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_PRIVATE_USER_MONEY.ID, this.onUpdatePrivateUserMoney, this);

        // các action của game play
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.BET, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.ALL_IN, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.CALL, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.CHECK, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.FOLD, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.RAISE, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.CHANGE_STATE, this.onChangeStateGame, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.CHANGE_TURN, this.onChangeTurn, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.BUY_PRIVATE_MONEY_REQUIRED, this.onBuyPrivateMoneyRequired, this);
        this.eventDispatchers.playCmd.addEventListener(PokerConstant.Action.CUT_OFF_MONEY_POKER, this.onCutOffMoney, this);
    },

    fetchInitialGameData: function fetchInitialGameData() {
        this.$super.fetchInitialGameData.call(this);
        this.getBuyMoneyInfo();
    },

    // ============================================================
    // Send API
    // ============================================================
    bet: function bet(betting, moneyBetting) {
        if (moneyBetting) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(betting),
                money: NetworkManager.SmartFox.type.long(moneyBetting)
            });
        } else {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(betting)
            });
        }
    },

    buyMoneyJoinTable: function buyMoneyJoinTable(money) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PokerConstant.Action.BUY_PRIVATE_MONEY),
            money: NetworkManager.SmartFox.type.long(money)
        });
    },

    getBuyMoneyInfo: function getBuyMoneyInfo() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(PokerConstant.Action.GET_BUY_PRIVATE_MONEY_INFO)
        });
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.currency = params.data.currency;
        this.roomBetting = params.data.betting;
        this._setGameState(params.data.gameState, params);
        this.onUpdateHand();
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.UPDATE_GAME, params);
    },

    onUpdateHand: function onUpdateHand() {
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.DRAW_CARD);
    },

    onPlayerBetting: function onPlayerBetting(params) {
        this._setGameState(params.allData.gameState, params);
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.USER_BET, params);
    },

    onWaittingDealCard: function onWaittingDealCard(params) {
        this._setGameState(params.allData.gameState, params);
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.START_TIME, params.data.time);
    },

    onChangeStateGame: function onChangeStateGame(params) {
        this.currentRound = params.allData.currentRound;
        this._setGameState(params.allData.gameState, params);
    },

    onChangeTurn: function onChangeTurn(params) {
        this._setGameState(params.allData.gameState, params);
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.CHANGE_TURN, params);
    },

    onFinishGame: function onFinishGame(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.FINISH_GAME, params);
    },

    onCutOffMoney: function onCutOffMoney(params) {
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.CUT_OFF_MONEY_POKER, params);
    },

    restartGame: function restartGame() {
        this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.REFRESH_GAME);
    },

    _setGameState: function _setGameState(newGameState, params) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            if (params) {
                this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.CHANGE_STATE, params);
            }
        }
    },

    onBuyPrivateMoneyRequired: function onBuyPrivateMoneyRequired(params) {
        if (this.current.player.data.username === params.data.userName) {
            this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.SHOW_BUY_CHIP, [params.data.minMoney, params.data.maxMoney, params.data.totalMoney]);
        }
    },

    onUpdatePrivateUserMoney: function onUpdatePrivateUserMoney(params) {
        if (this.current.player.data.username === params.username) {
            this.eventDispatchers.local.dispatchEvent(PokerConstant.Event.HIDE_BUY_CHIP_BUTTON);
        }
    }

});

// ============================================================
// Action API
// ============================================================

module.exports = PokerGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","PokerConstant":"PokerConstant","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"PotInforSanThuong":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8fbe2UAdEJPl4orb5H1pX6x', 'PotInforSanThuong');
// scripts\components\games\san_thuong\PotInforSanThuong.js

cc.Class({
    "extends": cc.Component,

    properties: {
        activePotSprite: cc.Sprite
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.isActive = true;
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
    //
    clickPot: function clickPot() {
        if (this.isActive) {
            this.isActive = false;
        } else {
            this.isActive = true;
        }
        this.activePotSprite.node.active = this.isActive;
    },

    activePot: function activePot(isActive) {
        this.isActive = isActive;
        this.activePotSprite.node.active = isActive;
    }

});

cc._RFpop();
},{}],"Profile":[function(require,module,exports){
"use strict";
cc._RFpush(module, '775a4UUmQBLWajtYFKIDldm', 'Profile');
// scripts\components\profile\Profile.js

var Url = require('Url'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    UrlImage = require('UrlImage'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant'),
    EventDispatcher = require('EventDispatcher'),
    PlatformImplement = require('PlatformImplement'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        xuLabel: cc.Label,
        piLabel: cc.Label,
        vipLabel: cc.Label,
        emailLabel: cc.Label,
        levelLabel: cc.Label,
        userAvatar: UrlImage,
        numPhoneLabel: cc.Label,
        displayNameLabel: cc.Label,
        levelPercentSprite: cc.Sprite
    },

    // use this for initialization
    onLoad: function onLoad() {
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_INFO, this.onCompleteChangeInfo, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_AVATAR, this.onCompleteUpdateAvatar, this);

        this.xuLabel.string = AuthUser.currencies[CommonConstant.CurrencyType.Xu.NAME].balance;
        this.xuLabel.string = Utils.Number.format(this.xuLabel.string);
        this.piLabel.string = AuthUser.currencies[CommonConstant.CurrencyType.Ip.NAME].balance;
        this.piLabel.string = Utils.Number.format(this.piLabel.string);

        this.levelLabel.string = 'LV: ' + AuthUser.level;
        this.vipLabel.string = AuthUser.vip_level || '0';
        this.levelPercentSprite.fillRange = AuthUser.level_percent;

        this.numPhoneLabel.string = AuthUser.mobile || 'Chưa có';
        this.displayNameLabel.string = AuthUser.display_name;
        this.emailLabel.string = AuthUser.email;
        this.userAvatar.loadImage(AuthUser.avatar);
    },

    onButtonBack: function onButtonBack() {
        var scene = Utils.Director.getPreviousSceneName() || CommonConstant.Scene.HALL;
        if (scene === CommonConstant.Scene.PROFILE) {
            scene = CommonConstant.Scene.HALL;
        }
        Utils.Director.loadScene(scene);
    },

    uploadAvatar: function uploadAvatar(event) {
        var self = this;
        PlatformImplement.uploadFile({
            accept: 'image/*'
        }, function (fileData) {
            var loadingComponent = self.node.getComponentInChildren('Loading'),
                loadingNode = loadingComponent && loadingComponent.node;
            if (loadingNode) {
                loadingNode.active = true;
            }
            NetworkManager.Http.fetch('POST', Url.Http.USER_UPDATE_AVATAR, {
                username: AuthUser.username,
                accesstoken: AuthUser.accesstoken,
                avatar: fileData
            }).success(function (rspDone) {
                if (loadingNode) {
                    loadingNode.active = false;
                }
                AuthUser.avatar = rspDone.data;
                EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_AVATAR);
                UiManager.openModal('Xin chúc mừng, bạn đã cập nhật avatar thành công.');
            }).error(function () {
                if (loadingNode) {
                    loadingNode.active = false;
                }
            }).setWaitingButton(event.target);
        });
    },

    onCompleteChangeInfo: function onCompleteChangeInfo() {
        this.displayNameLabel.string = AuthUser.display_name;
        this.emailLabel.string = AuthUser.email;
    },

    onCompleteUpdateAvatar: function onCompleteUpdateAvatar() {
        this.userAvatar.loadImage(AuthUser.avatar);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_INFO, this.onCompleteChangeInfo, this);
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_AVATAR, this.onCompleteUpdateAvatar, this);
    }

});

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","UiManager":"UiManager","Url":"Url","UrlImage":"UrlImage","Utils":"Utils"}],"RouletteConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e16f035pAlGJJrzHStk4Fre', 'RouletteConstant');
// scripts\games\roulte\RouletteConstant.js

var Utils = require('Utils');

module.exports = {
    Action: {
        BETTING: 1,
        CANCEL_BET: 2,
        TURN_MASTER: 3,
        MASTER_SELL_POT: 4,
        CHANGE_STATE: 5,
        UPDATE_POTS: 9
    },
    GameState: {
        NONE: 0,
        EFFECT: 1,
        PLAYER_BETTING: 2,
        MASTER_CANEL_BET: 3,
        FINISH: 4,
        FINALIZING: 5,
        ROTATE_VONG_QUAY: 6
    },
    ChipColor: {
        BLUE: {
            ID: 0,
            NAME: 'blue'
        },

        PURPLE: {
            ID: 1,
            NAME: 'purple'
        },

        GREEN: {
            ID: 2,
            NAME: 'green'
        },

        RED: {
            ID: 3,
            NAME: 'red'
        },

        findById: function findById(potId) {
            potId = parseInt(potId, 10);
            return Utils.Object.findObject(this, 'ID', potId);
        }
    },
    Event: {
        TURN_START: 'in_game.roulette.turn_start',
        BETTING_SUCCESS: 'in_game.roulette.betting_success',
        ROTATE_VONG_QUAY: 'in_game.roulette.rotate_vong_quay',
        FINISH_GAME: 'in_game.roulette.finish_game',
        CHANGE_STATE: 'in_game.roulette.change_state',
        CANCEL_BET: 'in_game.roulette.cancel_bet',
        BETTING_UPDATEGAME: 'in_game.roulette.betting_updategame',
        ADD_LIST_BETTING: 'in_game.roulette.add_list_betting'
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"RouletteGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'fe3caOBx19CHYwE/LwZL/l1', 'RouletteGameManager');
// scripts\games\roulte\RouletteGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    RouletteConstant = require('RouletteConstant'),

// Url = require('Url'),
RoulteGameManager;

var RoulteGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(gameCmd, roomId, logEnabled) {
        this.$super.constructor.call(this, gameCmd, roomId, logEnabled, true);

        this.currentBet = [];
        this.history = [];
        this.isMaster = false;
        this.lstRatio = [];
        this.time = 0;
        this.bettingList = [];

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(RouletteConstant.Action.BETTING, this.onBettingSuccess, this);
        this.eventDispatchers.playCmd.addEventListener(RouletteConstant.Action.CHANGE_STATE, this.onChangeState, this);
        this.eventDispatchers.playCmd.addEventListener(RouletteConstant.Action.CANCEL_BET, this.onCancelBetting, this);
    },

    // Send API
    //
    sellBetCancelBet: function sellBetCancelBet(pot) {
        if (this.isMaster) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(RouletteConstant.Action.MASTER_SELL_POT),
                pot: NetworkManager.SmartFox.type.byte(pot)
            });
        }
    },

    sendBet: function sendBet(pot, moneyBet) {
        if (!this.isMaster && moneyBet > 0) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(RouletteConstant.Action.BETTING),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(pot),
                money: NetworkManager.SmartFox.type.long(moneyBet)
            });
        }
    },

    sendReBet: function sendReBet() {
        for (var i = 0; i < this.history.length; i += 2) {
            this.sendBet(this.history[i], this.history[i + 1]);
        }
    },

    sendDoubleBet: function sendDoubleBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.sendBet(this.currentBet[i], this.currentBet[i + 1]);
        }
    },

    sendCancelBet: function sendCancelBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(RouletteConstant.Action.CANCEL_BET),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(this.currentBet[i])
            });
        }
    },

    // End Send API
    //
    //
    //
    //
    onFinishGame: function onFinishGame(params) {
        // {time: 5000, players: Array[3], command: 30, potWin: Array[6], banker: Object}
        this._setGameState(5);
        this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.FINISH_GAME, params);
        if (this.currentBet.length > 0) {
            this.history = this.currentBet;
            this.currentBet = [];
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}
        this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.CANCEL_BET, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet = [];
        }
    },

    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 5, username: "ngohoangtrung85044"}
        this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.BETTING_SUCCESS, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet.push(params.pot, params.money);
        }
    },
    onUpdateGame: function onUpdateGame(params) {
        this.bettingList = params.bettingValues;
        this._updateListBetting(params.bettingValues);
        this._updateRatio(params.potInfo);
        this.onChangeState(params);
        // if (this.gameState !== RouletteConstant.GameState.FINISH) {
        this._bettingUpdateGame(params.pots);
        // }
    },
    _updateRatio: function _updateRatio(params) {
        this.lstRatio = [];
        for (var i = 0; i < params.length; i += 1) {
            this.lstRatio.push(params[params[i].id].ratio);
        }
    },
    _bettingUpdateGame: function _bettingUpdateGame(params) {
        for (var i = 0; i < params.length; i += 1) {
            this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.BETTING_UPDATEGAME, params[i]);
        }
    },

    _updateListBetting: function _updateListBetting(params) {
        this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.ADD_LIST_BETTING, params);
    },

    onChangeState: function onChangeState(params) {
        this._setGameState(params.gameState);
        switch (params.gameState) {
            case RouletteConstant.GameState.EFFECT:
                this._rotate(params);
                break;
            case RouletteConstant.GameState.PLAYER_BETTING:
                this.time = Date.now() + params.time;
                // this.onPlayerBetting(params);
                break;
            case RouletteConstant.GameState.MASTER_CANEL_BET:
                this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.MASTER_CANEL_BET, params);
                break;
            default:
                break;
        }
    },
    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.CHANGE_STATE);
        }
    },
    _rotate: function _rotate(params) {
        this.eventDispatchers.local.dispatchEvent(RouletteConstant.Event.ROTATE_VONG_QUAY, params);
    }
});

module.exports = RoulteGameManager;

cc._RFpop();
},{"AuthUser":"AuthUser","BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","RouletteConstant":"RouletteConstant","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"RoulettePotInfor":[function(require,module,exports){
"use strict";
cc._RFpush(module, '96d424Xp41Dwq+koiIxBPif', 'RoulettePotInfor');
// scripts\components\games\roulte\RoulettePotInfor.js

var BaseMainGameplay = require('BaseMainGameplay'),
    AuthUser = require('AuthUser'),
    RouletteConstant = require('RouletteConstant'),
    Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        // myMoneyLabel: cc.Label,
        // totallMoneyLabel: cc.Label,
        // ratioLabel: cc.Label,
        // hieuUngThangSprite: cc.Sprite,
        sceneScript: BaseMainGameplay
    },

    // pot: 0,
    // btnCancelBet: cc.Sprite,
    onLoad: function onLoad() {
        if (!this.chipFackeList) {
            this.init();
        }
    },

    init: function init() {
        if (!this.chipFackeList) {
            this.potX = 0;
            this.playerBetList = {};
            this.chipFackeList = [];
            this.countChipList = [];
            this.isWin = false;
            this.totallMoneyLong = 0;
            this.myMoneyLong = 0;
        }
    },

    activeEfectWin: function activeEfectWin(isShow) {
        this.node.getChildByName('EfectWin').active = isShow;
        if (isShow) {
            var action = cc.repeatForever(cc.sequence(cc.fadeIn(0.8, 0), cc.fadeOut(0.8, 0)));
            this.node.getChildByName('EfectWin').runAction(action);
        } else {
            this.node.getChildByName('EfectWin').stopAllActions();
        }
    },
    addPlayerBetToPot: function addPlayerBetToPot(player, money) {
        var moneyTemp = this.playerBetList[player];
        if (Utils.Type.isNumber(moneyTemp)) {
            this.playerBetList[player] = money + moneyTemp;
        } else {
            this.playerBetList[player] = money;
        }
    },

    setMoneyPot: function setMoneyPot(myMoney, totallMoney) {
        this.totallMoneyLong += totallMoney;
        this.myMoneyLong += myMoney;
        if (totallMoney > 0) {
            // this.setFakeChip();
            this.caculateChip();
        }
    },

    // setFakeChip: function() {
    //     if (this.chipFackeList.length <= 0) {
    //         var chip = cc.instantiate(this.sceneScript.chipPrefab);
    //         var chipComponent = chip.getComponent('Chip');
    //         chip.parent = this.node;
    //         chip.scale = cc.v2(0.5, 0.5);
    //         chip.position = cc.v2(0, this.potX);
    //         chipComponent.activeSelectChip(false);
    //         chipComponent.moneyLabel.node.active = false;
    //         chipComponent = chip.getComponent(cc.Button);
    //         chipComponent.destroy();
    //         this.chipFackeList.push(chip);
    //     }

    //     // this.caculateChip();
    // },

    //==========================================
    caculateChip: function caculateChip() {
        this.destroyChipFacke(false);

        var moneyTemp = this.totallMoneyLong;
        var moneyBetting = this.sceneScript.gameManager.bettingList;
        var tempList = [];
        // moneyBetting.reverse();
        this.countChipList = [];
        //[0,5,3,2]
        for (var i = moneyBetting.length; i > 0; i -= 1) {
            if (moneyTemp >= moneyBetting[i - 1]) {
                var num = Math.floor(moneyTemp / moneyBetting[i - 1]);
                tempList.push(num);
                moneyTemp -= num * moneyBetting[i - 1];
            } else {
                tempList.push(0);
            }
        }
        this.countChipList = tempList.reverse();
        this.setFakeChip();
    },

    setFakeChip: function setFakeChip() {
        var chipList = this.countChipList;
        for (var i = 0; i < chipList.length; i += 1) {
            if (chipList[i] > 0) {
                for (var j = 0; j < chipList[i]; j += 1) {
                    var chip = cc.instantiate(this.sceneScript.chipPrefab);
                    var chipComponent = chip.getComponent('Chip');
                    chip.parent = this.node.getChildByName(i.toString());
                    // chip.parent = this.node;
                    chip.scale = cc.v2(0.5, 0.5);
                    chip.removeComponent('ButtonScaler');
                    chip.removeComponent(cc.Button);
                    switch (i) {
                        case 0:

                            chip.position = cc.v2(0, this.potX0);
                            this.potX0 += 3;
                            break;
                        case 1:
                            chip.position = cc.v2(0, this.potX1);
                            this.potX1 += 3;
                            break;
                        case 2:
                            chip.position = cc.v2(0, this.potX2);
                            this.potX2 += 3;
                            break;
                        case 3:
                            chip.position = cc.v2(0, this.potX3);
                            this.potX3 += 3;
                            break;

                    }

                    chipComponent.activeSelectChip(false);
                    chipComponent.init(this.sceneScript.gameManager.bettingList[i], RouletteConstant.ChipColor.findById(i).NAME);
                    // chipComponent = chip.getComponent(cc.Button);
                    // chipComponent.remove();
                    // chipComponent.destroy();
                    this.chipFackeList.push(chip);
                }
            }
        }
    },
    //==================================================================================

    removePlayerBet: function removePlayerBet(player) {
        delete this.playerBetList[player];
    },

    removeMoneyPot: function removeMoneyPot(username) {
        var moneyTemp = this.playerBetList[username];
        if (Utils.Type.isNumber(moneyTemp)) {
            if (this.totallMoneyLong > moneyTemp) {
                this.totallMoneyLong -= moneyTemp;
            } else {
                this.totallMoneyLong = 0;
            }
        }
        if (AuthUser.username === username) {
            this.myMoneyLong = 0;
        }
        if (this.totallMoneyLong <= 0) {
            this.destroyChipFacke(true);
        }
        this.removePlayerBet(username);
    },

    destroyChipFacke: function destroyChipFacke(isClease) {
        if (this.chipFackeList) {
            for (var i = 0; i < this.chipFackeList.length; i += 1) {
                this.chipFackeList[i].destroy();
            }
            this.chipFackeList = [];
        }
        this.potX = 0;
        if (isClease) {
            this.chipFackeList = [];
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","RouletteConstant":"RouletteConstant","Utils":"Utils"}],"RowInforSanThuong":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'e5f1cBMI91PLIsrUNxuT8h9', 'RowInforSanThuong');
// scripts\components\games\san_thuong\RowInforSanThuong.js

cc.Class({
    'extends': cc.Component,

    properties: {
        gemList: {
            'default': [],
            type: cc.Prefab
        },
        count: 30
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.initDefaultGem();
        this.gemTemp = [];
    },

    initDefaultGem: function initDefaultGem() {
        var index = 0;
        for (var i = 0; i < this.count; i += 1) {
            if (index === 7) {
                index = 0;
            }
            var gem = cc.instantiate(this.gemList[index]);
            this.node.addChild(gem);
            index += 1;
        }
    },

    initGemFinish: function initGemFinish(gemIndex) {
        var gem = cc.instantiate(this.gemList[gemIndex]);
        this.node.addChild(gem);
        gem.setSiblingIndex(0);
        this.gemTemp.push(gem);
    },

    destroyGemTemp: function destroyGemTemp() {
        for (var i = 0; i < this.gemTemp.length; i += 1) {
            this.gemTemp[i].destroy();
        }
        this.gemTemp = [];
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"RowTable":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1c33fFDkI1HSLuNeUMMgigE', 'RowTable');
// scripts\ui\RowTable.js

cc.Class({
    "extends": cc.Component,

    properties: {
        columnLabels: {
            "default": [],
            type: cc.Label
        }
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData() {
        for (var i = 0; i < this.columnLabels.length; i += 1) {
            this.columnLabels[i].string = arguments[i];
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"RulePotSanThuong":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8fcebfhqkxKkqJTPzpGHHql', 'RulePotSanThuong');
// scripts\components\games\san_thuong\RulePotSanThuong.js

cc.Class({
    'extends': cc.Component,

    properties: {
        lblRatio: {
            'default': [],
            type: cc.Label
        }
    },

    // use this for initialization
    onLoad: function onLoad() {},

    setRatio: function setRatio(object) {
        for (var i = 0; i < object.awards.length; i += 1) {
            if (i <= this.lblRatio.length) {
                this.lblRatio[i].string = object.awards[i].number + ' x ' + object.awards[i].ratio;
            }
        }
    }
});

cc._RFpop();
},{}],"RunningMessageStore":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3cc6f9Y/x1NF6YjGPynkFNb', 'RunningMessageStore');
// scripts\components\running_message\RunningMessageStore.js

var EventDispatcher = require('EventDispatcher'),
    CommonConstant = require('CommonConstant'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    TinhNangManager = require('TinhNangManager'),
    Utils = require('Utils'),
    MAX_ITEMS = 25,
    RunningMessageStore;

RunningMessageStore = {
    MESSAGES: [],
    INGAME_MESSAGES: [],

    _add: function _add(msgObj, methodName) {
        if (msgObj) {
            if (msgObj.isIngame) {
                Utils.Array.trimLeft(this.INGAME_MESSAGES, MAX_ITEMS);
                this.INGAME_MESSAGES[methodName](msgObj);
            } else {
                Utils.Array.trimLeft(this.MESSAGES, MAX_ITEMS);
                this.MESSAGES[methodName](msgObj);
            }
        }
    },

    push: function push(msgObj) {
        this._add(msgObj, 'push');
    },

    pushTop: function pushTop(msgObj) {
        this._add(msgObj, 'unshift');
    },

    pop: function pop() {
        var msgObj = this.MESSAGES.shift();
        if (!msgObj) {
            msgObj = this.INGAME_MESSAGES.shift();
        }
        return msgObj;
    },

    clear: function clear() {
        this.MESSAGES = [];
        this.INGAME_MESSAGES = [];
    }
};

EventDispatcher.addEventListener(CommonConstant.PushMessageType.RUNNING.EVENT, function (params) {
    if (params && params.content && TinhNangManager.choPhep('nc')) {
        RunningMessageStore.push({
            content: params.content,
            target: params.target,
            targetId: params.targetId,
            times: params.times > 0 ? params.times : 1,
            isIngame: params.isIngame,
            at: Date.now()
        });
    }
});

EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, function () {
    if (!TinhNangManager.choPhep('nc')) {
        RunningMessageStore.clear();
    }
});

module.exports = RunningMessageStore;

cc._RFpop();
},{"CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","TinhNangManager":"TinhNangManager","Utils":"Utils"}],"RunningMessage":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0a852CTuphMaIy/h6LTroBA', 'RunningMessage');
// scripts\components\running_message\RunningMessage.js

var RunningMessageStore = require('RunningMessageStore'),
    PlatformImplement = require('PlatformImplement'),
    EventDispatcher = require('EventDispatcher'),
    TinhNangManager = require('TinhNangManager'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    UiManager = require('UiManager'),
    Utils = require('Utils'),
    MSG_MOVE_STEP_X = 3,
    MSG_UPDATE_POSITION_INTERVAL = 33,
    VALID_TIME_THRESHOLD = 2 * 60 * 1000,
    // 2 mins
NUMBER_RELATED_COLOR = '#02bbff',
    LINK_COLOR = '#ffed6b';

cc.Class({
    'extends': cc.Component,

    properties: {
        maskNode: cc.Node,
        runningMessageTemplateNode: cc.Node,
        minDistance: 200
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.activeNodes = [];

        EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.onTinhNangNew, this);
    },

    // called every frame, uncomment this function to activate update callback
    update: function update() {
        if (this.activeNodes.length === 0 || this.activeNodes[0].shouldShowMore) {
            var msgObj = RunningMessageStore.pop();
            if (msgObj && Date.now() - msgObj.at <= VALID_TIME_THRESHOLD) {
                this.displayMessage(msgObj);
            }
        }
    },

    onTinhNangNew: function onTinhNangNew() {
        this.node.active = TinhNangManager.choPhep('nc');
    },

    displayMessage: function displayMessage(msgObj) {
        var runningMessageLabelNode = cc.instantiate(this.runningMessageTemplateNode),
            maskNodePositionWS = this.maskNode.convertToWorldSpace(cc.v2(0, 0)),
            maskNodePositionNSToLabelNode,
            fromX,
            deltaX,
            deltaXToShowMore,
            deltaXToDone,
            timeToShowMore,
            timeToDone,
            self = this,
            isLink = false;

        runningMessageLabelNode.parent = this.maskNode;
        runningMessageLabelNode.active = true;
        runningMessageLabelNode.position = cc.v2(0, 0);
        maskNodePositionNSToLabelNode = runningMessageLabelNode.convertToNodeSpace(maskNodePositionWS);
        fromX = maskNodePositionNSToLabelNode.x + this.maskNode.width;
        this.activeNodes.unshift(runningMessageLabelNode);

        switch (msgObj.target) {
            case 'open_web':
                isLink = true;
                runningMessageLabelNode.on(cc.Node.EventType.TOUCH_START, function () {
                    PlatformImplement.openWebUrl(msgObj.targetId);
                });
                break;

            case 'event':
                isLink = true;
                runningMessageLabelNode.on(cc.Node.EventType.TOUCH_START, function () {
                    UiManager.openPopupEvent(msgObj.targetId);
                });
                break;

            case 'webview':
                isLink = true;
                runningMessageLabelNode.on(cc.Node.EventType.TOUCH_START, function () {
                    try {
                        var data = msgObj.targetId.split('\n');
                        UiManager.openWebView(data[0], data[1]);
                    } catch (e) {}
                });
                break;
        }

        runningMessageLabelNode.getComponent(cc.RichText).string = this._decorateMsg(msgObj.content, isLink);
        runningMessageLabelNode.x = fromX;
        deltaX = this.maskNode.width + runningMessageLabelNode.width;
        deltaXToShowMore = runningMessageLabelNode.width + this.minDistance;
        timeToShowMore = deltaXToShowMore / MSG_MOVE_STEP_X * MSG_UPDATE_POSITION_INTERVAL / 1000;
        deltaXToDone = Math.max(deltaX - deltaXToShowMore, 0);
        timeToDone = deltaXToDone / MSG_MOVE_STEP_X * MSG_UPDATE_POSITION_INTERVAL / 1000;
        runningMessageLabelNode.runAction(cc.sequence(cc.moveBy(timeToShowMore, cc.v2(-deltaXToShowMore, 0)), cc.callFunc(function () {
            runningMessageLabelNode.shouldShowMore = true;
        }), cc.moveBy(timeToDone, cc.v2(-deltaXToDone, 0)), cc.callFunc(function () {
            Utils.Array.removeRef(self.activeNodes, runningMessageLabelNode);
            runningMessageLabelNode.destroy();
            runningMessageLabelNode.shouldShowMore = true;
        })));

        msgObj.times -= 1;
        if (msgObj.times > 0) {
            RunningMessageStore.pushTop(msgObj);
        }
    },

    _decorateMsg: function _decorateMsg(msg, isLink) {
        if (Utils.Type.isString(msg)) {
            msg = msg.replace(/(\b|\-)[\w\-.,:]+\b/g, function (match) {
                if (match && /\d/.test(match)) {
                    match = '<color=' + NUMBER_RELATED_COLOR + '><b>' + match + '</b></color>';
                }
                return match;
            });
            msg = '<i>' + msg + '</i>';
            if (isLink) {
                msg = '<color=' + LINK_COLOR + '>' + msg + '</color>';
            }
        }
        return msg;
    }
});

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","PlatformImplement":"PlatformImplement","RunningMessageStore":"RunningMessageStore","TinhNangManager":"TinhNangManager","UiManager":"UiManager","Utils":"Utils"}],"SFS2X":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8e923lOK3ZJiZoCgaziN7W5', 'SFS2X');
// scripts\lib\SFS2X.js

/*
SmartFoxServer 2X HTML5/JavaScript API
(c) gotoAndPlay | All rights reserved
http://www.smartfoxserver.com
*/
var SFS2X = {
    SmartFox: function SmartFox(a) {
        this._majVersion = 1;
        this._minVersion = 2;
        this._subVersion = 0;
        this._socketEngine = new SFS2X.SocketEngine();
        this._eventDispatcher = new SFS2X.EventDispatcher();
        this._lagMonitor = null;
        this._log = SFS2X.Logger;
        this._inited = this._isJoining = !1;
        this._currentZone = null;
        this._clientDetails = "JavaScript";
        this.version = this._majVersion + "." + this._minVersion + "." + this._subVersion;
        this.config = a;
        this.debug = !1;
        null != this.config && this.config.debug && (this.debug = !0);
        this.logger = this._log;
        this.lastJoinedRoom = this.mySelf = this.buddyManager = this.userManager = this.roomManager = this.sessionToken = null;
        this._controllers = {};
        this._initialize();
        this._log.info("SmartFox instance ready!");
    }
},
    SmartFox = SFS2X.SmartFox;
SFS2X.SmartFox.prototype.addEventListener = function (a, b, c) {
    this._eventDispatcher.addEventListener(a, b, c);
};
SFS2X.SmartFox.prototype.removeEventListener = function (a, b) {
    this._eventDispatcher.removeEventListener(a, b);
};
SFS2X.SmartFox.prototype.setClientDetails = function (a, b) {
    this.isConnected() ? this._log.warn("SetClientDetails must be called before the connection is started") : (this._clientDetails = null != a ? a.replace(":", " ") : "", this._clientDetails += ":", this._clientDetails += null != b ? b.replace(":", " ") : "");
};
SFS2X.SmartFox.prototype.connect = function (a, b, c) {
    if (this.isConnected()) this._log.warn("Already connected");else if (this._socketEngine.isConnecting) this._log.warn("A connection attempt is already in progress");else {
        var d = null != this.config && null != this.config.host ? this.config.host : null,
            e = null != this.config && null != this.config.port ? this.config.port : null,
            f = null != this.config && this.config.useSSL;
        null != a && (d = a);
        null != b && (e = b);
        null != c && (f = c);
        null == d || 0 == d.length ? this._log.error("Invalid connection host/address") : "number" != typeof e || 0 > e || 65535 < e ? this._log.error("Invalid TCP port") : ("boolean" != typeof f && (f = !1), this._socketEngine.connect(d, e, f));
    }
};
SFS2X.SmartFox.prototype.disconnect = function () {
    this.isConnected() ? (0 < this._socketEngine.reconnectionSeconds && this.send(new SFS2X.Requests.System.ManualDisconnectionRequest()), setTimeout(function (a) {
        a._handleClientDisconnection(SFS2X.Utils.ClientDisconnectionReason.MANUAL);
    }, 100, this)) : this._log.info("You are not connected");
};
SFS2X.SmartFox.prototype.enableLagMonitor = function (a, b, c) {
    null == this.mySelf ? this._log.warn("Lag Monitoring requires that you are logged in a Zone; please retry after completing the login process") : (null != this._lagMonitor && this._lagMonitor.destroy(), a && (this._lagMonitor = new SFS2X.Utils.LagMonitor(this, b, c), this._lagMonitor.start()));
};
SFS2X.SmartFox.prototype.isConnected = function () {
    return null != this._socketEngine ? this._socketEngine.isConnected : !1;
};
SFS2X.SmartFox.prototype.getMaxMessageSize = function () {
    return null != this._socketEngine ? this._socketEngine._maxMessageSize : 0;
};
SFS2X.SmartFox.prototype.send = function (a) {
    if (this.isConnected()) if (null == a.validate || null == a.execute) this._log.error("An invalid request was passed: " + a), this._log.debug("Object dump:\n" + SFS2X.DebugHelper.getDump(a));else {
        try {
            a.validate(this), a.execute(this);
        } catch (b) {
            if (b instanceof SFS2X.Exceptions.SFSValidationError && null != b.getMessage) {
                a = b.getMessage();
                if (null != b.getErrors()) for (var a = a + ":", c = 0; c < b.getErrors().length; c++) 1 < b.getErrors().length && (a += " " + (c + 1) + ")"), a += " " + b.getErrors()[c];
                this._log.error("Request failed | " + a);
            } else throw b;
            return !1;
        }
        this.debug && (this._log.info("OUTGOING DATA\n" + SFS2X.DebugHelper.getDump(a.getMessage())), this._log.info("OUT > " + SFS2X.Requests.getRequestNameFromId(a._id)));
        this._socketEngine.send(a.getMessage());
        return !0;
    } else this._log.error("You are not connected. Request cannot be sent: " + SFS2X.Requests.getRequestNameFromId(a._id));
};
SFS2X.SmartFox.prototype.getRoomById = function (a) {
    return this.roomManager.getRoomById(a);
};
SFS2X.SmartFox.prototype.getRoomByName = function (a) {
    return this.roomManager.getRoomByName(a);
};
SFS2X.SmartFox.prototype.getRoomList = function () {
    return this.roomManager.getRoomList();
};
SFS2X.SmartFox.prototype.getRoomListFromGroup = function (a) {
    return this.roomManager.getRoomListFromGroup(a);
};
SFS2X.SmartFox.prototype.getJoinedRooms = function () {
    return this.roomManager.getJoinedRooms();
};
SFS2X.SmartFox.prototype._initialize = function () {
    this._inited || (this._socketEngine = new SFS2X.SocketEngine(this), this._socketEngine.addEventListener(SFS2X.SocketEvent.CONNECT, this._onSocketConnect, this), this._socketEngine.addEventListener(SFS2X.SocketEvent.DISCONNECT, this._onSocketDisconnect, this), this._socketEngine.addEventListener(SFS2X.SocketEvent.DATA, this._onSocketData, this), this._socketEngine.addEventListener(SFS2X.SocketEvent.IOERROR, this._onSocketIOError, this), this._controllers[0] = new SFS2X.Controllers.SystemController(this), this._controllers[1] = new SFS2X.Controllers.ExtensionController(this), this._inited = !0, this._reset());
};
SFS2X.SmartFox.prototype._reset = function (a) {
    null != this.buddyManager && this.buddyManager._clearAll();
    this.userManager = new SFS2X.Managers.GlobalUserManager(this);
    this.roomManager = new SFS2X.Managers.RoomManager(this);
    this.buddyManager = new SFS2X.Managers.BuddyManager(this);
    null != this._lagMonitor && this._lagMonitor.destroy();
    this._isJoining = !1;
    this.mySelf = this.lastJoinedRoom = this._currentZone = null;
    a && (this.sessionToken = null);
};
SFS2X.SmartFox.prototype._dispatchEvent = function (a, b) {
    this._eventDispatcher.dispatchEvent(a, b);
};
SFS2X.SmartFox.prototype._onSocketConnect = function (a) {
    a.success ? (a = new SFS2X.Requests.System.HandshakeRequest(this.version, this._clientDetails, a.isReconnection ? this.sessionToken : null), this.send(a)) : this._dispatchEvent(SFS2X.SFSEvent.CONNECTION, {
        success: !1
    });
};
SFS2X.SmartFox.prototype._onSocketDisconnect = function (a) {
    this._dispatchEvent(SFS2X.SFSEvent.CONNECTION_LOST, {
        reason: a.reason
    });
    this._reset(!0);
};
SFS2X.SmartFox.prototype._onSocketData = function (a) {
    this.debug && this._log.info("INCOMING DATA\n" + SFS2X.DebugHelper.getDump(a));
    var b = a[SFS2X.Controllers.CONTROLLER_ID],
        c = a[SFS2X.Controllers.ACTION_ID],
        a = a[SFS2X.Controllers.PARAM_ID];
    null == b ? this._log.error("Message rejected: Controller ID is missing") : null == b ? this._log.error("Message rejected: Action ID missing") : this._controllers[b].handleMessage(a, c);
};
SFS2X.SmartFox.prototype._onSocketIOError = function (a) {
    this._dispatchEvent(SFS2X.SFSEvent.SOCKET_ERROR, {
        message: a
    });
};
SFS2X.SmartFox.prototype._handleHandShake = function (a) {
    var b = a[SFS2X.Controllers.KEY_ERROR_CODE];
    null == b ? (this.sessionToken = a[SFS2X.Requests.System.HandshakeRequest.KEY_SESSION_TOKEN], this._socketEngine._maxMessageSize = a[SFS2X.Requests.System.HandshakeRequest.KEY_MAX_MESSAGE_SIZE], this._socketEngine._isReconnecting ? this._socketEngine._isReconnecting = !1 : this._dispatchEvent(SFS2X.SFSEvent.CONNECTION, {
        success: !0
    })) : (a = {
        success: !1,
        errorMessage: SFS2X.ErrorCodes.getErrorMessage(b, a[SFS2X.Controllers.KEY_ERROR_PARAMS]),
        errorCode: b
    }, this._dispatchEvent(SFS2X.SFSEvent.CONNECTION, a));
};
SFS2X.SmartFox.prototype._handleLogout = function () {
    this._reset(!1);
};
SFS2X.SmartFox.prototype._handleClientDisconnection = function (a) {
    this.isConnected() && this._socketEngine.disconnect(a);
};
var Class = (function () {
    var a = !1,
        b = /xyz/.test(function () {
        xyz;
    }) ? /\b_super\b/ : /.*/;
    var Class = function Class() {};
    Class.extend = function extend(c) {
        function d() {
            !a && this.init && this.init.apply(this, arguments);
        }
        var e = this.prototype;
        a = !0;
        var f = new this();
        a = !1;
        for (var g in c) f[g] = "function" == typeof c[g] && "function" == typeof e[g] && b.test(c[g]) ? (function (a, b) {
            return function () {
                var c = this._super;
                this._super = e[a];
                var d = b.apply(this, arguments);
                this._super = c;
                return d;
            };
        })(g, c[g]) : c[g];
        d.prototype = f;
        d.prototype.constructor = d;
        d.extend = extend;
        return d;
    };
    return Class;
})();
var hexcase = 0,
    b64pad = "";

function hex_md5(a) {
    return rstr2hex(rstr_md5(str2rstr_utf8(a)));
}

function b64_md5(a) {
    return rstr2b64(rstr_md5(str2rstr_utf8(a)));
}

function any_md5(a, b) {
    return rstr2any(rstr_md5(str2rstr_utf8(a)), b);
}

function hex_hmac_md5(a, b) {
    return rstr2hex(rstr_hmac_md5(str2rstr_utf8(a), str2rstr_utf8(b)));
}

function b64_hmac_md5(a, b) {
    return rstr2b64(rstr_hmac_md5(str2rstr_utf8(a), str2rstr_utf8(b)));
}

function any_hmac_md5(a, b, c) {
    return rstr2any(rstr_hmac_md5(str2rstr_utf8(a), str2rstr_utf8(b)), c);
}

function md5_vm_test() {
    return "900150983cd24fb0d6963f7d28e17f72" == hex_md5("abc").toLowerCase();
}

function rstr_md5(a) {
    return binl2rstr(binl_md5(rstr2binl(a), 8 * a.length));
}

function rstr_hmac_md5(a, b) {
    var c = rstr2binl(a);
    16 < c.length && (c = binl_md5(c, 8 * a.length));
    for (var d = Array(16), e = Array(16), f = 0; 16 > f; f++) d[f] = c[f] ^ 909522486, e[f] = c[f] ^ 1549556828;
    c = binl_md5(d.concat(rstr2binl(b)), 512 + 8 * b.length);
    return binl2rstr(binl_md5(e.concat(c), 640));
}

function rstr2hex(a) {
    try {
        hexcase;
    } catch (b) {
        hexcase = 0;
    }
    for (var c = hexcase ? "0123456789ABCDEF" : "0123456789abcdef", d = "", e, f = 0; f < a.length; f++) e = a.charCodeAt(f), d += c.charAt(e >>> 4 & 15) + c.charAt(e & 15);
    return d;
}

function rstr2b64(a) {
    try {
        b64pad;
    } catch (b) {
        b64pad = "";
    }
    for (var c = "", d = a.length, e = 0; e < d; e += 3) for (var f = a.charCodeAt(e) << 16 | (e + 1 < d ? a.charCodeAt(e + 1) << 8 : 0) | (e + 2 < d ? a.charCodeAt(e + 2) : 0), g = 0; 4 > g; g++) c = 8 * e + 6 * g > 8 * a.length ? c + b64pad : c + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f >>> 6 * (3 - g) & 63);
    return c;
}

function rstr2any(a, b) {
    var c = b.length,
        d,
        e,
        f,
        g,
        i,
        j = Array(Math.ceil(a.length / 2));
    for (d = 0; d < j.length; d++) j[d] = a.charCodeAt(2 * d) << 8 | a.charCodeAt(2 * d + 1);
    var k = Math.ceil(8 * a.length / (Math.log(b.length) / Math.log(2))),
        h = Array(k);
    for (e = 0; e < k; e++) {
        i = [];
        for (d = g = 0; d < j.length; d++) if ((g = (g << 16) + j[d], f = Math.floor(g / c), g -= f * c, 0 < i.length || 0 < f)) i[i.length] = f;
        h[e] = g;
        j = i;
    }
    c = "";
    for (d = h.length - 1; 0 <= d; d--) c += b.charAt(h[d]);
    return c;
}

function str2rstr_utf8(a) {
    for (var b = "", c = -1, d, e; ++c < a.length;) d = a.charCodeAt(c), e = c + 1 < a.length ? a.charCodeAt(c + 1) : 0, 55296 <= d && 56319 >= d && 56320 <= e && 57343 >= e && (d = 65536 + ((d & 1023) << 10) + (e & 1023), c++), 127 >= d ? b += String.fromCharCode(d) : 2047 >= d ? b += String.fromCharCode(192 | d >>> 6 & 31, 128 | d & 63) : 65535 >= d ? b += String.fromCharCode(224 | d >>> 12 & 15, 128 | d >>> 6 & 63, 128 | d & 63) : 2097151 >= d && (b += String.fromCharCode(240 | d >>> 18 & 7, 128 | d >>> 12 & 63, 128 | d >>> 6 & 63, 128 | d & 63));
    return b;
}

function str2rstr_utf16le(a) {
    for (var b = "", c = 0; c < a.length; c++) b += String.fromCharCode(a.charCodeAt(c) & 255, a.charCodeAt(c) >>> 8 & 255);
    return b;
}

function str2rstr_utf16be(a) {
    for (var b = "", c = 0; c < a.length; c++) b += String.fromCharCode(a.charCodeAt(c) >>> 8 & 255, a.charCodeAt(c) & 255);
    return b;
}

function rstr2binl(a) {
    for (var b = Array(a.length >> 2), c = 0; c < b.length; c++) b[c] = 0;
    for (c = 0; c < 8 * a.length; c += 8) b[c >> 5] |= (a.charCodeAt(c / 8) & 255) << c % 32;
    return b;
}

function binl2rstr(a) {
    for (var b = "", c = 0; c < 32 * a.length; c += 8) b += String.fromCharCode(a[c >> 5] >>> c % 32 & 255);
    return b;
}

function binl_md5(a, b) {
    a[b >> 5] |= 128 << b % 32;
    a[(b + 64 >>> 9 << 4) + 14] = b;
    for (var c = 1732584193, d = -271733879, e = -1732584194, f = 271733878, g = 0; g < a.length; g += 16) var i = c, j = d, k = e, h = f, c = md5_ff(c, d, e, f, a[g + 0], 7, -680876936), f = md5_ff(f, c, d, e, a[g + 1], 12, -389564586), e = md5_ff(e, f, c, d, a[g + 2], 17, 606105819), d = md5_ff(d, e, f, c, a[g + 3], 22, -1044525330), c = md5_ff(c, d, e, f, a[g + 4], 7, -176418897), f = md5_ff(f, c, d, e, a[g + 5], 12, 1200080426), e = md5_ff(e, f, c, d, a[g + 6], 17, -1473231341), d = md5_ff(d, e, f, c, a[g + 7], 22, -45705983), c = md5_ff(c, d, e, f, a[g + 8], 7, 1770035416), f = md5_ff(f, c, d, e, a[g + 9], 12, -1958414417), e = md5_ff(e, f, c, d, a[g + 10], 17, -42063), d = md5_ff(d, e, f, c, a[g + 11], 22, -1990404162), c = md5_ff(c, d, e, f, a[g + 12], 7, 1804603682), f = md5_ff(f, c, d, e, a[g + 13], 12, -40341101), e = md5_ff(e, f, c, d, a[g + 14], 17, -1502002290), d = md5_ff(d, e, f, c, a[g + 15], 22, 1236535329), c = md5_gg(c, d, e, f, a[g + 1], 5, -165796510), f = md5_gg(f, c, d, e, a[g + 6], 9, -1069501632), e = md5_gg(e, f, c, d, a[g + 11], 14, 643717713), d = md5_gg(d, e, f, c, a[g + 0], 20, -373897302), c = md5_gg(c, d, e, f, a[g + 5], 5, -701558691), f = md5_gg(f, c, d, e, a[g + 10], 9, 38016083), e = md5_gg(e, f, c, d, a[g + 15], 14, -660478335), d = md5_gg(d, e, f, c, a[g + 4], 20, -405537848), c = md5_gg(c, d, e, f, a[g + 9], 5, 568446438), f = md5_gg(f, c, d, e, a[g + 14], 9, -1019803690), e = md5_gg(e, f, c, d, a[g + 3], 14, -187363961), d = md5_gg(d, e, f, c, a[g + 8], 20, 1163531501), c = md5_gg(c, d, e, f, a[g + 13], 5, -1444681467), f = md5_gg(f, c, d, e, a[g + 2], 9, -51403784), e = md5_gg(e, f, c, d, a[g + 7], 14, 1735328473), d = md5_gg(d, e, f, c, a[g + 12], 20, -1926607734), c = md5_hh(c, d, e, f, a[g + 5], 4, -378558), f = md5_hh(f, c, d, e, a[g + 8], 11, -2022574463), e = md5_hh(e, f, c, d, a[g + 11], 16, 1839030562), d = md5_hh(d, e, f, c, a[g + 14], 23, -35309556), c = md5_hh(c, d, e, f, a[g + 1], 4, -1530992060), f = md5_hh(f, c, d, e, a[g + 4], 11, 1272893353), e = md5_hh(e, f, c, d, a[g + 7], 16, -155497632), d = md5_hh(d, e, f, c, a[g + 10], 23, -1094730640), c = md5_hh(c, d, e, f, a[g + 13], 4, 681279174), f = md5_hh(f, c, d, e, a[g + 0], 11, -358537222), e = md5_hh(e, f, c, d, a[g + 3], 16, -722521979), d = md5_hh(d, e, f, c, a[g + 6], 23, 76029189), c = md5_hh(c, d, e, f, a[g + 9], 4, -640364487), f = md5_hh(f, c, d, e, a[g + 12], 11, -421815835), e = md5_hh(e, f, c, d, a[g + 15], 16, 530742520), d = md5_hh(d, e, f, c, a[g + 2], 23, -995338651), c = md5_ii(c, d, e, f, a[g + 0], 6, -198630844), f = md5_ii(f, c, d, e, a[g + 7], 10, 1126891415), e = md5_ii(e, f, c, d, a[g + 14], 15, -1416354905), d = md5_ii(d, e, f, c, a[g + 5], 21, -57434055), c = md5_ii(c, d, e, f, a[g + 12], 6, 1700485571), f = md5_ii(f, c, d, e, a[g + 3], 10, -1894986606), e = md5_ii(e, f, c, d, a[g + 10], 15, -1051523), d = md5_ii(d, e, f, c, a[g + 1], 21, -2054922799), c = md5_ii(c, d, e, f, a[g + 8], 6, 1873313359), f = md5_ii(f, c, d, e, a[g + 15], 10, -30611744), e = md5_ii(e, f, c, d, a[g + 6], 15, -1560198380), d = md5_ii(d, e, f, c, a[g + 13], 21, 1309151649), c = md5_ii(c, d, e, f, a[g + 4], 6, -145523070), f = md5_ii(f, c, d, e, a[g + 11], 10, -1120210379), e = md5_ii(e, f, c, d, a[g + 2], 15, 718787259), d = md5_ii(d, e, f, c, a[g + 9], 21, -343485551), c = safe_add(c, i), d = safe_add(d, j), e = safe_add(e, k), f = safe_add(f, h);
    return [c, d, e, f];
}

function md5_cmn(a, b, c, d, e, f) {
    return safe_add(bit_rol(safe_add(safe_add(b, a), safe_add(d, f)), e), c);
}

function md5_ff(a, b, c, d, e, f, g) {
    return md5_cmn(b & c | ~b & d, a, b, e, f, g);
}

function md5_gg(a, b, c, d, e, f, g) {
    return md5_cmn(b & d | c & ~d, a, b, e, f, g);
}

function md5_hh(a, b, c, d, e, f, g) {
    return md5_cmn(b ^ c ^ d, a, b, e, f, g);
}

function md5_ii(a, b, c, d, e, f, g) {
    return md5_cmn(c ^ (b | ~d), a, b, e, f, g);
}

function safe_add(a, b) {
    var c = (a & 65535) + (b & 65535);
    return (a >> 16) + (b >> 16) + (c >> 16) << 16 | c & 65535;
}

function bit_rol(a, b) {
    return a << b | a >>> 32 - b;
}
SFS2X.Utils = {};
SFS2X.Utils.md5_crypt = function (a, b) {
    "undefined" != typeof VarType && (a = VarType.toStr(a), b = VarType.toStr(b));
    var c = b64pad;
    b64pad = "";
    var d = chrsz;
    chrsz = 8;
    "$1$" == b.substr(0, 3) && (b = b.substr(3));
    var e = b.indexOf("$");
    if (0 > e || 8 < e) e = 8;
    for (var b = b.substr(0, e), f = a + "$1$" + b, g = str_md5(a + b + a), e = a.length; 0 < e; e -= 16) f = 16 <= e ? f + g : f + g.substr(0, e);
    for (e = a.length; 0 != e; e >>= 1) f = 0 != (e & 1) ? f + String.fromCharCode(0) : f + a.charAt(0);
    for (var i = "$1$" + b + "$", g = str_md5(f), e = 0; 1E3 > e; e++) f = "", f = 0 != (e & 1) ? f + a : f + g, 0 != e % 3 && (f += b), 0 != e % 7 && (f += a), f = 0 != (e & 1) ? f + g : f + a, g = str_md5(f);
    g += g.charAt(5);
    for (e = 0; 5 > e; e++) f = g.charCodeAt(e) << 16 | g.charCodeAt(e + 6) << 8 | g.charCodeAt(e + 12), i += md5_to64(f, 4);
    f = g.charCodeAt(11);
    i += md5_to64(f, 2);
    b64pad = c;
    chrsz = d;
    return i;
};
SFS2X.Utils.ClientDisconnectionReason = {
    IDLE: "idle",
    KICK: "kick",
    BAN: "ban",
    MANUAL: "manual",
    UNKNOWN: "unknown"
};
SFS2X.Utils.ClientDisconnectionReason.getReason = function (a) {
    switch (a) {
        case 0:
            return this.IDLE;
        case 1:
            return this.KICK;
        case 2:
            return this.BAN;
        case 3:
            return this.MANUAL;
        case 4:
            return this.UNKNOWN;
    }
};
SFS2X.Utils.ArrayUtil = {};
SFS2X.Utils.ArrayUtil.objToArray = function (a) {
    var b = [],
        c;
    for (c in a) a.hasOwnProperty(c) && b.push(a[c]);
    return b;
};
SFS2X.Utils.ArrayUtil.removeItem = function (a, b) {
    var c = a.indexOf(b);-1 < c && a.splice(c, 1);
};
SFS2X.Utils.HashTable = function (a) {
    this.length = 0;
    this.items = {};
    for (var b in a) a.hasOwnProperty(b) && (this.items[b] = a[b], this.length++);
};
SFS2X.Utils.HashTable.prototype.setItem = function (a, b) {
    var c = void 0;
    this.hasItem(a) ? c = this.items[a] : this.length++;
    this.items[a] = b;
    return c;
};
SFS2X.Utils.HashTable.prototype.getItem = function (a) {
    return this.hasItem(a) ? this.items[a] : void 0;
};
SFS2X.Utils.HashTable.prototype.hasItem = function (a) {
    return this.items.hasOwnProperty(a);
};
SFS2X.Utils.HashTable.prototype.removeItem = function (a) {
    var previous;
    if (this.hasItem(a)) return previous = this.items[a], this.length--, delete this.items[a], previous;
};
SFS2X.Utils.HashTable.prototype.keys = function () {
    var a = [],
        b;
    for (b in this.items) this.hasItem(b) && a.push(b);
    return a;
};
SFS2X.Utils.HashTable.prototype.values = function () {
    var a = [],
        b;
    for (b in this.items) this.hasItem(b) && a.push(this.items[b]);
    return a;
};
SFS2X.Utils.HashTable.prototype.each = function (a) {
    for (var b in this.items) this.hasItem(b) && a(b, this.items[b]);
};
SFS2X.Utils.HashTable.prototype.clear = function () {
    this.items = {};
    this.length = 0;
};
SFS2X.Utils.LagMonitor = function (a, b, c) {
    if (null == b || 1 > b) b = 4;
    if (null == c || 1 > c) c = 10;
    this._sfs = a;
    this._valueQueue = [];
    this._interval = b;
    this._queueSize = c;
    this._thread = null;
    this._lastReqTime = -1;
};
SFS2X.Utils.LagMonitor.prototype.start = function () {
    !this.isRunning() && null != this._sfs && (this._thread = setInterval(this._threadRunner, 1E3 * this._interval, this));
};
SFS2X.Utils.LagMonitor.prototype.stop = function () {
    this.isRunning() && (clearInterval(this._thread), this._thread = null, this._valueQueue = []);
};
SFS2X.Utils.LagMonitor.prototype.destroy = function () {
    this.stop();
    this._sfs = null;
};
SFS2X.Utils.LagMonitor.prototype.isRunning = function () {
    return null != this._thread;
};
SFS2X.Utils.LagMonitor.prototype.getLastPingTime = function () {
    return 0 < this._valueQueue.length ? this._valueQueue[this._valueQueue.length - 1] : 0;
};
SFS2X.Utils.LagMonitor.prototype._threadRunner = function (a) {
    a._lastReqTime = new Date().getTime();
    a._sfs.send(new SFS2X.Requests.System.PingPongRequest());
};
SFS2X.Utils.LagMonitor.prototype._onPingPong = function () {
    var a = new Date().getTime() - this._lastReqTime;
    this._valueQueue.length >= this._queueSize && this._valueQueue.shift();
    this._valueQueue.push(a);
    return this._getAveragePingTime();
};
SFS2X.Utils.LagMonitor.prototype._getAveragePingTime = function () {
    if (0 == this._valueQueue.length) return 0;
    for (var a = 0, b = 0; b < this._valueQueue.length; b++) a += this._valueQueue[b];
    return a / this._valueQueue.length;
};
SFS2X.Utils.BuddyOnlineState = {
    ONLINE: 0,
    OFFLINE: 1,
    LEFT_THE_SERVER: 2
};
SFS2X.Controllers = {};
SFS2X.Controllers.CONTROLLER_ID = "c";
SFS2X.Controllers.ACTION_ID = "a";
SFS2X.Controllers.PARAM_ID = "p";
SFS2X.Controllers.KEY_ERROR_CODE = "ec";
SFS2X.Controllers.KEY_ERROR_PARAMS = "ep";
SFS2X.Controllers.ROOM_PARAM = "r";
SFS2X.Controllers.USER_PARAM = "u";
SFS2X.Controllers.USER_COUNT_PARAM = "uc";
SFS2X.Controllers.SPECT_COUNT_PARAM = "sc";
SFS2X.Controllers.SystemController = function (a) {
    this._sfs = a;
    this._id = 0;
    this._requestHandlers = {};
    this._initRequestHandlers();
    this._log = SFS2X.Logger;
};
SFS2X.Controllers.SystemController.prototype.getId = function () {
    return this._id;
};
SFS2X.Controllers.SystemController.prototype.handleMessage = function (a, b) {
    this._sfs.debug && this._log.info("IN < " + this._getEvtName(b));
    var c = this._requestHandlers[b];
    if (null != c) this[c](a);else this._log.warn("Unknown message id: " + a.id);
};
SFS2X.Controllers.SystemController.prototype._initRequestHandlers = function () {
    this._requestHandlers[SFS2X.Requests.Handshake] = "_fnHandshake";
    this._requestHandlers[SFS2X.Requests.Login] = "_fnLogin";
    this._requestHandlers[SFS2X.Requests.Logout] = "_fnLogout";
    this._requestHandlers[SFS2X.Requests.JoinRoom] = "_fnJoinRoom";
    this._requestHandlers[SFS2X.Requests.CreateRoom] = "_fnCreateRoom";
    this._requestHandlers[SFS2X.Requests.ChangeRoomName] = "_fnChangeRoomName";
    this._requestHandlers[SFS2X.Requests.ChangeRoomPassword] = "_fnChangeRoomPassword";
    this._requestHandlers[SFS2X.Requests.ChangeRoomCapacity] = "_fnChangeRoomCapacity";
    this._requestHandlers[SFS2X.Requests.GenericMessage] = "_fnGenericMessage";
    this._requestHandlers[SFS2X.Requests.SetRoomVariables] = "_fnSetRoomVariables";
    this._requestHandlers[SFS2X.Requests.SetUserVariables] = "_fnSetUserVariables";
    this._requestHandlers[SFS2X.Requests.SubscribeRoomGroup] = "_fnSubscribeRoomGroup";
    this._requestHandlers[SFS2X.Requests.UnsubscribeRoomGroup] = "_fnUnsubscribeRoomGroup";
    this._requestHandlers[SFS2X.Requests.SpectatorToPlayer] = "_fnSpectatorToPlayer";
    this._requestHandlers[SFS2X.Requests.PlayerToSpectator] = "_fnPlayerToSpectator";
    this._requestHandlers[SFS2X.Requests.InitBuddyList] = "_fnInitBuddyList";
    this._requestHandlers[SFS2X.Requests.AddBuddy] = "_fnAddBuddy";
    this._requestHandlers[SFS2X.Requests.RemoveBuddy] = "_fnRemoveBuddy";
    this._requestHandlers[SFS2X.Requests.BlockBuddy] = "_fnBlockBuddy";
    this._requestHandlers[SFS2X.Requests.GoOnline] = "_fnGoOnline";
    this._requestHandlers[SFS2X.Requests.SetBuddyVariables] = "_fnSetBuddyVariables";
    this._requestHandlers[SFS2X.Requests.FindRooms] = "_fnFindRooms";
    this._requestHandlers[SFS2X.Requests.FindUsers] = "_fnFindUsers";
    this._requestHandlers[SFS2X.Requests.InviteUsers] = "_fnInviteUsers";
    this._requestHandlers[SFS2X.Requests.InvitationReply] = "_fnInvitationReply";
    this._requestHandlers[SFS2X.Requests.QuickJoinGame] = "_fnQuickJoinGame";
    this._requestHandlers[SFS2X.Requests.PingPong] = "_fnPingPong";
    this._requestHandlers[SFS2X.Requests.SetUserPosition] = "_fnSetUserPosition";
    this._requestHandlers[1E3] = "_fnUserEnterRoom";
    this._requestHandlers[1001] = "_fnUserCountChange";
    this._requestHandlers[1002] = "_fnUserLost";
    this._requestHandlers[1003] = "_fnRoomLost";
    this._requestHandlers[1004] = "_fnUserExitRoom";
    this._requestHandlers[1005] = "_fnClientDisconnection";
    this._requestHandlers[1007] = "_fnSetMMOItemVariables";
};
SFS2X.Controllers.SystemController.prototype._getEvtName = function (a) {
    return this._requestHandlers[a].substr(3);
};
SFS2X.Controllers.SystemController.prototype._fnHandshake = function (a) {
    this._sfs._handleHandShake(a);
};
SFS2X.Controllers.SystemController.prototype._fnLogin = function (a) {
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        this._populateRoomList(a[SFS2X.Requests.System.LoginRequest.KEY_ROOMLIST]);
        this._sfs.mySelf = new SFS2X.Entities.SFSUser(a[SFS2X.Requests.System.LoginRequest.KEY_ID], a[SFS2X.Requests.System.LoginRequest.KEY_USER_NAME], !0);
        this._sfs.mySelf._setUserManager(this._sfs.userManager);
        this._sfs.mySelf.privilegeId = a[SFS2X.Requests.System.LoginRequest.KEY_PRIVILEGE_ID];
        this._sfs.userManager._addUser(this._sfs.mySelf);
        this._sfs._socketEngine.reconnectionSeconds = a[SFS2X.Requests.System.LoginRequest.KEY_RECONNECTION_SECONDS];
        var b = {};
        b.zone = a[SFS2X.Requests.System.LoginRequest.KEY_ZONE_NAME];
        b.user = this._sfs.mySelf;
        b.data = a[SFS2X.Requests.System.LoginRequest.KEY_PARAMS];
        this._sfs._dispatchEvent(SFS2X.SFSEvent.LOGIN, b);
    } else b = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(b, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), this._sfs._dispatchEvent(SFS2X.SFSEvent.LOGIN_ERROR, {
        errorMessage: a,
        errorCode: b
    });
};
SFS2X.Controllers.SystemController.prototype._fnLogout = function (a) {
    this._sfs._handleLogout();
    var b = {};
    b.zone = a[SFS2X.Requests.System.LogoutRequest.KEY_ZONE_NAME];
    this._sfs._dispatchEvent(SFS2X.SFSEvent.LOGOUT, b);
};
SFS2X.Controllers.SystemController.prototype._fnJoinRoom = function (a) {
    var b = this._sfs.roomManager,
        c = {};
    this._sfs._isJoining = !1;
    var d = a[SFS2X.Controllers.KEY_ERROR_CODE];
    if (null == d) {
        d = a[SFS2X.Requests.System.JoinRoomRequest.KEY_USER_LIST];
        a = SFS2X.Entities.SFSRoom.fromArray(a[SFS2X.Requests.System.JoinRoomRequest.KEY_ROOM]);
        a._setRoomManager(b);
        a = b._replaceRoom(a, b.containsGroup(a.groupId));
        for (b = 0; b < d.length; b++) {
            var e = d[b],
                f = this._getOrCreateUser(e, !0, a);
            f._setPlayerId(e[3], a);
            a._addUser(f);
        }
        a.isJoined = !0;
        this._sfs.lastJoinedRoom = a;
        c.room = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_JOIN, c);
    } else a = SFS2X.ErrorCodes.getErrorMessage(d, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), c.errorMessage = a, c.errorCode = d, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_JOIN_ERROR, c);
};
SFS2X.Controllers.SystemController.prototype._fnCreateRoom = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = this._sfs.roomManager,
            a = SFS2X.Entities.SFSRoom.fromArray(a[SFS2X.Requests.System.CreateRoomRequest.KEY_ROOM]);
        a._setRoomManager = c;
        c._addRoom(a);
        b.room = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_ADD, b);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_CREATION_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnChangeRoomName = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = this._sfs.roomManager.getRoomById(a[SFS2X.Requests.System.ChangeRoomNameRequest.KEY_ROOM]);
        null != c ? (b.oldName = c.name, this._sfs.roomManager._changeRoomName(c, a[SFS2X.Requests.System.ChangeRoomNameRequest.KEY_NAME]), b.room = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_NAME_CHANGE, b)) : this._log.warn("RoomNameChange event, unknown Room id: " + rId);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_NAME_CHANGE_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnChangeRoomPassword = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = this._sfs.roomManager.getRoomById(a[SFS2X.Requests.System.ChangeRoomNameRequest.KEY_ROOM]);
        null != c ? (this._sfs.roomManager._changeRoomPasswordState(c, a[SFS2X.Requests.System.ChangeRoomPasswordStateRequest.KEY_PASS]), b.room = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_PASSWORD_STATE_CHANGE, b)) : this._log.warn("RoomPasswordChange event, unknown Room id: " + rId);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_PASSWORD_STATE_CHANGE_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnChangeRoomCapacity = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = this._sfs.roomManager.getRoomById(a[SFS2X.Requests.System.ChangeRoomNameRequest.KEY_ROOM]);
        null != c ? (this._sfs.roomManager._changeRoomCapacity(c, a[SFS2X.Requests.System.ChangeRoomCapacityRequest.KEY_USER_SIZE], a[SFS2X.Requests.System.ChangeRoomCapacityRequest.KEY_SPEC_SIZE]), b.room = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_CAPACITY_CHANGE, b)) : this._log.warn("RoomPasswordChange event, unknown Room id: " + rId);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_CAPACITY_CHANGE_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnGenericMessage = function (a) {
    switch (a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE_TYPE]) {
        case SFS2X.Requests.GenericMessageType.PUBLIC_MSG:
            this._handlePublicMessage(a);
            break;
        case SFS2X.Requests.GenericMessageType.PRIVATE_MSG:
            this._handlePrivateMessage(a);
            break;
        case SFS2X.Requests.GenericMessageType.BUDDY_MSG:
            this._handleBuddyMessage(a);
            break;
        case SFS2X.Requests.GenericMessageType.MODERATOR_MSG:
            this._handleModMessage(a);
            break;
        case SFS2X.Requests.GenericMessageType.ADMING_MSG:
            this._handleAdminMessage(a);
            break;
        case SFS2X.Requests.GenericMessageType.OBJECT_MSG:
            this._handleObjectMessage(a);
    }
};
SFS2X.Controllers.SystemController.prototype._handlePublicMessage = function (a) {
    var b = {},
        c = a[SFS2X.Requests.System.GenericMessageRequest.KEY_ROOM_ID],
        d = this._sfs.roomManager.getRoomById(c);
    null != d ? (b.room = d, b.sender = this._sfs.userManager.getUserById(a[SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID]), b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE], b.data = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS], this._sfs._dispatchEvent(SFS2X.SFSEvent.PUBLIC_MESSAGE, b)) : this._log.warn("Unexpected, public message target Room doesn't exist; Room id: " + c);
};
SFS2X.Controllers.SystemController.prototype._handlePrivateMessage = function (a) {
    var b = {},
        c = this._sfs.userManager.getUserById(a[SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID]);
    if (null == c) {
        if (null == a[SFS2X.Requests.System.GenericMessageRequest.KEY_SENDER_DATA]) {
            this._log.warn("Unexpected, private message has no sender details");
            return;
        }
        c = SFS2X.Entities.SFSUser.fromArray(a[SFS2X.Requests.System.GenericMessageRequest.KEY_SENDER_DATA]);
    }
    b.sender = c;
    b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE];
    b.data = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS];
    this._sfs._dispatchEvent(SFS2X.SFSEvent.PRIVATE_MESSAGE, b);
};
SFS2X.Controllers.SystemController.prototype._handleBuddyMessage = function (a) {
    var b = {},
        c = a[SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID],
        d = this._sfs.buddyManager.getBuddyById(c);
    b.isItMe = this._sfs.mySelf.id == c;
    b.buddy = d;
    b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE];
    b.data = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS];
    this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_MESSAGE, b);
};
SFS2X.Controllers.SystemController.prototype._handleModMessage = function (a) {
    var b = {};
    b.sender = SFS2X.Entities.SFSUser.fromArray(a[SFS2X.Requests.System.GenericMessageRequest.KEY_SENDER_DATA]);
    b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE];
    b.data = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS];
    this._sfs._dispatchEvent(SFS2X.SFSEvent.MODERATOR_MESSAGE, b);
};
SFS2X.Controllers.SystemController.prototype._handleAdminMessage = function (a) {
    var b = {};
    b.sender = SFS2X.Entities.SFSUser.fromArray(a[SFS2X.Requests.System.GenericMessageRequest.KEY_SENDER_DATA]);
    b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE];
    b.data = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS];
    this._sfs._dispatchEvent(SFS2X.SFSEvent.ADMIN_MESSAGE, b);
};
SFS2X.Controllers.SystemController.prototype._handleObjectMessage = function (a) {
    var b = {};
    b.sender = this._sfs.userManager.getUserById(a[SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID]);
    b.message = a[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS];
    this._sfs._dispatchEvent(SFS2X.SFSEvent.OBJECT_MESSAGE, b);
};
SFS2X.Controllers.SystemController.prototype._fnSetRoomVariables = function (a) {
    var b = a[SFS2X.Requests.System.SetRoomVariablesRequest.KEY_VAR_ROOM],
        c = a[SFS2X.Requests.System.SetRoomVariablesRequest.KEY_VAR_LIST],
        a = this._sfs.roomManager.getRoomById(b),
        d = [];
    if (null != a) {
        for (b = 0; b < c.length; b++) {
            var e = SFS2X.Entities.Variables.SFSRoomVariable.fromArray(c[b]);
            a._setVariable(e);
            d.push(e.name);
        }
        c = {};
        c.changedVars = d;
        c.room = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_VARIABLES_UPDATE, c);
    } else this._log.warn("RoomVariablesUpdate event, unknown Room id: " + b);
};
SFS2X.Controllers.SystemController.prototype._fnSetUserVariables = function (a) {
    var b = a[SFS2X.Requests.System.SetUserVariablesRequest.KEY_USER],
        c = a[SFS2X.Requests.System.SetUserVariablesRequest.KEY_VAR_LIST],
        a = this._sfs.userManager.getUserById(b),
        d = [];
    if (null != a) {
        for (b = 0; b < c.length; b++) {
            var e = SFS2X.Entities.Variables.SFSUserVariable.fromArray(c[b]);
            a._setVariable(e);
            d.push(e.name);
        }
        c = {};
        c.changedVars = d;
        c.user = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_VARIABLES_UPDATE, c);
    } else this._log.warn("UserVariablesUpdate event, unknown User id: " + b);
};
SFS2X.Controllers.SystemController.prototype._fnSubscribeRoomGroup = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.System.SubscribeRoomGroupRequest.KEY_GROUP_ID],
            a = a[SFS2X.Requests.System.SubscribeRoomGroupRequest.KEY_ROOM_LIST];
        this._sfs.roomManager.containsGroup(c) && this._log.warn("Subscribe Group error: Group '" + c + "' already subscribed");
        this._populateRoomList(a);
        b.groupId = c;
        b.newRooms = this._sfs.roomManager.getRoomListFromGroup(c);
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_GROUP_SUBSCRIBE, b);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_GROUP_SUBSCRIBE_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnUnsubscribeRoomGroup = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.System.UnsubscribeRoomGroupRequest.KEY_GROUP_ID];
        this._sfs.roomManager.containsGroup(c) || this._log.warn("Unsubscribe Group error: Group '" + c + "' not found (maybe never subscribed, or the Room Manager doesn't contain Rooms belonging to that Group)");
        this._sfs.roomManager._removeGroup(c);
        b.groupId = c;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_GROUP_UNSUBSCRIBE, b);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_GROUP_UNSUBSCRIBE_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnSpectatorToPlayer = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_ROOM_ID],
            d = a[SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_USER_ID],
            a = a[SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_PLAYER_ID],
            e = this._sfs.userManager.getUserById(d),
            f = this._sfs.roomManager.getRoomById(c);
        null != f ? null != e ? e.isJoinedInRoom(f) ? (e._setPlayerId(a, f), b.room = f, b.user = e, b.playerId = a, this._sfs._dispatchEvent(SFS2X.SFSEvent.SPECTATOR_TO_PLAYER, b)) : this._log.warn("SpectatorToPlayer event, user " + e + " not joined in Room ", f) : this._log.warn("SpectatorToPlayer event, unknown User id: " + d) : this._log.warn("SpectatorToPlayer event, unknown Room id: " + c);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], d = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = d, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.SPECTATOR_TO_PLAYER_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnPlayerToSpectator = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.System.PlayerToSpectatorRequest.KEY_ROOM_ID],
            a = a[SFS2X.Requests.System.PlayerToSpectatorRequest.KEY_USER_ID],
            d = this._sfs.userManager.getUserById(a),
            e = this._sfs.roomManager.getRoomById(c);
        null != e ? null != d ? d.isJoinedInRoom(e) ? (d._setPlayerId(-1, e), b.room = e, b.user = d, this._sfs._dispatchEvent(SFS2X.SFSEvent.PLAYER_TO_SPECTATOR, b)) : this._log.warn("PlayerToSpectator event, user " + d + " not joined in Room ", e) : this._log.warn("PlayerToSpectator event, unknown User id: " + a) : this._log.warn("PlayerToSpectator event, unknown Room id: " + c);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.PLAYER_TO_SPECTATOR_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnFindRooms = function (a) {
    for (var b = {}, a = a[SFS2X.Requests.System.FindRoomsRequest.KEY_FILTERED_ROOMS], c = [], d = 0; d < a.length; d++) {
        var e = SFS2X.Entities.SFSRoom.fromArray(a[d]),
            f = this._sfs.roomManager.getRoomById(e.id);
        null != f && (e.isJoined = f.isJoined);
        c.push(e);
    }
    b.rooms = c;
    this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_FIND_RESULT, b);
};
SFS2X.Controllers.SystemController.prototype._fnFindUsers = function (a) {
    for (var b = {}, a = a[SFS2X.Requests.System.FindUsersRequest.KEY_FILTERED_USERS], c = [], d = this._sfs.mySelf, e = 0; e < a.length; e++) {
        var f = SFS2X.Entities.SFSUser.fromArray(a[e]);
        f.id == d.id && (f = d);
        c.push(f);
    }
    b.users = c;
    this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_FIND_RESULT, b);
};
SFS2X.Controllers.SystemController.prototype._fnInviteUsers = function (a) {
    var b = {},
        c = null,
        c = null != a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER_ID] ? this._sfs.userManager.getUserById(a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER_ID]) : SFS2X.Entities.SFSUser.fromArray(a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER]),
        d = a[SFS2X.Requests.Game.InviteUsersRequest.KEY_INVITATION_ID],
        a = new SFS2X.Entities.Invitation.SFSInvitation(c, this._sfs.mySelf, a[SFS2X.Requests.Game.InviteUsersRequest.KEY_TIME], a[SFS2X.Requests.Game.InviteUsersRequest.KEY_PARAMS]);
    a.id = d;
    b.invitation = a;
    this._sfs._dispatchEvent(SFS2X.SFSEvent.INVITATION, b);
};
SFS2X.Controllers.SystemController.prototype._fnInvitationReply = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = null,
            c = null != a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER_ID] ? this._sfs.userManager.getUserById(a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER_ID]) : SFS2X.Entities.SFSUser.fromArray(a[SFS2X.Requests.Game.InviteUsersRequest.KEY_USER]),
            d = a[SFS2X.Requests.Game.InviteUsersRequest.KEY_REPLY_ID],
            a = a[SFS2X.Requests.Game.InviteUsersRequest.KEY_PARAMS];
        b.invitee = c;
        b.reply = d;
        b.data = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.INVITATION_REPLY, b);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSEvent.INVITATION_REPLY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnQuickJoinGame = function (a) {
    if (null != a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var b = a[SFS2X.Controllers.KEY_ERROR_CODE],
            a = SFS2X.ErrorCodes.getErrorMessage(b, a[SFS2X.Controllers.KEY_ERROR_PARAMS]),
            c = {};
        c.errorMessage = a;
        c.errorCode = b;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_JOIN_ERROR, c);
    }
};
SFS2X.Controllers.SystemController.prototype._fnPingPong = function () {
    var a = this._sfs._lagMonitor._onPingPong(),
        b = {};
    b.lagValue = a;
    this._sfs._dispatchEvent(SFS2X.SFSEvent.PING_PONG, b);
};
SFS2X.Controllers.SystemController.prototype._fnSetUserPosition = function (a) {
    var b = {},
        c = this._sfs.roomManager.getRoomById(a[SFS2X.Requests.MMO.SetUserPositionRequest.KEY_ROOM]),
        d = a[SFS2X.Requests.MMO.SetUserPositionRequest.KEY_MINUS_USER_LIST],
        e = a[SFS2X.Requests.MMO.SetUserPositionRequest.KEY_PLUS_USER_LIST],
        f = a[SFS2X.Requests.MMO.SetUserPositionRequest.KEY_MINUS_ITEM_LIST],
        a = a[SFS2X.Requests.MMO.SetUserPositionRequest.KEY_PLUS_ITEM_LIST],
        g = [],
        i = [],
        j = [],
        k = [],
        h = 0;
    if (null != d) for (h = 0; h < d.length; h++) {
        var l = c.getUserById(d[h]);
        null != l && (c._removeUser(l), i.push(l));
    }
    if (null != e) for (h = 0; h < e.length; h++) l = e[h], d = this._getOrCreateUser(l, !0, c), g.push(d), c._addUser(d), l = l[5], null != l && (d.aoiEntryPoint = SFS2X.Entities.Data.Vec3D.fromArray(l));
    if (null != f) for (h = 0; h < f.length; h++) e = c.getMMOItem(f[h]), null != e && (c._removeItem(e), k.push(e));
    if (null != a) for (h = 0; h < a.length; h++) e = a[h], f = SFS2X.Entities.MMOItem.fromArray(e), j.push(f), c._addMMOItem(f), e = e[2], null != e && (f.aoiEntryPoint = SFS2X.Entities.Data.Vec3D.fromArray(e));
    b.addedItems = j;
    b.removedItems = k;
    b.removedUsers = i;
    b.addedUsers = g;
    b.room = c;
    this._sfs._dispatchEvent(SFS2X.SFSEvent.PROXIMITY_LIST_UPDATE, b);
};
SFS2X.Controllers.SystemController.prototype._fnSetMMOItemVariables = function (a) {
    var b = {},
        c = this._sfs.roomManager.getRoomById(a[SFS2X.Requests.MMO.SetMMOItemVariables.KEY_ROOM_ID]),
        d = a[SFS2X.Requests.MMO.SetMMOItemVariables.KEY_ITEM_ID],
        a = a[SFS2X.Requests.MMO.SetMMOItemVariables.KEY_VAR_LIST],
        e = [];
    if (null != c && (d = c.getMMOItem(d), null != d)) {
        for (var f = 0; f < a.length; f++) {
            var g = SFS2X.Entities.Variables.MMOItemVariable.fromArray(a[f]);
            d._setVariable(g);
            e.push(g.name);
        }
        b.changedVars = e;
        b.mmoItem = d;
        b.room = c;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.MMOITEM_VARIABLES_UPDATE, b);
    }
};
SFS2X.Controllers.SystemController.prototype._fnUserEnterRoom = function (a) {
    var b = this._sfs.roomManager.getRoomById(a[SFS2X.Controllers.ROOM_PARAM]);
    if (null != b) {
        a = this._getOrCreateUser(a[SFS2X.Controllers.USER_PARAM], !0, b);
        b._addUser(a);
        var c = {};
        c.user = a;
        c.room = b;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_ENTER_ROOM, c);
    }
};
SFS2X.Controllers.SystemController.prototype._fnUserCountChange = function (a) {
    var b = this._sfs.roomManager.getRoomById(a[SFS2X.Controllers.ROOM_PARAM]);
    if (null != b) {
        var c = a[SFS2X.Controllers.USER_COUNT_PARAM],
            d = 0;
        null != a.sc && (d = a[SFS2X.Controllers.SPECT_COUNT_PARAM]);
        b._userCount = c;
        b._specCount = d;
        a = {};
        a.room = b;
        a.uCount = c;
        a.sCount = d;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_COUNT_CHANGE, a);
    }
};
SFS2X.Controllers.SystemController.prototype._fnUserLost = function (a) {
    a = this._sfs.userManager.getUserById(a[SFS2X.Controllers.USER_PARAM]);
    if (null != a) {
        var b = this._sfs.roomManager.getUserRooms(a);
        this._sfs.roomManager._removeUser(a);
        this._sfs.userManager._removeUser(a);
        for (var c = 0; c < b.length; c++) {
            var d = {};
            d.user = a;
            d.room = b[c];
            this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_EXIT_ROOM, d);
        }
    }
};
SFS2X.Controllers.SystemController.prototype._fnRoomLost = function (a) {
    var a = this._sfs.roomManager.getRoomById(a[SFS2X.Controllers.ROOM_PARAM]),
        b = this._sfs.userManager;
    if (null != a) {
        this._sfs.roomManager._removeRoom(a);
        for (var c = a.getUserList(), d = 0; d < c.length; d++) b._removeUser(c[d]);
        b = {};
        b.room = a;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.ROOM_REMOVE, b);
    }
};
SFS2X.Controllers.SystemController.prototype._fnUserExitRoom = function (a) {
    var b = this._sfs.roomManager.getRoomById(a[SFS2X.Controllers.ROOM_PARAM]),
        a = this._sfs.userManager.getUserById(a[SFS2X.Controllers.USER_PARAM]);
    if (null != b && null != a) {
        b._removeUser(a);
        this._sfs.userManager._removeUser(a);
        a.isItMe && b.isJoined && (b.isJoined = !1, 0 == this._sfs.roomManager.getJoinedRooms().length && (this._sfs.lastJoinedRoom = null), b._isManaged || this._sfs.roomManager._removeRoom(b));
        var c = {};
        c.user = a;
        c.room = b;
        this._sfs._dispatchEvent(SFS2X.SFSEvent.USER_EXIT_ROOM, c);
    } else this._log.debug("Failed to handle UserExit event. Room: " + b + ", User: " + a);
};
SFS2X.Controllers.SystemController.prototype._fnClientDisconnection = function (a) {
    this._sfs._handleClientDisconnection(SFS2X.Utils.ClientDisconnectionReason.getReason(a.dr));
};
SFS2X.Controllers.SystemController.prototype._fnInitBuddyList = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_BLIST],
            d = a[SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_MY_VARS],
            e = a[SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_BUDDY_STATES];
        this._sfs.buddyManager._clearAll();
        for (a = 0; a < c.length; a++) {
            var f = SFS2X.Entities.SFSBuddy.fromArray(c[a]);
            this._sfs.buddyManager._addBuddy(f);
        }
        null != e && this._sfs.buddyManager._setBuddyStates(e);
        c = [];
        for (a = 0; a < d.length; a++) e = SFS2X.Entities.Variables.SFSBuddyVariable.fromArray(d[a]), c.push(e);
        this._sfs.buddyManager._setMyVariables(c);
        this._sfs.buddyManager._setInited();
        b.buddyList = this._sfs.buddyManager.getBuddyList();
        b.myVariables = this._sfs.buddyManager.getMyVariables();
        this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_LIST_INIT, b);
    } else d = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(d, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = d, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnAddBuddy = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = SFS2X.Entities.SFSBuddy.fromArray(a[SFS2X.Requests.BuddyList.AddBuddyRequest.KEY_BUDDY_NAME]);
        this._sfs.buddyManager._addBuddy(c);
        b.buddy = c;
        this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ADD, b);
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnRemoveBuddy = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.BuddyList.RemoveBuddyRequest.KEY_BUDDY_NAME],
            a = this._sfs.buddyManager._removeBuddyByName(c);
        null != a ? (b.buddy = a, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_REMOVE, b)) : this._log.warn("Unexpected: buddy removal failed, can't find " + c + " in local buddy list");
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnBlockBuddy = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.BuddyList.BlockBuddyRequest.KEY_BUDDY_NAME],
            d = this._sfs.buddyManager.getBuddyByName(c);
        null != d ? (d.blocked = a[SFS2X.Requests.BuddyList.BlockBuddyRequest.KEY_BUDDY_BLOCK_STATE], b.buddy = d, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_BLOCK, b)) : this._log.warn("Unexpected: buddy blocking/unblocking failed, can't find " + c + " in local buddy list");
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnGoOnline = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        var c = a[SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_BUDDY_NAME],
            d = this._sfs.buddyManager.getBuddyByName(c),
            e = c == this._sfs.mySelf.name,
            f = a[SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_ONLINE],
            g = f == SFS2X.Utils.BuddyOnlineState.ONLINE,
            i = !0;
        if (e) this._sfs.buddyManager.getMyOnlineState() != g && (this._log.warn("Unexpected: myOnlineState is not in synch with the server; resynching to: " + g), this._sfs.buddyManager._setMyOnlineState(g));else if (null != d) d.id = a[SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_BUDDY_ID], d._setVariable(new SFS2X.Entities.Variables.SFSBuddyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_ONLINE, g)), f == SFS2X.Utils.BuddyOnlineState.LEFT_THE_SERVER && d._clearVolatileVariables(), i = this._sfs.buddyManager.getMyOnlineState();else {
            this._log.warn("Unexpected:  buddy '" + c + "' not found in local Buddy List when trying to set his online state");
            return;
        }
        i && (b.buddy = d, b.isItMe = e, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ONLINE_STATE_CHANGE, b));
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._fnSetBuddyVariables = function (a) {
    var b = {};
    if (null == a[SFS2X.Controllers.KEY_ERROR_CODE]) {
        for (var c = a[SFS2X.Requests.BuddyList.SetBuddyVariablesRequest.KEY_BUDDY_NAME], a = a[SFS2X.Requests.BuddyList.SetBuddyVariablesRequest.KEY_BUDDY_VARS], d = this._sfs.buddyManager.getBuddyByName(c), e = c == this._sfs.mySelf.name, f = [], g = [], i = !0, j = 0; j < a.length; j++) {
            var k = SFS2X.Entities.Variables.SFSBuddyVariable.fromArray(a[j]);
            g.push(k);
            f.push(k.name);
        }
        if (e) this._sfs.buddyManager._setMyVariables(g);else if (null != d) d._setVariables(g), i = sfs.buddyManager.getMyOnlineState();else {
            this._log.warn("Unexpected:  buddy '" + c + "' not found in local Buddy List when trying to set his Buddy Variables");
            return;
        }
        i && (b.buddy = d, b.isItMe = e, b.changedVars = f, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_VARIABLES_UPDATE, b));
    } else c = a[SFS2X.Controllers.KEY_ERROR_CODE], a = SFS2X.ErrorCodes.getErrorMessage(c, a[SFS2X.Controllers.KEY_ERROR_PARAMS]), b.errorMessage = a, b.errorCode = c, this._sfs._dispatchEvent(SFS2X.SFSBuddyEvent.BUDDY_ERROR, b);
};
SFS2X.Controllers.SystemController.prototype._populateRoomList = function (a) {
    for (var b = this._sfs.roomManager, c = 0; c < a.length; c++) {
        var d = SFS2X.Entities.SFSRoom.fromArray(a[c]);
        b._replaceRoom(d);
    }
};
SFS2X.Controllers.SystemController.prototype._getOrCreateUser = function (a, b, c) {
    null == b && (b = !1);
    var d = this._sfs.userManager.getUserById(a[0]);
    if (null == d) d = SFS2X.Entities.SFSUser.fromArray(a, c), d._setUserManager(this._sfs.userManager);else if (null != c) {
        d._setPlayerId(a[3], c);
        a = a[4];
        for (c = 0; c < a.length; c++) d._setVariable(SFS2X.Entities.Variables.SFSUserVariable.fromArray(a[c]));
    }
    b && this._sfs.userManager._addUser(d);
    return d;
};
SFS2X.Controllers.ExtensionController = function (a) {
    this.KEY_CMD = "c";
    this.KEY_PARAMS = "p";
    this.KEY_ROOM = "r";
    this._sfs = a;
    this._id = 1;
    this._log = SFS2X.Logger;
};
SFS2X.Controllers.ExtensionController.prototype.getId = function () {
    return this._id;
};
SFS2X.Controllers.ExtensionController.prototype.handleMessage = function (a) {
    this._sfs.debug && this._log.info("IN < ExtensionResponse");
    var b = {};
    b.cmd = a[this.KEY_CMD];
    b.params = a[this.KEY_PARAMS];
    null != a[this.KEY_ROOM] && (b.sourceRoom = a[this.KEY_ROOM]);
    this._sfs._dispatchEvent(SFS2X.SFSEvent.EXTENSION_RESPONSE, b);
};
SFS2X.DebugHelper = {};
SFS2X.DebugHelper.getDump = function (a) {
    return void 0 == a ? "<Null>" : a instanceof Object ? this._dumpObject(a) : "<Not An Object>";
};
SFS2X.DebugHelper._dumpObject = function (a) {
    function b(a, c, f) {
        var g = null;
        SFS2X.DebugHelper._getTabs(f);
        for (var i in a) {
            var j = a[i];
            if (null == j) g = "Null";else {
                var k = j.constructor,
                    h = void 0;
                k === Array || k === Object ? (g = null, h = k === Array ? "[Array]" : "[Object]", b(j, c, f + 1)) : g = j.constructor === Number ? "Num" : j.constructor === Boolean ? "Bool" : j.constructor === String ? "Str" : "Unsupported";
            }
            c.push(SFS2X.DebugHelper._getTabs(f) + i + ": " + (void 0 == h ? j : h) + (void 0 == g ? "" : " (" + g + ")"));
        }
    }
    var c = [];
    b(a, c, 0);
    return SFS2X.DebugHelper._prettyPrint(c);
};
SFS2X.DebugHelper._getTabs = function (a) {
    if (0 >= a) return "";
    if (1 == a) return "\t";
    for (var b = "", c = 0; c < a; c++) b += "\t";
    return b;
};
SFS2X.DebugHelper._prettyPrint = function (a) {
    for (var b = "", c = a.length - 1; -1 < c; c--) b += a[c] + "\n";
    return b;
};
SFS2X.Entities = {};
SFS2X.Entities.Data = {};
SFS2X.Entities.Variables = {};
SFS2X.Entities.Match = {};
SFS2X.Entities.Invitation = {};
SFS2X.Entities.SFSRoom = Class.extend({
    init: function init(a, b, c) {
        this.id = a;
        this.name = b;
        this.groupId = null != c ? c : "default";
        this.isPasswordProtected = this.isJoined = this.isHidden = this.isGame = !1;
        this._specCount = this._userCount = this.maxSpectators = this.maxUsers = 0;
        this._isManaged = !0;
        this.variables = {};
        this.properties = {};
        this._userManager = new SFS2X.Managers.UserManager();
        this._roomManager = null;
    },
    toString: function toString() {
        return "[Room: " + this.name + ", Id: " + this.id + ", Group id: " + this.groupId + "]";
    },
    getUserCount: function getUserCount() {
        return this.isJoined ? this.isGame ? this.getPlayerList().length : this._userManager.getUserCount() : this._userCount;
    },
    getSpectatorCount: function getSpectatorCount() {
        return !this.isGame ? 0 : this.isJoined ? this.getSpectatorList().length : this._specCount;
    },
    getCapacity: function getCapacity() {
        return this.maxUsers + this.maxSpectators;
    },
    getUserByName: function getUserByName(a) {
        return this._userManager.getUserByName(a);
    },
    getUserById: function getUserById(a) {
        return this._userManager.getUserById(a);
    },
    containsUser: function containsUser(a) {
        return this._userManager.containsUser(a);
    },
    getUserList: function getUserList() {
        return this._userManager.getUserList();
    },
    getPlayerList: function getPlayerList() {
        for (var a = [], b = this._userManager.getUserList(), c = 0; c < b.length; c++) {
            var d = b[c];
            d.isPlayerInRoom(this) && a.push(d);
        }
        return a;
    },
    getSpectatorList: function getSpectatorList() {
        for (var a = [], b = this._userManager.getUserList(), c = 0; c < b.length; c++) {
            var d = b[c];
            d.isSpectatorInRoom(this) && a.push(d);
        }
        return a;
    },
    getVariable: function getVariable(a) {
        return this.variables[a];
    },
    containsVariable: function containsVariable(a) {
        return null != this.variables[a];
    },
    getVariables: function getVariables() {
        return SFS2X.Utils.ArrayUtil.objToArray(this.variables);
    },
    getRoomManager: function getRoomManager() {
        return this._roomManager;
    },
    _addUser: function _addUser(a) {
        this._userManager._addUser(a);
    },
    _removeUser: function _removeUser(a) {
        this._userManager._removeUser(a);
    },
    _setVariables: function _setVariables(a) {
        for (var b = 0; b < a.length; b++) this._setVariable(a[b]);
    },
    _setVariable: function _setVariable(a) {
        a.isNull() ? delete this.variables[a.name] : this.variables[a.name] = a;
    },
    _setRoomManager: function _setRoomManager(a) {
        if (null != this._roomManager) throw new SFS2X.Exceptions.SFSError("Room Manager already assigned to Room " + this.toString());
        this._roomManager = a;
    },
    _merge: function _merge(a) {
        this.variables = [];
        for (var b in a.variables) this.variables[b] = a.variables[b];
        this._userManager._clearAll();
        a = a.getUserList();
        for (b = 0; b < a.length; b++) this._userManager._addUser(a[b]);
    }
});
SFS2X.Entities.SFSRoom.fromArray = function (a) {
    var b = 14 == a.length,
        c = null,
        c = b ? new SFS2X.Entities.MMORoom(a[0], a[1], a[2]) : new SFS2X.Entities.SFSRoom(a[0], a[1], a[2]);
    c.isGame = a[3];
    c.isHidden = a[4];
    c.isPasswordProtected = a[5];
    c._userCount = a[6];
    c.maxUsers = a[7];
    var d = a[8];
    if (null != d) for (var e = 0; e < d.length; e++) {
        var f = SFS2X.Entities.Variables.SFSRoomVariable.fromArray(d[e]);
        c._setVariable(f);
    }
    c.isGame && (c._specCount = a[9], c.maxSpectators = a[10]);
    b && (c.defaultAOI = SFS2X.Entities.Data.Vec3D.fromArray(a[11]), null != a[13] && (c.lowerMapLimit = SFS2X.Entities.Data.Vec3D.fromArray(a[12]), c.higherMapLimit = SFS2X.Entities.Data.Vec3D.fromArray(a[13])));
    return c;
};
SFS2X.Entities.MMORoom = SFS2X.Entities.SFSRoom.extend({
    init: function init(a, b, c) {
        this._super(a, b, c);
        this.higherMapLimit = this.lowerMapLimit = this.defaultAOI = null;
        this._itemsById = {};
    },
    getMMOItem: function getMMOItem(a) {
        return this._itemsById[a];
    },
    getMMOItems: function getMMOItems() {
        return SFS2X.Utils.ArrayUtil.objToArray(this._itemsById);
    },
    _addMMOItem: function _addMMOItem(a) {
        this._itemsById[a.id] = a;
    },
    _removeItem: function _removeItem(a) {
        delete this._itemsById[a];
    }
});
SFS2X.Entities.SFSUser = function (a, b, c) {
    this.id = a;
    this.name = b;
    this.isItMe = null != c ? c : !1;
    this.privilegeId = 0;
    this.properties = {};
    this.aoiEntryPoint = null;
    this.variables = {};
    this._playerIdByRoomId = {};
    this._userManager = null;
};
SFS2X.Entities.SFSUser.fromArray = function (a, b) {
    var c = new SFS2X.Entities.SFSUser(a[0], a[1]);
    c.privilegeId = a[2];
    null != b && c._setPlayerId(a[3], b);
    var d = a[4];
    if (null != d) for (var e = 0; e < d.length; e++) {
        var f = SFS2X.Entities.Variables.SFSUserVariable.fromArray(d[e]);
        c._setVariable(f);
    }
    return c;
};
SFS2X.Entities.SFSUser.prototype.toString = function () {
    return "[User: " + this.name + ", Id: " + this.id + ", Is me: " + this.isItMe + "]";
};
SFS2X.Entities.SFSUser.prototype.isJoinedInRoom = function (a) {
    return a.containsUser(this);
};
SFS2X.Entities.SFSUser.prototype.isGuest = function () {
    return this.privilegeId == SFS2X.Entities.UserPrivileges.GUEST;
};
SFS2X.Entities.SFSUser.prototype.isStandardUser = function () {
    return this.privilegeId == SFS2X.Entities.UserPrivileges.STANDARD;
};
SFS2X.Entities.SFSUser.prototype.isModerator = function () {
    return this.privilegeId == SFS2X.Entities.UserPrivileges.MODERATOR;
};
SFS2X.Entities.SFSUser.prototype.isAdmin = function () {
    return this.privilegeId == SFS2X.Entities.UserPrivileges.ADMINISTRATOR;
};
SFS2X.Entities.SFSUser.prototype.isPlayer = function () {
    return this.isPlayerInRoom(this._userManager._sfs.lastJoinedRoom);
};
SFS2X.Entities.SFSUser.prototype.isSpectator = function () {
    return this.isSpectatorInRoom(this._userManager._sfs.lastJoinedRoom);
};
SFS2X.Entities.SFSUser.prototype.getPlayerId = function (a) {
    var b = 0;
    null != this._playerIdByRoomId[a.id] && (b = this._playerIdByRoomId[a.id]);
    return b;
};
SFS2X.Entities.SFSUser.prototype.isPlayerInRoom = function (a) {
    return null != a && a.isGame ? 0 < this._playerIdByRoomId[a.id] : !1;
};
SFS2X.Entities.SFSUser.prototype.isSpectatorInRoom = function (a) {
    return null != a && a.isGame ? 0 > this._playerIdByRoomId[a.id] : !1;
};
SFS2X.Entities.SFSUser.prototype.getVariable = function (a) {
    return this.variables[a];
};
SFS2X.Entities.SFSUser.prototype.containsVariable = function (a) {
    return null != this.variables[a];
};
SFS2X.Entities.SFSUser.prototype.getVariables = function () {
    return SFS2X.Utils.ArrayUtil.objToArray(this.variables);
};
SFS2X.Entities.SFSUser.prototype.getUserManager = function () {
    return this._userManager;
};
SFS2X.Entities.SFSUser.prototype._setPlayerId = function (a, b) {
    this._playerIdByRoomId[b.id] = a;
};
SFS2X.Entities.SFSUser.prototype._removePlayerId = function (a) {
    delete this._playerIdByRoomId[a.id];
};
SFS2X.Entities.SFSUser.prototype._setVariables = function (a) {
    for (var b = 0; b < a.length; b++) this._setVariable(a[b]);
};
SFS2X.Entities.SFSUser.prototype._setVariable = function (a) {
    a.isNull() ? delete this.variables[a.name] : this.variables[a.name] = a;
};
SFS2X.Entities.SFSUser.prototype._setUserManager = function (a) {
    if (null != this._userManager) throw new SFS2X.Exceptions.SFSError("User Manager already assigned to user " + this.toString());
    this._userManager = a;
};
SFS2X.Entities.SFSBuddy = function (a, b, c, d) {
    this.id = a;
    this.name = b;
    this.blocked = null != c ? c : !1;
    this.temp = null != d ? d : !1;
    this.variables = {};
};
SFS2X.Entities.SFSBuddy.fromArray = function (a) {
    for (var b = new SFS2X.Entities.SFSBuddy(a[0], a[1], a[2], 4 < a.length ? a[4] : !1), a = a[3], c = 0; c < a.length; c++) {
        var d = SFS2X.Entities.Variables.SFSBuddyVariable.fromArray(a[c]);
        b._setVariable(d);
    }
    return b;
};
SFS2X.Entities.SFSBuddy.prototype.toString = function () {
    return "[Buddy: " + this.name + ", Id: " + this.id + "]";
};
SFS2X.Entities.SFSBuddy.prototype.isBlocked = function () {
    return this.blocked;
};
SFS2X.Entities.SFSBuddy.prototype.isTemp = function () {
    return this.temp;
};
SFS2X.Entities.SFSBuddy.prototype.isOnline = function () {
    var a = !0,
        b = SFS2X.Entities.Variables.ReservedBuddyVariables.BV_ONLINE;
    this.containsVariable(b) && (a = this.getVariable(b).value);
    return a && -1 < this.id;
};
SFS2X.Entities.SFSBuddy.prototype.getState = function () {
    var a = SFS2X.Entities.Variables.ReservedBuddyVariables.BV_STATE;
    return this.containsVariable(a) ? this.getVariable(a).value : null;
};
SFS2X.Entities.SFSBuddy.prototype.getNickName = function () {
    var a = SFS2X.Entities.Variables.ReservedBuddyVariables.BV_NICKNAME;
    return this.containsVariable(a) ? this.getVariable(a).value : null;
};
SFS2X.Entities.SFSBuddy.prototype.getVariable = function (a) {
    return this.variables[a];
};
SFS2X.Entities.SFSBuddy.prototype.containsVariable = function (a) {
    return null != this.variables[a];
};
SFS2X.Entities.SFSBuddy.prototype.getVariables = function () {
    return SFS2X.Utils.ArrayUtil.objToArray(this.variables);
};
SFS2X.Entities.SFSBuddy.prototype.getOfflineVariables = function () {
    var a = [],
        b;
    for (b in this.variables) {
        var c = this.variables[b];
        c.name.charAt(0) == SFS2X.Entities.Variables.SFSBuddyVariable.OFFLINE_PREFIX && a.push(c);
    }
    return a;
};
SFS2X.Entities.SFSBuddy.prototype.getOnlineVariables = function () {
    var a = [],
        b;
    for (b in this.variables) {
        var c = this.variables[b];
        c.name.charAt(0) != SFS2X.Entities.Variables.SFSBuddyVariable.OFFLINE_PREFIX && a.push(c);
    }
    return a;
};
SFS2X.Entities.SFSBuddy.prototype._setVariables = function (a) {
    for (var b = 0; b < a.length; b++) this._setVariable(a[b]);
};
SFS2X.Entities.SFSBuddy.prototype._setVariable = function (a) {
    a.isNull() ? this._removeVariable(a.name) : this.variables[a.name] = a;
};
SFS2X.Entities.SFSBuddy.prototype._removeVariable = function (a) {
    delete this.variables[a];
};
SFS2X.Entities.SFSBuddy.prototype._clearVolatileVariables = function () {
    for (var a in this.variables) {
        var b = this.variables[a];
        b.name.charAt(0) != SFS2X.Entities.Variables.SFSBuddyVariable.OFFLINE_PREFIX && this._removeVariable(b.name);
    }
};
SFS2X.Entities.MMOItem = function (a) {
    this.id = a;
    this.aoiEntryPoint = null;
    this.variables = {};
};
SFS2X.Entities.MMOItem.fromArray = function (a) {
    var b = new SFS2X.Entities.MMOItem(a[0]),
        a = a[1];
    if (null != a) for (var c = 0; c < a.length; c++) {
        var d = SFS2X.Entities.Variables.MMOItemVariable.fromArray(a[c]);
        b._setVariable(d);
    }
    return b;
};
SFS2X.Entities.MMOItem.prototype.toString = function () {
    return "[Item: " + this.id + "]";
};
SFS2X.Entities.MMOItem.prototype.getVariable = function (a) {
    return this.variables[a];
};
SFS2X.Entities.MMOItem.prototype.containsVariable = function (a) {
    return null != this.variables[a];
};
SFS2X.Entities.MMOItem.prototype.getVariables = function () {
    return SFS2X.Utils.ArrayUtil.objToArray(this.variables);
};
SFS2X.Entities.MMOItem.prototype._setVariables = function (a) {
    for (var b = 0; b < a.length; b++) this._setVariable(a[b]);
};
SFS2X.Entities.MMOItem.prototype._setVariable = function (a) {
    null != a && (a.isNull() ? delete this.variables[a.name] : this.variables[a.name] = a);
};
SFS2X.Entities.Variables.SFSUserVariable = Class.extend({
    init: function init(a, b, c) {
        this.name = a;
        this.value = b;
        this._setType(c);
    },
    toString: function toString() {
        return "[UserVar: " + this.name + ", Type: " + this.type + ", Value: " + this.value + "]";
    },
    toArray: function toArray() {
        return [this.name, SFS2X.Entities.Variables.VariableType.getTypeIdFromName(this.type), this.value];
    },
    isNull: function isNull() {
        return SFS2X.Entities.Variables.VariableType.getTypeIdFromName(this.type) == SFS2X.Entities.Variables.VariableType.NULL;
    },
    _setType: function _setType(a) {
        null == a && (a = -1);-1 < a ? this.type = this.getTypeName(a) : null == this.value ? this.type = this.getTypeName(SFS2X.Entities.Variables.VariableType.NULL) : (a = typeof this.value, "boolean" == a ? this.type = this.getTypeName(SFS2X.Entities.Variables.VariableType.BOOL) : "number" == a ? this.type = this.value === +this.value && this.value === (this.value | 0) ? this.getTypeName(SFS2X.Entities.Variables.VariableType.INT) : this.getTypeName(SFS2X.Entities.Variables.VariableType.DOUBLE) : "string" == a ? this.type = this.getTypeName(SFS2X.Entities.Variables.VariableType.STRING) : "object" == a && (this.type = this.value instanceof Array ? this.getTypeName(SFS2X.Entities.Variables.VariableType.ARRAY) : this.getTypeName(SFS2X.Entities.Variables.VariableType.OBJECT)));
    },
    getTypeName: function getTypeName(a) {
        return SFS2X.Entities.Variables.VariableType.getTypeName(a);
    }
});
SFS2X.Entities.Variables.SFSUserVariable.fromArray = function (a) {
    return new SFS2X.Entities.Variables.SFSUserVariable(a[0], a[2], a[1]);
};
SFS2X.Entities.Variables.SFSRoomVariable = SFS2X.Entities.Variables.SFSUserVariable.extend({
    init: function init(a, b, c) {
        this._super(a, b, c);
        this.isPersistent = this.isPrivate = !1;
    },
    toString: function toString() {
        return "[RoomVar: " + this.name + ", Type: " + this.type + ", Value: " + this.value + ", Is private: " + this.isPrivate + "]";
    },
    toArray: function toArray() {
        var a = this._super();
        a.push(this.isPrivate);
        a.push(this.isPersistent);
        return a;
    }
});
SFS2X.Entities.Variables.SFSRoomVariable.fromArray = function (a) {
    var b = new SFS2X.Entities.Variables.SFSRoomVariable(a[0], a[2], a[1]);
    b.isPrivate = a[3];
    b.isPersistent = a[4];
    return b;
};
SFS2X.Entities.Variables.SFSBuddyVariable = SFS2X.Entities.Variables.SFSUserVariable.extend({
    init: function init(a, b, c) {
        this._super(a, b, c);
    },
    toString: function toString() {
        return "[BuddyVar: " + this.name + ", Type: " + this.type + ", Value: " + this.value + "]";
    },
    isOffline: function isOffline() {
        return this.name.charAt(0) == SFS2X.Entities.Variables.SFSBuddyVariable.OFFLINE_PREFIX;
    }
});
SFS2X.Entities.Variables.SFSBuddyVariable.OFFLINE_PREFIX = "$";
SFS2X.Entities.Variables.SFSBuddyVariable.fromArray = function (a) {
    return new SFS2X.Entities.Variables.SFSBuddyVariable(a[0], a[2], a[1]);
};
SFS2X.Entities.Variables.MMOItemVariable = SFS2X.Entities.Variables.SFSUserVariable.extend({
    init: function init(a, b, c) {
        this._super(a, b, c);
    },
    toString: function toString() {
        return "[ItemVar: " + this.name + ", Type: " + this.type + ", Value: " + this.value + "]";
    }
});
SFS2X.Entities.Variables.MMOItemVariable.fromArray = function (a) {
    return new SFS2X.Entities.Variables.MMOItemVariable(a[0], a[2], a[1]);
};
SFS2X.Entities.Variables.VariableType = {
    _typeStrings: "Null Bool Int Double String Object Array".split(" "),
    NULL: 0,
    BOOL: 1,
    INT: 2,
    DOUBLE: 3,
    STRING: 4,
    OBJECT: 5,
    ARRAY: 6
};
SFS2X.Entities.Variables.VariableType.getTypeName = function (a) {
    return this._typeStrings[a];
};
SFS2X.Entities.Variables.VariableType.getTypeIdFromName = function (a) {
    return this._typeStrings.indexOf(a);
};
SFS2X.Entities.Variables.ReservedBuddyVariables = {};
SFS2X.Entities.Variables.ReservedBuddyVariables.BV_ONLINE = "$__BV_ONLINE__";
SFS2X.Entities.Variables.ReservedBuddyVariables.BV_STATE = "$__BV_STATE__";
SFS2X.Entities.Variables.ReservedBuddyVariables.BV_NICKNAME = "$__BV_NICKNAME__";
SFS2X.Entities.Variables.ReservedRoomVariables = {};
SFS2X.Entities.Variables.ReservedRoomVariables.RV_GAME_STARTED = "$GS";
SFS2X.Entities.UserPrivileges = {};
SFS2X.Entities.UserPrivileges.GUEST = 0;
SFS2X.Entities.UserPrivileges.STANDARD = 1;
SFS2X.Entities.UserPrivileges.MODERATOR = 2;
SFS2X.Entities.UserPrivileges.ADMINISTRATOR = 3;
SFS2X.Entities.Match.MatchExpression = function (a, b, c) {
    this.varName = a;
    this.condition = b;
    this.value = c;
    this._parent = this.next = this.logicOp = null;
};
SFS2X.Entities.Match.MatchExpression.chainedMatchExpression = function (a, b, c, d, e) {
    a = new SFS2X.Entities.Match.MatchExpression(a, b, c);
    a.logicOp = d;
    a._parent = e;
    return a;
};
SFS2X.Entities.Match.MatchExpression.prototype.and = function (a, b, c) {
    return this.next = SFS2X.Entities.Match.MatchExpression.chainedMatchExpression(a, b, c, SFS2X.Entities.Match.LogicOperator.AND, this);
};
SFS2X.Entities.Match.MatchExpression.prototype.or = function (a, b, c) {
    return this.next = SFS2X.Entities.Match.MatchExpression.chainedMatchExpression(a, b, c, SFS2X.Entities.Match.LogicOperator.OR, this);
};
SFS2X.Entities.Match.MatchExpression.prototype.hasNext = function () {
    return null != this.next;
};
SFS2X.Entities.Match.MatchExpression.prototype.rewind = function () {
    for (var a = this;;) if (null != a._parent) a = a._parent;else break;
    return a;
};
SFS2X.Entities.Match.MatchExpression.prototype.toString = function () {
    for (var a = this.rewind(), b = a._asString(); a.hasNext();) a = a.next, b += a._asString();
    return b;
};
SFS2X.Entities.Match.MatchExpression.prototype._asString = function () {
    var a = "";
    null != this.logicOp && (a += " " + this.logicOp.id + " ");
    a = a + "(" + (this.varName + " " + this.condition.symbol + " " + ("string" == typeof this.value ? "'" + this.value + "'" : this.value));
    return a + ")";
};
SFS2X.Entities.Match.MatchExpression.prototype._toArray = function () {
    var a = this.rewind(),
        b = [];
    for (b.push(a._expressionAsArray()); a.hasNext();) a = a.next, b.push(a._expressionAsArray());
    return b;
};
SFS2X.Entities.Match.MatchExpression.prototype._expressionAsArray = function () {
    var a = [];
    null != this.logicOp ? a.push(this.logicOp.id) : a.push(null);
    a.push(this.varName);
    a.push(this.condition.type);
    a.push(this.condition.symbol);
    a.push(this.value);
    return a;
};
SFS2X.Entities.Match.LogicOperator = function (a) {
    this.id = a;
};
SFS2X.Entities.Match.LogicOperator.AND = new SFS2X.Entities.Match.LogicOperator("AND");
SFS2X.Entities.Match.LogicOperator.OR = new SFS2X.Entities.Match.LogicOperator("OR");
SFS2X.Entities.Match.BoolMatch = function (a) {
    this.type = 0;
    this.symbol = a;
};
SFS2X.Entities.Match.BoolMatch.EQUALS = new SFS2X.Entities.Match.BoolMatch("==");
SFS2X.Entities.Match.BoolMatch.NOT_EQUALS = new SFS2X.Entities.Match.BoolMatch("!=");
SFS2X.Entities.Match.NumberMatch = function (a) {
    this.type = 1;
    this.symbol = a;
};
SFS2X.Entities.Match.NumberMatch.EQUALS = new SFS2X.Entities.Match.NumberMatch("==");
SFS2X.Entities.Match.NumberMatch.NOT_EQUALS = new SFS2X.Entities.Match.NumberMatch("!=");
SFS2X.Entities.Match.NumberMatch.GREATER_THAN = new SFS2X.Entities.Match.NumberMatch(">");
SFS2X.Entities.Match.NumberMatch.GREATER_THAN_OR_EQUAL_TO = new SFS2X.Entities.Match.NumberMatch(">=");
SFS2X.Entities.Match.NumberMatch.LESS_THAN = new SFS2X.Entities.Match.NumberMatch("<");
SFS2X.Entities.Match.NumberMatch.LESS_THAN_OR_EQUAL_TO = new SFS2X.Entities.Match.NumberMatch("<=");
SFS2X.Entities.Match.StringMatch = function (a) {
    this.type = 2;
    this.symbol = a;
};
SFS2X.Entities.Match.StringMatch.EQUALS = new SFS2X.Entities.Match.StringMatch("==");
SFS2X.Entities.Match.StringMatch.NOT_EQUALS = new SFS2X.Entities.Match.StringMatch("!=");
SFS2X.Entities.Match.StringMatch.CONTAINS = new SFS2X.Entities.Match.StringMatch("contains");
SFS2X.Entities.Match.StringMatch.STARTS_WITH = new SFS2X.Entities.Match.StringMatch("startsWith");
SFS2X.Entities.Match.StringMatch.ENDS_WITH = new SFS2X.Entities.Match.StringMatch("endsWith");
SFS2X.Entities.Match.RoomProperties = {};
SFS2X.Entities.Match.RoomProperties.NAME = "${N}";
SFS2X.Entities.Match.RoomProperties.GROUP_ID = "${G}";
SFS2X.Entities.Match.RoomProperties.MAX_USERS = "${MXU}";
SFS2X.Entities.Match.RoomProperties.MAX_SPECTATORS = "${MXS}";
SFS2X.Entities.Match.RoomProperties.USER_COUNT = "${UC}";
SFS2X.Entities.Match.RoomProperties.SPECTATOR_COUNT = "${SC}";
SFS2X.Entities.Match.RoomProperties.IS_GAME = "${ISG}";
SFS2X.Entities.Match.RoomProperties.IS_PRIVATE = "${ISP}";
SFS2X.Entities.Match.RoomProperties.HAS_FREE_PLAYER_SLOTS = "${HFP}";
SFS2X.Entities.Match.RoomProperties.IS_TYPE_SFSGAME = "${IST}";
SFS2X.Entities.Match.UserProperties = {};
SFS2X.Entities.Match.UserProperties.NAME = "${N}";
SFS2X.Entities.Match.UserProperties.IS_PLAYER = "${ISP}";
SFS2X.Entities.Match.UserProperties.IS_SPECTATOR = "${ISS}";
SFS2X.Entities.Match.UserProperties.IS_NPC = "${ISN}";
SFS2X.Entities.Match.UserProperties.PRIVILEGE_ID = "${PRID}";
SFS2X.Entities.Match.UserProperties.IS_IN_ANY_ROOM = "${IAR}";
SFS2X.Entities.Invitation.SFSInvitation = function (a, b, c, d) {
    this.id = -1;
    this.inviter = a;
    this.invitee = b;
    this.secondsForAnswer = null != c ? c : 15;
    this.params = d;
};
SFS2X.Entities.Invitation.InvitationReply = {};
SFS2X.Entities.Invitation.InvitationReply.ACCEPT = 0;
SFS2X.Entities.Invitation.InvitationReply.REFUSE = 1;
SFS2X.Entities.Data.Vec3D = function (a, b, c) {
    this.px = null != a ? a : 0;
    this.py = null != b ? b : 0;
    this.pz = null != c ? c : 0;
};
SFS2X.Entities.Data.Vec3D.fromArray = function (a) {
    return new SFS2X.Entities.Data.Vec3D(a[0], a[1], a[2]);
};
SFS2X.Entities.Data.Vec3D.prototype.isFloat = function () {
    return !(this.px === parseInt(this.px) && this.py === parseInt(this.py) && this.pz === parseInt(this.pz));
};
SFS2X.Entities.Data.Vec3D.prototype._toString = function () {
    return "(" + this.px + ", " + this.py + ", " + this.pz + ")";
};
SFS2X.Entities.Data.Vec3D.prototype._toArray = function () {
    return [this.px, this.py, this.pz];
};
SFS2X.ErrorCodes = {};
SFS2X.ErrorCodes._errorsByCode = ["Client API version is obsolete: {0}; required version: {1}", "Requested Zone {0} does not exist", "User name {0} is not recognized", "Wrong password for user {0}", "User {0} is banned", "Zone {0} is full", "User {0} is already logged in Zone {1}", "The server is full", "Zone {0} is currently inactive", "User name {0} contains bad words; filtered: {1}", "Guest users not allowed in Zone {0}", "IP address {0} is banned", "A Room with the same name already exists: {0}", "Requested Group is not available - Room: {0}; Group: {1}", "Bad Room name length -  Min: {0}; max: {1}; passed name length: {2}", "Room name contains bad words: {0}", "Zone is full; can't add Rooms anymore", "You have exceeded the number of Rooms that you can create per session: {0}", "Room creation failed, wrong parameter: {0}", "User {0} already joined in Room", "Room {0} is full", "Wrong password for Room {0}", "Requested Room does not exist", "Room {0} is locked", "Group {0} is already subscribed", "Group {0} does not exist", "Group {0} is not subscribed", "Group {0} does not exist", "{0}", "Room permission error; Room {0} cannot be renamed", "Room permission error; Room {0} cannot change password state", "Room permission error; Room {0} cannot change capacity", "Switch user error; no player slots available in Room {0}", "Switch user error; no spectator slots available in Room {0}", "Switch user error; Room {0} is not a Game Room", "Switch user error; you are not joined in Room {0}", "Buddy Manager initialization error, could not load buddy list: {0}", "Buddy Manager error, your buddy list is full; size is {0}", "Buddy Manager error, was not able to block buddy {0} because offline", "Buddy Manager error, you are attempting to set too many Buddy Variables; limit is {0}", "Game {0} access denied, user does not match access criteria", "QuickJoinGame action failed: no matching Rooms were found", "Your previous invitation reply was invalid or arrived too late"];
SFS2X.ErrorCodes.setErrorMessage = function (a, b) {
    this._errorsByCode[a] = b;
};
SFS2X.ErrorCodes.getErrorMessage = function (a, b) {
    return this.stringFormat(this._errorsByCode[a], b);
};
SFS2X.ErrorCodes.stringFormat = function (a, b) {
    if (null == a) return "";
    if (null != b) for (var c = 0; c < b.length; c++) a = a.replace("{" + c + "}", b[c]);
    return a;
};
SFS2X.EventDispatcher = function () {
    this.listenersByEvent = {};
};
SFS2X.EventDispatcher.prototype.addEventListener = function (a, b, c) {
    null == this.listenersByEvent[a] && (this.listenersByEvent[a] = []);
    this.listenersByEvent[a].push({
        listener: b,
        scope: c
    });
};
SFS2X.EventDispatcher.prototype.removeEventListener = function (a, b) {
    var c = this.listenersByEvent[a];
    if (null != c) for (var d = 0; d < c.length; d++) if (c[d].listener === b) {
        c.splice(d, 1);
        break;
    }
};
SFS2X.EventDispatcher.prototype.dispatchEvent = function (a, b) {
    var c = this.listenersByEvent[a];
    if (c && 0 < c.length) for (var d = 0; d < c.length; d++) c[d].listener.call(c[d].scope, b);
};
SFS2X.EventDispatcher.prototype.getListeners = function (a) {
    return listeners[a];
};
SFS2X.SFSEvent = {
    HANDSHAKE: "handshake",
    CONNECTION: "connection",
    CONNECTION_LOST: "connectionLost",
    CONNECTION_RETRY: "connectionRetry",
    CONNECTION_RESUME: "connectionResume",
    LOGIN: "login",
    LOGIN_ERROR: "loginError",
    LOGOUT: "logout",
    ROOM_ADD: "roomAdd",
    ROOM_CREATION_ERROR: "roomCreationError",
    ROOM_REMOVE: "roomRemove",
    ROOM_JOIN: "roomJoin",
    ROOM_JOIN_ERROR: "roomJoinError",
    USER_ENTER_ROOM: "userEnterRoom",
    USER_EXIT_ROOM: "userExitRoom",
    USER_COUNT_CHANGE: "userCountChange",
    PROXIMITY_LIST_UPDATE: "proximityListUpdate",
    PLAYER_TO_SPECTATOR: "playerToSpectator",
    PLAYER_TO_SPECTATOR_ERROR: "playerToSpectatorError",
    SPECTATOR_TO_PLAYER: "spectatorToPlayer",
    SPECTATOR_TO_PLAYER_ERROR: "spectatorToPlayerError",
    ROOM_NAME_CHANGE: "roomNameChange",
    ROOM_NAME_CHANGE_ERROR: "roomNameChangeError",
    ROOM_PASSWORD_STATE_CHANGE: "roomPasswordStateChange",
    ROOM_PASSWORD_STATE_CHANGE_ERROR: "roomPasswordStateChangeError",
    ROOM_CAPACITY_CHANGE: "roomCapacityChange",
    ROOM_CAPACITY_CHANGE_ERROR: "roomCapacityChangeError",
    PUBLIC_MESSAGE: "publicMessage",
    PRIVATE_MESSAGE: "privateMessage",
    OBJECT_MESSAGE: "objectMessage",
    MODERATOR_MESSAGE: "moderatorMessage",
    ADMIN_MESSAGE: "adminMessage",
    EXTENSION_RESPONSE: "extensionResponse",
    ROOM_VARIABLES_UPDATE: "roomVariablesUpdate",
    USER_VARIABLES_UPDATE: "userVariablesUpdate",
    MMOITEM_VARIABLES_UPDATE: "mmoItemVariablesUpdate",
    ROOM_GROUP_SUBSCRIBE: "roomGroupSubscribe",
    ROOM_GROUP_SUBSCRIBE_ERROR: "roomGroupSubscribeError",
    ROOM_GROUP_UNSUBSCRIBE: "roomGroupUnsubscribe",
    ROOM_GROUP_UNSUBSCRIBE_ERROR: "roomGroupUnsubscribeError",
    ROOM_FIND_RESULT: "roomFindResult",
    USER_FIND_RESULT: "userFindResult",
    INVITATION: "invitation",
    INVITATION_REPLY: "invitationReply",
    INVITATION_REPLY_ERROR: "invitationReplyError",
    PING_PONG: "pingPong",
    SOCKET_ERROR: "socketError"
};
SFS2X.SFSBuddyEvent = {
    BUDDY_LIST_INIT: "buddyListInit",
    BUDDY_ADD: "buddyAdd",
    BUDDY_REMOVE: "buddyRemove",
    BUDDY_BLOCK: "buddyBlock",
    BUDDY_ERROR: "buddyError",
    BUDDY_ONLINE_STATE_CHANGE: "buddyOnlineStateChange",
    BUDDY_VARIABLES_UPDATE: "buddyVariablesUpdate",
    BUDDY_MESSAGE: "buddyMessage"
};
SFS2X.Exceptions = {};
SFS2X.Exceptions.SFSError = Class.extend({
    init: function init(a) {
        this._messsage = a;
    },
    getMessage: function getMessage() {
        return this._messsage;
    }
});
SFS2X.Exceptions.SFSValidationError = SFS2X.Exceptions.SFSError.extend({
    init: function init(a, b) {
        this._super(a);
        this._errrors = b;
    },
    getErrors: function getErrors() {
        return this._errrors;
    }
});
SFS2X.LogLevel = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
};
SFS2X._Logger = function () {
    this.isAvailable = void 0 != console;
    this.level = SFS2X.LogLevel.INFO;
};
SFS2X.Logger = new SFS2X._Logger();
SFS2X._Logger.prototype.setLevel = function (a) {
    a < SFS2X.LogLevel.DEBUG || a > SFS2X.LogLevel.ERROR || (this.level = a);
};
SFS2X._Logger.prototype.debug = function (a) {
    this.isAvailable && this.level <= SFS2X.LogLevel.DEBUG && console.log("[DEBUG] " + a);
};
SFS2X._Logger.prototype.info = function (a) {
    this.isAvailable && this.level <= SFS2X.LogLevel.INFO && console.log("[INFO] " + a);
};
SFS2X._Logger.prototype.warn = function (a) {
    this.isAvailable && this.level <= SFS2X.LogLevel.WARN && console.log("[WARN] " + a);
};
SFS2X._Logger.prototype.error = function (a) {
    this.isAvailable && console.log("[ERROR] " + a);
};
SFS2X.Managers = {};
SFS2X.Managers.UserManager = Class.extend({
    init: function init(a) {
        this._sfs = a;
        this._usersById = new SFS2X.Utils.HashTable();
        this._usersByName = new SFS2X.Utils.HashTable();
    },
    containsUserName: function containsUserName(a) {
        return this._usersByName.hasItem(a);
    },
    containsUserId: function containsUserId(a) {
        return this._usersById.hasItem(a);
    },
    containsUser: function containsUser(a) {
        return this._usersById.hasItem(a.id);
    },
    getUserById: function getUserById(a) {
        return this._usersById.getItem(a);
    },
    getUserByName: function getUserByName(a) {
        return this._usersByName.getItem(a);
    },
    getUserCount: function getUserCount() {
        return this._usersById.length;
    },
    getUserList: function getUserList() {
        return this._usersById.values();
    },
    _addUser: function _addUser(a) {
        this._usersById.hasItem(a.id) && SFS2X.Logger.warn("Unexpected, duplicate user in UserManager: " + a.toString());
        this.__addUser(a);
    },
    __addUser: function __addUser(a) {
        this._usersByName.setItem(a.name, a);
        this._usersById.setItem(a.id, a);
    },
    _removeUser: function _removeUser(a) {
        this.__removeUser(a);
    },
    __removeUser: function __removeUser(a) {
        this._usersById.removeItem(a.id);
        this._usersByName.removeItem(a.name);
    },
    _removeUserById: function _removeUserById() {
        this._usersById.removeItem(user.id);
        this._usersByName.removeItem(user.name);
    },
    _clearAll: function _clearAll() {
        this._usersById.clear();
        this._usersByName.clear();
    }
});
SFS2X.Managers.GlobalUserManager = SFS2X.Managers.UserManager.extend({
    init: function init(a) {
        this._super(a);
        this._roomRefCount = [];
    },
    _addUser: function _addUser(a) {
        null == this._roomRefCount[a] ? this._roomRefCount[a] = 1 : this._roomRefCount[a]++;
        this.__addUser(a);
    },
    _removeUser: function _removeUser(a) {
        null != this._roomRefCount ? 1 > this._roomRefCount[a] ? SFS2X.Logger.warn("GlobalUserManager RefCount is already at zero. User: " + a) : (this._roomRefCount[a]--, 0 == this._roomRefCount[a] && (this.__removeUser(a), delete this._roomRefCount[a])) : SFS2X.Logger.warn("Can't remove User from GlobalUserManager. RefCount missing. User: " + a);
    },
    dumpRefCount: function dumpRefCount() {}
});
SFS2X.Managers.RoomManager = function (a) {
    this._sfs = a;
    this._ownerZone = null;
    this._groups = [];
    this._roomsById = new SFS2X.Utils.HashTable();
    this._roomsByName = new SFS2X.Utils.HashTable();
};
SFS2X.Managers.RoomManager.prototype.getRoomGroups = function () {
    return this._groups;
};
SFS2X.Managers.RoomManager.prototype.containsGroup = function (a) {
    return -1 < this._groups.indexOf(a);
};
SFS2X.Managers.RoomManager.prototype.containsRoom = function (a) {
    return "number" == typeof a ? this._roomsById.hasItem(a) : this._roomsByName.hasItem(a);
};
SFS2X.Managers.RoomManager.prototype.containsRoomInGroup = function (a, b) {
    var c = this.getRoomListFromGroup(b),
        d = !1,
        e = "number" == typeof a,
        f;
    for (f in c) {
        var g = c[f];
        if (g instanceof SFS2X.Entities.SFSRoom) if (e) {
            if (g.id == a) {
                d = !0;
                break;
            }
        } else if (g.name == a) {
            d = !0;
            break;
        }
    }
    return d;
};
SFS2X.Managers.RoomManager.prototype.getRoomById = function (a) {
    return this._roomsById.getItem(a);
};
SFS2X.Managers.RoomManager.prototype.getRoomByName = function (a) {
    return this._roomsByName.getItem(a);
};
SFS2X.Managers.RoomManager.prototype.getRoomList = function () {
    return this._roomsById.values();
};
SFS2X.Managers.RoomManager.prototype.getRoomCount = function () {
    return this._roomsById.length;
};
SFS2X.Managers.RoomManager.prototype.getRoomListFromGroup = function (a) {
    var b = [],
        c;
    for (c in this._roomsById.items) {
        var d = this._roomsById.items[c];
        d instanceof SFS2X.Entities.SFSRoom && d.groupId == a && b.push(d);
    }
    return b;
};
SFS2X.Managers.RoomManager.prototype.getJoinedRooms = function () {
    var a = [],
        b;
    for (b in this._roomsById.items) {
        var c = this._roomsById.items[b];
        c instanceof SFS2X.Entities.SFSRoom && c.isJoined && a.push(c);
    }
    return a;
};
SFS2X.Managers.RoomManager.prototype.getUserRooms = function (a) {
    var b = [],
        c;
    for (c in this._roomsById.items) {
        var d = this._roomsById.items[c];
        d instanceof SFS2X.Entities.SFSRoom && d.containsUser(a) && b.push(d);
    }
    return b;
};
SFS2X.Managers.RoomManager.prototype._addRoom = function (a, b) {
    null == b && (b = !0);
    this._roomsById.setItem(a.id, a);
    this._roomsByName.setItem(a.name, a);
    b ? this.containsGroup(a.groupId) || this._addGroup(a.groupId) : a._isManaged = !1;
};
SFS2X.Managers.RoomManager.prototype._replaceRoom = function (a, b) {
    null == b && (b = !0);
    var c = this.getRoomById(a.id);
    if (null != c) return c._merge(a), c;
    this._addRoom(a, b);
    return a;
};
SFS2X.Managers.RoomManager.prototype._removeRoom = function (a) {
    this._roomsById.removeItem(a.id);
    this._roomsByName.removeItem(a.name);
};
SFS2X.Managers.RoomManager.prototype._removeRoomById = function (a) {
    a = this.getRoomById(a);
    null != a && this._removeRoom(a);
};
SFS2X.Managers.RoomManager.prototype._removeRoomByName = function (a) {
    a = this.getRoomByName(a);
    null != a && this._removeRoom(a);
};
SFS2X.Managers.RoomManager.prototype._changeRoomName = function (a, b) {
    var c = a.name;
    a.name = b;
    this._roomsByName.setItem(b, a);
    this._roomsByName.removeItem(c);
};
SFS2X.Managers.RoomManager.prototype._changeRoomPasswordState = function (a, b) {
    a.isPasswordProtected = b;
};
SFS2X.Managers.RoomManager.prototype._changeRoomCapacity = function (a, b, c) {
    a.maxUsers = b;
    a.maxSpectators = c;
};
SFS2X.Managers.RoomManager.prototype._addGroup = function (a) {
    this._groups.push(a);
};
SFS2X.Managers.RoomManager.prototype._removeGroup = function (a) {
    SFS2X.Utils.ArrayUtil.removeItem(this._groups, a);
    var a = this.getRoomListFromGroup(a),
        b;
    for (b in a) {
        var c = a[b];
        c instanceof SFS2X.Entities.SFSRoom && (c.isJoined ? c._isManaged = !1 : this._removeRoom(c));
    }
};
SFS2X.Managers.RoomManager.prototype._removeUser = function (a) {
    for (var b in this._roomsById.items) {
        var c = this._roomsById.items[b];
        c instanceof SFS2X.Entities.SFSRoom && c.containsUser(a) && c._removeUser(a);
    }
};
SFS2X.Managers.BuddyManager = function (a) {
    this._sfs = a;
    this._buddiesByName = [];
    this._myVariables = [];
    this._inited = !1;
    this._buddyStates = [];
};
SFS2X.Managers.BuddyManager.prototype.isInited = function () {
    return this._inited;
};
SFS2X.Managers.BuddyManager.prototype.containsBuddy = function (a) {
    return null != this.getBuddyByName(a);
};
SFS2X.Managers.BuddyManager.prototype.getBuddyById = function (a) {
    if (-1 < a) for (var b in this._buddiesByName) {
        var c = this._buddiesByName[b];
        if (c instanceof SFS2X.Entities.SFSBuddy && c.id == a) return c;
    }
    return null;
};
SFS2X.Managers.BuddyManager.prototype.getBuddyByName = function (a) {
    return this._buddiesByName[a];
};
SFS2X.Managers.BuddyManager.prototype.getBuddyByNickName = function (a) {
    for (var b in this._buddiesByName) {
        var c = this._buddiesByName[b];
        if (c instanceof SFS2X.Entities.SFSBuddy && c.nickName == a) return c;
    }
    return null;
};
SFS2X.Managers.BuddyManager.prototype.getOfflineBuddies = function () {
    var a = [],
        b;
    for (b in this._buddiesByName) {
        var c = this._buddiesByName[b];
        c instanceof SFS2X.Entities.SFSBuddy && !c.isOnline() && a.push(c);
    }
    return a;
};
SFS2X.Managers.BuddyManager.prototype.getOnlineBuddies = function () {
    var a = [],
        b;
    for (b in this._buddiesByName) {
        var c = this._buddiesByName[b];
        c instanceof SFS2X.Entities.SFSBuddy && c.isOnline() && a.push(c);
    }
    return a;
};
SFS2X.Managers.BuddyManager.prototype.getBuddyList = function () {
    return SFS2X.Utils.ArrayUtil.objToArray(this._buddiesByName);
};
SFS2X.Managers.BuddyManager.prototype.getMyVariable = function (a) {
    return this._myVariables[a];
};
SFS2X.Managers.BuddyManager.prototype.getMyVariables = function () {
    return SFS2X.Utils.ArrayUtil.objToArray(this._myVariables);
};
SFS2X.Managers.BuddyManager.prototype.getMyOnlineState = function () {
    if (!this._inited) return !1;
    var a = !0,
        b = this.getMyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_ONLINE);
    null != b && (a = b.value);
    return a;
};
SFS2X.Managers.BuddyManager.prototype.getMyNickName = function () {
    var a = this.getMyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_NICKNAME);
    return null != a ? a.value : null;
};
SFS2X.Managers.BuddyManager.prototype.getMyState = function () {
    var a = this.getMyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_STATE);
    return null != a ? a.value : null;
};
SFS2X.Managers.BuddyManager.prototype.getBuddyStates = function () {
    return this._buddyStates;
};
SFS2X.Managers.BuddyManager.prototype._setInited = function () {
    this._inited = !0;
};
SFS2X.Managers.BuddyManager.prototype._addBuddy = function (a) {
    this._buddiesByName[a.name] = a;
};
SFS2X.Managers.BuddyManager.prototype._clearAll = function () {
    this._buddiesByName = [];
};
SFS2X.Managers.BuddyManager.prototype._removeBuddyById = function (a) {
    a = this.getBuddyById(a);
    null != a && delete this._buddiesByName[a.name];
    return a;
};
SFS2X.Managers.BuddyManager.prototype._removeBuddyByName = function (a) {
    var b = this.getBuddyByName(a);
    null != b && delete this._buddiesByName[a];
    return b;
};
SFS2X.Managers.BuddyManager.prototype._setMyVariables = function (a) {
    for (var b = 0; b < a.length; b++) this._setMyVariable(a[b]);
};
SFS2X.Managers.BuddyManager.prototype._setMyVariable = function (a) {
    a.isNull() ? delete this._myVariables[a.name] : this._myVariables[a.name] = a;
};
SFS2X.Managers.BuddyManager.prototype._setMyOnlineState = function (a) {
    a = new SFS2X.Entities.Variables.SFSBuddyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_ONLINE, a);
    this._setMyVariable(a);
};
SFS2X.Managers.BuddyManager.prototype._setMyNickName = function (a) {
    a = new SFS2X.Entities.Variables.SFSBuddyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_NICKNAME, a);
    this._setMyVariable(a);
};
SFS2X.Managers.BuddyManager.prototype._setMyState = function (a) {
    a = new SFS2X.Entities.Variables.SFSBuddyVariable(SFS2X.Entities.Variables.ReservedBuddyVariables.BV_STATE, a);
    this._setMyVariable(a);
};
SFS2X.Managers.BuddyManager.prototype._setBuddyStates = function (a) {
    this._buddyStates = a;
};
SFS2X.Requests = {};
SFS2X.Requests.System = {};
SFS2X.Requests.MMO = {};
SFS2X.Requests.BuddyList = {};
SFS2X.Requests.Game = {};
SFS2X.Requests._BaseRequest = Class.extend({
    init: function init(a) {
        this._reqObj = {};
        this._id = a;
        this._targetController = 0;
        this._log = SFS2X.Logger;
    },
    getMessage: function getMessage() {
        return {
            a: this._id,
            c: this._targetController,
            p: this._reqObj
        };
    },
    validate: function validate() {
        this._log.error("BaseRequest.validate = no child-class implementation found!");
    },
    execute: function execute() {
        this._log.error("BaseRequest.execute = no child-class implementation found!");
    }
});
SFS2X.Requests.System.HandshakeRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.Handshake);
        this._apiVersion = a;
        this._clientDetails = b;
        this._reconnectionToken = c;
    },
    validate: function validate() {},
    execute: function execute() {
        this._reqObj[this.constructor.KEY_API] = this._apiVersion;
        this._reqObj[this.constructor.KEY_CLIENT_TYPE] = this._clientDetails;
        null != this._reconnectionToken && (this.reqObj[this.constructor.KEY_RECONNECTION_TOKEN] = this._reconnectionToken);
    }
});
SFS2X.Requests.System.HandshakeRequest.KEY_SESSION_TOKEN = "tk";
SFS2X.Requests.System.HandshakeRequest.KEY_API = "api";
SFS2X.Requests.System.HandshakeRequest.KEY_COMPRESSION_THRESHOLD = "ct";
SFS2X.Requests.System.HandshakeRequest.KEY_RECONNECTION_TOKEN = "rt";
SFS2X.Requests.System.HandshakeRequest.KEY_CLIENT_TYPE = "cl";
SFS2X.Requests.System.HandshakeRequest.KEY_MAX_MESSAGE_SIZE = "ms";
SFS2X.Requests.System.LoginRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c, d) {
        this._super(SFS2X.Requests.Login);
        this._userName = a;
        this._password = b;
        this._params = c;
        this._zoneName = d;
    },
    validate: function validate(a) {
        if (null != a.mySelf) throw new SFS2X.Exceptions.SFSValidationError("LoginRequest error", ["You are already logged in; logout before attempting a new login"]);
        a = null != a.config && null != a.config.zone ? a.config.zone : null;
        null != this._zoneName && (a = this._zoneName);
        if (null == a || 0 == a.length) throw new SFS2X.Exceptions.SFSValidationError("LoginRequest Error", ["Missing Zone name"]);
        this._zoneName = a;
        null == this._userName && (this._userName = "");
        null == this._password && (this._password = "");
    },
    execute: function execute(a) {
        this._reqObj[this.constructor.KEY_ZONE_NAME] = this._zoneName;
        this._reqObj[this.constructor.KEY_USER_NAME] = this._userName;
        this._reqObj[this.constructor.KEY_PASSWORD] = 0 < this._password.length ? hex_md5(a.sessionToken + this._password) : "";
        null != this._params && (this._reqObj[this.constructor.KEY_PARAMS] = this._params);
    }
});
SFS2X.Requests.System.LoginRequest.KEY_ZONE_NAME = "zn";
SFS2X.Requests.System.LoginRequest.KEY_USER_NAME = "un";
SFS2X.Requests.System.LoginRequest.KEY_PASSWORD = "pw";
SFS2X.Requests.System.LoginRequest.KEY_PARAMS = "p";
SFS2X.Requests.System.LoginRequest.KEY_PRIVILEGE_ID = "pi";
SFS2X.Requests.System.LoginRequest.KEY_ID = "id";
SFS2X.Requests.System.LoginRequest.KEY_ROOMLIST = "rl";
SFS2X.Requests.System.LoginRequest.KEY_RECONNECTION_SECONDS = "rs";
SFS2X.Requests.System.LogoutRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init() {
        this._super(SFS2X.Requests.Logout);
    },
    validate: function validate(a) {
        if (null == a.mySelf) throw new SFS2X.Exceptions.SFSValidationError("LogoutRequest error", ["You are not logged in"]);
    },
    execute: function execute() {}
});
SFS2X.Requests.System.LogoutRequest.KEY_ZONE_NAME = "zn";
SFS2X.Requests.System.JoinRoomRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c, d) {
        this._super(SFS2X.Requests.JoinRoom);
        "string" == typeof a ? this._rName = a : "number" == typeof a ? this._rId = a : a instanceof SFS2X.Entities.SFSRoom && (this._rId = a.id, this._rName = a.name);
        this._password = b;
        this._roomIdToLeave = c;
        this._asSpectator = "boolean" == typeof d ? d : !1;
    },
    validate: function validate() {
        if (null == this._rId && null == this._rName) throw new SFS2X.Exceptions.SFSValidationError("JoinRoomRequest Error", ["Missing Room id or name, please provide one of the two or an existing Room object"]);
    },
    execute: function execute(a) {
        a._isJoining = !0;
        0 <= this._rId ? this._reqObj[this.constructor.KEY_ROOM_ID] = this._rId : null != this._rName && (this._reqObj[this.constructor.KEY_ROOM_NAME] = this._rName);
        null != this._password && (this._reqObj[this.constructor.KEY_PASS] = this._password);
        null != this._roomIdToLeave && (this._reqObj[this.constructor.KEY_ROOM_TO_LEAVE] = this._roomIdToLeave);
        this._asSpectator && (this._reqObj[this.constructor.KEY_AS_SPECTATOR] = this._asSpectator);
    }
});
SFS2X.Requests.System.JoinRoomRequest.KEY_ROOM = "r";
SFS2X.Requests.System.JoinRoomRequest.KEY_USER_LIST = "ul";
SFS2X.Requests.System.JoinRoomRequest.KEY_ROOM_NAME = "n";
SFS2X.Requests.System.JoinRoomRequest.KEY_ROOM_ID = "i";
SFS2X.Requests.System.JoinRoomRequest.KEY_PASS = "p";
SFS2X.Requests.System.JoinRoomRequest.KEY_ROOM_TO_LEAVE = "rl";
SFS2X.Requests.System.JoinRoomRequest.KEY_AS_SPECTATOR = "sp";
SFS2X.Requests.System.CreateRoomRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.CreateRoom);
        this._settings = a;
        this._autoJoin = "boolean" == typeof b ? b : !1;
        this._roomToLeave = c;
    },
    validate: function validate() {
        var a = [];
        (null == this._settings.name || 0 == this._settings.name.length) && a.push("Missing Room name");
        0 >= this._settings.maxUsers && a.push("Max number of users must be > 0");
        null != this._settings.extension && ((null == this._settings.extension.className || 0 == this._settings.extension.className.length) && a.push("Missing Extension class name"), (null == this._settings.extension.id || 0 == this._settings.extension.id.length) && a.push("Missing Extension id"));
        this._settings instanceof SFS2X.Requests.MMO.MMORoomSettings && (null == this._settings.defaultAOI && a.push("Missing default AoI (Area of Interest)"), null != this._settings.mapLimits && (null == this._settings.mapLimits.lowerLimit || null == this._settings.mapLimits.higherLimit) && a.push("Map limits must be both defined"));
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("CreateRoomRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_NAME] = this._settings.name;
        this._reqObj[this.constructor.KEY_GROUP_ID] = this._settings.groupId;
        this._reqObj[this.constructor.KEY_PASSWORD] = this._settings.password;
        this._reqObj[this.constructor.KEY_ISGAME] = this._settings.isGame;
        this._reqObj[this.constructor.KEY_MAXUSERS] = this._settings.maxUsers;
        this._reqObj[this.constructor.KEY_MAXSPECTATORS] = this._settings.maxSpectators;
        this._reqObj[this.constructor.KEY_MAXVARS] = this._settings.maxVariables;
        if (null != this._settings.variables && 0 < this._settings.variables.length) {
            var a = [],
                b;
            for (b in this._settings.variables) {
                var c = this._settings.variables[b];
                c instanceof SFS2X.Entities.Variables.SFSRoomVariable && a.push(c.toArray());
            }
            this._reqObj[this.constructor.KEY_ROOMVARS] = a;
        }
        null != this._settings.permissions && (a = [], a.push(this._settings.permissions.allowNameChange), a.push(this._settings.permissions.allowPasswordStateChange), a.push(this._settings.permissions.allowPublicMessages), a.push(this._settings.permissions.allowResizing), this._reqObj[this.constructor.KEY_PERMISSIONS] = a);
        null != this._settings.events && (a = [], a.push(this._settings.events.allowUserEnter), a.push(this._settings.events.allowUserExit), a.push(this._settings.events.allowUserCountChange), a.push(this._settings.events.allowUserVariablesUpdate), this._reqObj[this.constructor.KEY_EVENTS] = a);
        null != this._settings.extension && (this._reqObj[this.constructor.KEY_EXTID] = this._settings.extension.id, this._reqObj[this.constructor.KEY_EXTCLASS] = this._settings.extension.className, null != this._settings.extension.propertiesFile && 0 < this._settings.extension.propertiesFile.length && (this._reqObj[this.constructor.KEY_EXTPROP] = this._settings.extension.propertiesFile));
        this._settings instanceof SFS2X.Requests.MMO.MMORoomSettings && (this._reqObj[this.constructor.KEY_MMO_DEFAULT_AOI] = this._settings.defaultAOI._toArray(), null != this._settings.mapLimits && (this._reqObj[this.constructor.KEY_MMO_MAP_LOW_LIMIT] = this._settings.mapLimits.lowerLimit._toArray(), this._reqObj[this.constructor.KEY_MMO_MAP_HIGH_LIMIT] = this._settings.mapLimits.higherLimit._toArray()), this._reqObj[this.constructor.KEY_MMO_USER_MAX_LIMBO_SECONDS] = this._settings.userMaxLimboSeconds, this._reqObj[this.constructor.KEY_MMO_PROXIMITY_UPDATE_MILLIS] = this._settings.proximityListUpdateMillis, this._reqObj[this.constructor.KEY_MMO_SEND_ENTRY_POINT] = this._settings.sendAOIEntryPoint);
        this._reqObj[this.constructor.KEY_AUTOJOIN] = this._autoJoin;
        null != this._roomToLeave && (this._reqObj[this.constructor.KEY_ROOM_TO_LEAVE] = this._roomToLeave.id);
    }
});
SFS2X.Requests.System.CreateRoomRequest.KEY_ROOM = "r";
SFS2X.Requests.System.CreateRoomRequest.KEY_NAME = "n";
SFS2X.Requests.System.CreateRoomRequest.KEY_PASSWORD = "p";
SFS2X.Requests.System.CreateRoomRequest.KEY_GROUP_ID = "g";
SFS2X.Requests.System.CreateRoomRequest.KEY_ISGAME = "ig";
SFS2X.Requests.System.CreateRoomRequest.KEY_MAXUSERS = "mu";
SFS2X.Requests.System.CreateRoomRequest.KEY_MAXSPECTATORS = "ms";
SFS2X.Requests.System.CreateRoomRequest.KEY_MAXVARS = "mv";
SFS2X.Requests.System.CreateRoomRequest.KEY_ROOMVARS = "rv";
SFS2X.Requests.System.CreateRoomRequest.KEY_PERMISSIONS = "pm";
SFS2X.Requests.System.CreateRoomRequest.KEY_EVENTS = "ev";
SFS2X.Requests.System.CreateRoomRequest.KEY_EXTID = "xn";
SFS2X.Requests.System.CreateRoomRequest.KEY_EXTCLASS = "xc";
SFS2X.Requests.System.CreateRoomRequest.KEY_EXTPROP = "xp";
SFS2X.Requests.System.CreateRoomRequest.KEY_AUTOJOIN = "aj";
SFS2X.Requests.System.CreateRoomRequest.KEY_ROOM_TO_LEAVE = "rl";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_DEFAULT_AOI = "maoi";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_MAP_LOW_LIMIT = "mllm";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_MAP_HIGH_LIMIT = "mlhm";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_USER_MAX_LIMBO_SECONDS = "muls";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_PROXIMITY_UPDATE_MILLIS = "mpum";
SFS2X.Requests.System.CreateRoomRequest.KEY_MMO_SEND_ENTRY_POINT = "msep";
SFS2X.Requests.System.GenericMessageRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init() {
        this._super(SFS2X.Requests.GenericMessage);
        this._type = -1;
        this._recipient = this._params = this._message = this._user = this._room = null;
        this._sendMode = -1;
    },
    validate: function validate(a) {
        if (0 > this._type) throw new SFS2X.Exceptions.SFSValidationError("GenericMessageRequest Error", ["Unsupported message type: " + this._type]);
        var b = [];
        switch (this._type) {
            case SFS2X.Requests.GenericMessageType.PUBLIC_MSG:
                this._validatePublicMessage(a, b);
                break;
            case SFS2X.Requests.GenericMessageType.PRIVATE_MSG:
                this._validatePrivateMessage(a, b);
                break;
            case SFS2X.Requests.GenericMessageType.OBJECT_MSG:
                this._validateObjectMessage(a, b);
                break;
            case SFS2X.Requests.GenericMessageType.BUDDY_MSG:
                this._validateBuddyMessage(a, b);
                break;
            default:
                this._validateSuperUserMessage(a, b);
        }
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("GenericMessageRequest Error", b);
    },
    execute: function execute(a) {
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE_TYPE] = this._type;
        switch (this._type) {
            case SFS2X.Requests.GenericMessageType.PUBLIC_MSG:
                this._executePublicMessage(a);
                break;
            case SFS2X.Requests.GenericMessageType.PRIVATE_MSG:
                this._executePrivateMessage(a);
                break;
            case SFS2X.Requests.GenericMessageType.OBJECT_MSG:
                this._executeObjectMessage(a);
                break;
            case SFS2X.Requests.GenericMessageType.BUDDY_MSG:
                this._executeBuddyMessage(a);
                break;
            default:
                this._executeSuperUserMessage(a);
        }
    },
    _validatePublicMessage: function _validatePublicMessage(a, b) {
        (null == this._message || 0 == this._message.length) && b.push("Public message is empty");
        null != this._room && !a.mySelf.isJoinedInRoom(this._room) && b.push("You are not joined in the target Room: " + this._room);
    },
    _validatePrivateMessage: function _validatePrivateMessage(a, b) {
        (null == this._message || 0 == this._message.length) && b.push("Private message is empty");
        0 > this._recipient && b.push("Invalid recipient id: " + this._recipient);
    },
    _validateObjectMessage: function _validateObjectMessage(a, b) {
        null == this._params && b.push("Object message is null");
    },
    _validateBuddyMessage: function _validateBuddyMessage(a, b) {
        a.buddyManager.isInited || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        !1 == a.buddyManager.myOnlineState && b.push("Can't send messages while you are offline in the Buddy List system");
        (null == this._message || 0 == this._message.length) && b.push("Buddy message is empty");
        0 > this._recipient && b.push("Recipient is offline or not in your Buddy List");
    },
    _validateSuperUserMessage: function _validateSuperUserMessage(a, b) {
        (null == this._message || 0 == this._message.length) && b.push("Moderator message is empty");
        switch (this._sendMode) {
            case SFS2X.Requests.MessageRecipientMode.TO_USER:
                this._recipient instanceof SFS2X.Entities.SFSUser || b.push("SFSUser object expected as recipient");
                break;
            case SFS2X.Requests.MessageRecipientMode.TO_ROOM:
                this._recipient instanceof SFS2X.Entities.SFSRoom || b.push("SFSRoom object expected as recipient");
                break;
            case SFS2X.Requests.MessageRecipientMode.TO_GROUP:
                "string" != typeof this._recipient && b.push("String object (the groupId) expected as recipient");
        }
    },
    _executePublicMessage: function _executePublicMessage(a) {
        null == this._room && (this._room = a.lastJoinedRoom);
        if (null == this._room) throw new SFS2X.Exceptions.SFSError("User should be joined in a Room in order to send a public message");
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_ROOM_ID] = this._room.id;
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID] = a.mySelf.id;
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE] = this._message;
        null != this._params && (this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS] = this._params);
    },
    _executePrivateMessage: function _executePrivateMessage() {
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = this._recipient;
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE] = this._message;
        null != this._params && (this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS] = this._params);
    },
    _executeBuddyMessage: function _executeBuddyMessage() {
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = this._recipient;
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE] = this._message;
        null != this._params && (this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS] = this._params);
    },
    _executeSuperUserMessage: function _executeSuperUserMessage() {
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE] = this._message;
        null != this._params && (this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS] = this._params);
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT_MODE] = this._sendMode;
        switch (this._sendMode) {
            case SFS2X.Requests.MessageRecipientMode.TO_USER:
                this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = this._recipient.id;
                break;
            case SFS2X.Requests.MessageRecipientMode.TO_ROOM:
                this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = this._recipient.id;
                break;
            case SFS2X.Requests.MessageRecipientMode.TO_GROUP:
                this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = this._recipient;
        }
    },
    _executeObjectMessage: function _executeObjectMessage(a) {
        null == this._room && (this._room = a.lastJoinedRoom);
        if (null == this._room) throw new SFS2X.Exceptions.SFSError("User should be joined in a Room in order to send an object message");
        a = [];
        if (null != this._recipient && this._recipient instanceof Array) {
            var b = this._recipient;
            if (b.length > this._room.capacity) throw new SFS2X.Exceptions.SFSError("The number of recipients is bigger than the target Room capacity: " + b.length);
            for (var c in b) {
                var d = b[c];
                d instanceof SFS2X.Entities.SFSUser ? a.push(d.id) : this._log.warn("Bad recipient in ObjectMessage recipient list: " + typeof d + "; expected type: SFSUser");
            }
        }
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_ROOM_ID] = this._room.id;
        this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS] = this._params;
        0 < a.length && (this._reqObj[SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT] = a);
    }
});
SFS2X.Requests.System.GenericMessageRequest.KEY_ROOM_ID = "r";
SFS2X.Requests.System.GenericMessageRequest.KEY_USER_ID = "u";
SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE = "m";
SFS2X.Requests.System.GenericMessageRequest.KEY_MESSAGE_TYPE = "t";
SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT = "rc";
SFS2X.Requests.System.GenericMessageRequest.KEY_RECIPIENT_MODE = "rm";
SFS2X.Requests.System.GenericMessageRequest.KEY_XTRA_PARAMS = "p";
SFS2X.Requests.System.GenericMessageRequest.KEY_SENDER_DATA = "sd";
SFS2X.Requests.System.ChangeRoomNameRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b) {
        this._super(SFS2X.Requests.ChangeRoomName);
        this._room = a;
        this._newName = b;
    },
    validate: function validate() {
        var a = [];
        null == this._room && a.push("Provided Room is null");
        (null == this._newName || 0 == this._newName.length) && a.push("Invalid new room name: it must be a non-null and non-empty string");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("ChangeRoomNameRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_ROOM] = this._room.id;
        this._reqObj[this.constructor.KEY_NAME] = this._newName;
    }
});
SFS2X.Requests.System.ChangeRoomNameRequest.KEY_ROOM = "r";
SFS2X.Requests.System.ChangeRoomNameRequest.KEY_NAME = "n";
SFS2X.Requests.System.ChangeRoomPasswordStateRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b) {
        this._super(SFS2X.Requests.ChangeRoomPassword);
        this._room = a;
        this._newPass = b;
    },
    validate: function validate() {
        var a = [];
        null == this._room && a.push("Provided Room is null");
        null == this._newPass && a.push("Invalid new room name: it must be a non-null string");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("ChangeRoomPasswordStateRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_ROOM] = this._room.id;
        this._reqObj[this.constructor.KEY_PASS] = this._newPass;
    }
});
SFS2X.Requests.System.ChangeRoomPasswordStateRequest.KEY_ROOM = "r";
SFS2X.Requests.System.ChangeRoomPasswordStateRequest.KEY_PASS = "p";
SFS2X.Requests.System.ObjectMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        this._type = SFS2X.Requests.GenericMessageType.OBJECT_MSG;
        this._params = a;
        this._room = b;
        this._recipient = c;
    }
});
SFS2X.Requests.System.SetRoomVariablesRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b) {
        this._super(SFS2X.Requests.SetRoomVariables);
        this._roomVariables = a;
        this._room = b;
    },
    validate: function validate(a) {
        var b = [];
        null != this._room ? this._room.containsUser(a.mySelf) || b.push("You are not joined in the target Room") : null == a.lastJoinedRoom && b.push("You are not joined in any Room");
        (null == this._roomVariables || 0 == this._roomVariables.length) && b.push("No variables were specified");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("SetRoomVariablesRequest Error", b);
    },
    execute: function execute(a) {
        var b = [],
            c;
        for (c in this._roomVariables) {
            var d = this._roomVariables[c];
            d instanceof SFS2X.Entities.Variables.SFSRoomVariable && b.push(d.toArray());
        }
        null == this._room && (this._room = a.lastJoinedRoom);
        this._reqObj[this.constructor.KEY_VAR_LIST] = b;
        this._reqObj[this.constructor.KEY_VAR_ROOM] = this._room.id;
    }
});
SFS2X.Requests.System.SetRoomVariablesRequest.KEY_VAR_ROOM = "r";
SFS2X.Requests.System.SetRoomVariablesRequest.KEY_VAR_LIST = "vl";
SFS2X.Requests.System.SetUserVariablesRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.SetUserVariables);
        this._userVariables = a;
    },
    validate: function validate() {
        var a = [];
        (null == this._userVariables || 0 == this._userVariables.length) && a.push("No variables were specified");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("SetUserVariablesRequest Error", a);
    },
    execute: function execute() {
        var a = [],
            b;
        for (b in this._userVariables) {
            var c = this._userVariables[b];
            c instanceof SFS2X.Entities.Variables.SFSUserVariable && a.push(c.toArray());
        }
        this._reqObj[this.constructor.KEY_VAR_LIST] = a;
    }
});
SFS2X.Requests.System.SetUserVariablesRequest.KEY_USER = "u";
SFS2X.Requests.System.SetUserVariablesRequest.KEY_VAR_LIST = "vl";
SFS2X.Requests.System.ExtensionRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.CallExtension);
        this._targetController = 1;
        this._extCmd = a;
        this._params = b;
        this._room = c;
        null == this._params && (this._params = {});
    },
    validate: function validate() {
        var a = [];
        (null == this._extCmd || 0 == this._extCmd.length) && a.push("Missing extension command");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("ExtensionRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_CMD] = this._extCmd;
        this._reqObj[this.constructor.KEY_ROOM] = null == this._room ? -1 : this._room.id;
        this._reqObj[this.constructor.KEY_PARAMS] = this._params;
    }
});
SFS2X.Requests.System.ExtensionRequest.KEY_CMD = "c";
SFS2X.Requests.System.ExtensionRequest.KEY_PARAMS = "p";
SFS2X.Requests.System.ExtensionRequest.KEY_ROOM = "r";
SFS2X.Requests.System.LeaveRoomRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.LeaveRoom);
        this._room = a;
    },
    validate: function validate(a) {
        if (1 > a.getJoinedRooms().length) throw new SFS2X.Exceptions.SFSValidationError("LeaveRoomRequest Error", ["You are not joined in any room"]);
    },
    execute: function execute() {
        null != this._room && (this._reqObj[this.constructor.KEY_ROOM_ID] = this._room.id);
    }
});
SFS2X.Requests.System.LeaveRoomRequest.KEY_ROOM_ID = "r";
SFS2X.Requests.System.SubscribeRoomGroupRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.SubscribeRoomGroup);
        this._groupId = a;
    },
    validate: function validate() {
        var a = [];
        (null == this._groupId || 0 == this._groupId.length) && a.push("Invalid group id passed; must be a string with at least one character");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("SubscribeGroupRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_GROUP_ID] = this._groupId;
    }
});
SFS2X.Requests.System.SubscribeRoomGroupRequest.KEY_GROUP_ID = "g";
SFS2X.Requests.System.SubscribeRoomGroupRequest.KEY_ROOM_LIST = "rl";
SFS2X.Requests.System.UnsubscribeRoomGroupRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.UnsubscribeRoomGroup);
        this._groupId = a;
    },
    validate: function validate() {
        var a = [];
        (null == this._groupId || 0 == this._groupId.length) && a.push("Invalid group id passed; must be a string with at least one character");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("UnsubscribeGroupRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_GROUP_ID] = this._groupId;
    }
});
SFS2X.Requests.System.UnsubscribeRoomGroupRequest.KEY_GROUP_ID = "g";
SFS2X.Requests.System.SpectatorToPlayerRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.SpectatorToPlayer);
        this._room = a;
    },
    validate: function validate(a) {
        if (1 > a.getJoinedRooms().length) throw new SFS2X.Exceptions.SFSValidationError("SpectatorToPlayerRequest Error", ["You are not joined in any room"]);
    },
    execute: function execute(a) {
        null == this._room && (this._room = a.lastJoinedRoom);
        this._reqObj[this.constructor.KEY_ROOM_ID] = this._room.id;
    }
});
SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_ROOM_ID = "r";
SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_USER_ID = "u";
SFS2X.Requests.System.SpectatorToPlayerRequest.KEY_PLAYER_ID = "p";
SFS2X.Requests.System.PlayerToSpectatorRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.PlayerToSpectator);
        this._room = a;
    },
    validate: function validate(a) {
        if (1 > a.getJoinedRooms().length) throw new SFS2X.Exceptions.SFSValidationError("PlayerToSpectatorRequest Error", ["You are not joined in any room"]);
    },
    execute: function execute(a) {
        null == this._room && (this._room = a.lastJoinedRoom);
        this._reqObj[this.constructor.KEY_ROOM_ID] = this._room.id;
    }
});
SFS2X.Requests.System.PlayerToSpectatorRequest.KEY_ROOM_ID = "r";
SFS2X.Requests.System.PlayerToSpectatorRequest.KEY_USER_ID = "u";
SFS2X.Requests.System.ChangeRoomCapacityRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.ChangeRoomCapacity);
        this._room = a;
        this._newMaxUsers = b;
        this._newMaxSpect = c;
    },
    validate: function validate() {
        var a = [];
        null == this._room && a.push("Provided Room is null");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("ChangeRoomCapacityRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_ROOM] = this._room.id;
        this._reqObj[this.constructor.KEY_USER_SIZE] = this._newMaxUsers;
        this._reqObj[this.constructor.KEY_SPEC_SIZE] = this._newMaxSpect;
    }
});
SFS2X.Requests.System.ChangeRoomCapacityRequest.KEY_ROOM = "r";
SFS2X.Requests.System.ChangeRoomCapacityRequest.KEY_USER_SIZE = "u";
SFS2X.Requests.System.ChangeRoomCapacityRequest.KEY_SPEC_SIZE = "s";
SFS2X.Requests.System.PublicMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        this._type = SFS2X.Requests.GenericMessageType.PUBLIC_MSG;
        this._message = a;
        this._room = c;
        this._params = b;
    }
});
SFS2X.Requests.System.PrivateMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        this._type = SFS2X.Requests.GenericMessageType.PRIVATE_MSG;
        this._message = a;
        this._recipient = b;
        this._params = c;
    }
});
SFS2X.Requests.System.ModeratorMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        if (null == b) throw new SFS2X.Exceptions.SFSError("Recipient mode cannot be null");
        this._type = SFS2X.Requests.GenericMessageType.MODERATOR_MSG;
        this._message = a;
        this._params = c;
        this._recipient = b.target;
        this._sendMode = b.mode;
    }
});
SFS2X.Requests.System.AdminMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        if (null == b) throw new SFS2X.Exceptions.SFSError("Recipient mode cannot be null");
        this._type = SFS2X.Requests.GenericMessageType.ADMING_MSG;
        this._message = a;
        this._params = c;
        this._recipient = b.target;
        this._sendMode = b.mode;
    }
});
SFS2X.Requests.System.KickUserRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.KickUser);
        null == c && (c = 5);
        0 > c && (c = 0);
        this._userId = a;
        this._message = b;
        this._delay = c;
    },
    validate: function validate(a) {
        var b = [];
        !a.mySelf.isModerator() && !a.mySelf.isAdmin() && b.push("You don't have enough permissions to execute this request");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("KickUserRequest Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_USER_ID] = this._userId;
        this._reqObj[this.constructor.KEY_DELAY] = this._delay;
        null != this._message && 0 < this._message.length && (this._reqObj[this.constructor.KEY_MESSAGE] = this._message);
    }
});
SFS2X.Requests.System.KickUserRequest.KEY_USER_ID = "u";
SFS2X.Requests.System.KickUserRequest.KEY_MESSAGE = "m";
SFS2X.Requests.System.KickUserRequest.KEY_DELAY = "d";
SFS2X.Requests.System.BanUserRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c, d, e) {
        this._super(SFS2X.Requests.BanUser);
        null == c && (c = 1);
        null == d && (d = 5);
        null == e && (e = 24);
        this._userId = a;
        this._message = b;
        this._banMode = c;
        this._delay = d;
        this._durationHours = e;
    },
    validate: function validate(a) {
        var b = [];
        !a.mySelf.isModerator() && !a.mySelf.isAdmin() && b.push("You don't have enough permissions to execute this request");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("BanUserRequest Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_USER_ID] = this._userId;
        this._reqObj[this.constructor.KEY_DELAY] = this._delay;
        this._reqObj[this.constructor.KEY_BAN_MODE] = this._banMode;
        this._reqObj[this.constructor.KEY_BAN_DURATION_HOURS] = this._durationHours;
        null != this._message && 0 < this._message.length && (this._reqObj[this.constructor.KEY_MESSAGE] = this._message);
    }
});
SFS2X.Requests.System.BanUserRequest.KEY_USER_ID = "u";
SFS2X.Requests.System.BanUserRequest.KEY_MESSAGE = "m";
SFS2X.Requests.System.BanUserRequest.KEY_DELAY = "d";
SFS2X.Requests.System.BanUserRequest.KEY_BAN_MODE = "b";
SFS2X.Requests.System.BanUserRequest.KEY_BAN_DURATION_HOURS = "dh";
SFS2X.Requests.System.ManualDisconnectionRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init() {
        this._super(SFS2X.Requests.ManualDisconnection);
    },
    validate: function validate() {},
    execute: function execute() {}
});
SFS2X.Requests.System.FindRoomsRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.FindRooms);
        null == c && (c = 0);
        this._matchExpr = a;
        this._groupId = b;
        this._limit = c;
    },
    validate: function validate() {
        var a = [];
        null == this._matchExpr && a.push("Missing match expression");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("FindRoomsRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_EXPRESSION] = this._matchExpr._toArray();
        null != this._groupId && (this._reqObj[this.constructor.KEY_GROUP] = this._groupId);
        0 < this._limit && (this._reqObj[this.constructor.KEY_LIMIT] = this._limit);
    }
});
SFS2X.Requests.System.FindRoomsRequest.KEY_EXPRESSION = "e";
SFS2X.Requests.System.FindRoomsRequest.KEY_GROUP = "g";
SFS2X.Requests.System.FindRoomsRequest.KEY_LIMIT = "l";
SFS2X.Requests.System.FindRoomsRequest.KEY_FILTERED_ROOMS = "fr";
SFS2X.Requests.System.FindUsersRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.FindUsers);
        null == c && (c = 0);
        this._matchExpr = a;
        this._target = b;
        this._limit = c;
    },
    validate: function validate() {
        var a = [];
        null == this._matchExpr && a.push("Missing match expression");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("FindUsersRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_EXPRESSION] = this._matchExpr._toArray();
        null != this._target && (this._target instanceof SFS2X.Entities.SFSRoom ? this._reqObj[this.constructor.KEY_ROOM] = this._target.id : "string" == typeof this._target ? this._reqObj[this.constructor.KEY_GROUP] = this._target : this._log.warn("Unsupport target type for FindUsersRequest: " + this._target));
        0 < this._limit && (this._reqObj[this.constructor.KEY_LIMIT] = this._limit);
    }
});
SFS2X.Requests.System.FindUsersRequest.KEY_EXPRESSION = "e";
SFS2X.Requests.System.FindUsersRequest.KEY_GROUP = "g";
SFS2X.Requests.System.FindUsersRequest.KEY_ROOM = "r";
SFS2X.Requests.System.FindUsersRequest.KEY_LIMIT = "l";
SFS2X.Requests.System.FindUsersRequest.KEY_FILTERED_USERS = "fu";
SFS2X.Requests.System.PingPongRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init() {
        this._super(SFS2X.Requests.PingPong);
    },
    validate: function validate() {},
    execute: function execute() {}
});
SFS2X.Requests.MMO.SetUserPositionRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b) {
        this._super(SFS2X.Requests.SetUserPosition);
        this._pos = a;
        this._room = b;
    },
    validate: function validate(a) {
        var b = [];
        null == this._pos && b.push("Position must be a Vec3D instance");
        null == this._room && (this._room = a.lastJoinedRoom);
        this._room instanceof SFS2X.Entities.MMORoom || b.push("Passed Room is not an MMORoom");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("SetUserPosition Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_ROOM] = this._room.id;
        this._reqObj[this.constructor.KEY_VEC3D] = this._pos._toArray();
    }
});
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_ROOM = "r";
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_VEC3D = "v";
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_PLUS_USER_LIST = "p";
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_MINUS_USER_LIST = "m";
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_PLUS_ITEM_LIST = "q";
SFS2X.Requests.MMO.SetUserPositionRequest.KEY_MINUS_ITEM_LIST = "n";
SFS2X.Requests.MMO.SetMMOItemVariables = {};
SFS2X.Requests.MMO.SetMMOItemVariables.KEY_ROOM_ID = "r";
SFS2X.Requests.MMO.SetMMOItemVariables.KEY_ITEM_ID = "i";
SFS2X.Requests.MMO.SetMMOItemVariables.KEY_VAR_LIST = "v";
SFS2X.Requests.BuddyList.InitBuddyListRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init() {
        this._super(SFS2X.Requests.InitBuddyList);
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() && b.push("Buddy List is already initialized");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("InitBuddyListRequest Error", b);
    },
    execute: function execute() {}
});
SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_BLIST = "bl";
SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_BUDDY_STATES = "bs";
SFS2X.Requests.BuddyList.InitBuddyListRequest.KEY_MY_VARS = "mv";
SFS2X.Requests.BuddyList.AddBuddyRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.AddBuddy);
        this._name = a;
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        (null == this._name || 1 > this._name.length) && b.push("Invalid buddy name (null or empty string)");
        !1 == a.buddyManager.getMyOnlineState() && b.push("Can't add a buddy while you are offline in the Buddy List system");
        a = a.buddyManager.getBuddyByName(this._name);
        null != a && !a.isTemp() && b.push("Can't add buddy '" + this._name + "' because it is already in your list");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("AddBuddyRequest Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_BUDDY_NAME] = this._name;
    }
});
SFS2X.Requests.BuddyList.AddBuddyRequest.KEY_BUDDY_NAME = "bn";
SFS2X.Requests.BuddyList.BlockBuddyRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b) {
        this._super(SFS2X.Requests.BlockBuddy);
        this._name = a;
        this._blocked = b;
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        (null == this._name || 1 > this._name.length) && b.push("Invalid buddy name (null or empty string)");
        !1 == a.buddyManager.getMyOnlineState() && b.push("Can't block a buddy while you are offline in the Buddy List system");
        a = a.buddyManager.getBuddyByName(this._name);
        null == a ? b.push("Can't block buddy '" + this._name + "' because it isn't in your list") : a.isBlocked() == this._blocked && b.push("Block flag is already in the requested '" + this._blocked + "' state for buddy " + this._name);
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("BlockBuddyRequest Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_BUDDY_NAME] = this._name;
        this._reqObj[this.constructor.KEY_BUDDY_BLOCK_STATE] = this._blocked;
    }
});
SFS2X.Requests.BuddyList.BlockBuddyRequest.KEY_BUDDY_NAME = "bn";
SFS2X.Requests.BuddyList.BlockBuddyRequest.KEY_BUDDY_BLOCK_STATE = "bs";
SFS2X.Requests.BuddyList.RemoveBuddyRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.RemoveBuddy);
        this._name = a;
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        !1 == a.buddyManager.getMyOnlineState() && b.push("Can't remove a buddy while you are offline in the Buddy List system");
        a.buddyManager.containsBuddy(this._name) || b.push("Can't remove buddy '" + this._name + "' because it isn't in your list");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("RemoveBuddyRequest Error", b);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_BUDDY_NAME] = this._name;
    }
});
SFS2X.Requests.BuddyList.RemoveBuddyRequest.KEY_BUDDY_NAME = "bn";
SFS2X.Requests.BuddyList.SetBuddyVariablesRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.SetBuddyVariables);
        this._buddyVariables = a;
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        !1 == a.buddyManager.getMyOnlineState() && b.push("Can't set Buddy Variables while you are offline in the Buddy List system");
        (null == this._buddyVariables || 0 == this._buddyVariables.length) && b.push("No Buddy Variables to set have been specified");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("SetBuddyVariablesRequest Error", b);
    },
    execute: function execute() {
        var a = [],
            b;
        for (b in this._buddyVariables) {
            var c = this._buddyVariables[b];
            c instanceof SFS2X.Entities.Variables.SFSBuddyVariable && a.push(c.toArray());
        }
        this._reqObj[this.constructor.KEY_BUDDY_VARS] = a;
    }
});
SFS2X.Requests.BuddyList.SetBuddyVariablesRequest.KEY_BUDDY_NAME = "bn";
SFS2X.Requests.BuddyList.SetBuddyVariablesRequest.KEY_BUDDY_VARS = "bv";
SFS2X.Requests.BuddyList.GoOnlineRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.GoOnline);
        this._online = a;
    },
    validate: function validate(a) {
        var b = [];
        a.buddyManager.isInited() || b.push("Buddy List not yet initialized; please send an InitBuddyRequest first");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("GoOnlineRequest Error", b);
    },
    execute: function execute(a) {
        a.buddyManager._setMyOnlineState(this._online);
        this._reqObj[this.constructor.KEY_ONLINE] = this._online;
    }
});
SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_ONLINE = "o";
SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_BUDDY_NAME = "bn";
SFS2X.Requests.BuddyList.GoOnlineRequest.KEY_BUDDY_ID = "bi";
SFS2X.Requests.BuddyList.BuddyMessageRequest = SFS2X.Requests.System.GenericMessageRequest.extend({
    init: function init(a, b, c) {
        this._super();
        this._type = SFS2X.Requests.GenericMessageType.BUDDY_MSG;
        this._message = a;
        this._recipient = null != b ? b.id : -1;
        this._params = c;
    }
});
SFS2X.Requests.Game.InviteUsersRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.InviteUsers);
        this._invitedUsers = a;
        this._secondsForAnswer = b;
        this._params = c;
    },
    validate: function validate() {
        var a = [];
        (null == this._invitedUsers || 1 > this._invitedUsers.length) && a.push("No invitation(s) to send");
        this._invitedUsers.length > this.constructor.MAX_INVITATIONS_FROM_CLIENT_SIDE && a.push("Too many invitations; " + this.constructor.MAX_INVITATIONS_FROM_CLIENT_SIDE + " max are allowed from client side");
        (this._secondsForAnswer < this.constructor.MIN_EXPIRY_TIME || this._secondsForAnswer > this.constructor.MAX_EXPIRY_TIME) && a.push("secondsForAnswer value is out of range (min: " + this.constructor.MIN_EXPIRY_TIME + "; max: " + this.constructor.MAX_EXPIRY_TIME + ")");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("InviteUsersRequest Error", a);
    },
    execute: function execute(a) {
        var b = [],
            c;
        for (c in this._invitedUsers) {
            var d = this._invitedUsers[c];
            (d instanceof SFS2X.Entities.SFSUser || d instanceof SFS2X.Entities.SFSBuddy) && d != a.mySelf && b.push(d.id);
        }
        this._reqObj[this.constructor.KEY_INVITED_USERS] = b;
        this._reqObj[this.constructor.KEY_TIME] = this._secondsForAnswer;
        null != this._params && (this._reqObj[this.constructor.KEY_PARAMS] = this._params);
    }
});
SFS2X.Requests.Game.InviteUsersRequest.KEY_USER = "u";
SFS2X.Requests.Game.InviteUsersRequest.KEY_USER_ID = "ui";
SFS2X.Requests.Game.InviteUsersRequest.KEY_INVITATION_ID = "ii";
SFS2X.Requests.Game.InviteUsersRequest.KEY_TIME = "t";
SFS2X.Requests.Game.InviteUsersRequest.KEY_PARAMS = "p";
SFS2X.Requests.Game.InviteUsersRequest.KEY_INVITEE_ID = "ee";
SFS2X.Requests.Game.InviteUsersRequest.KEY_INVITED_USERS = "iu";
SFS2X.Requests.Game.InviteUsersRequest.KEY_REPLY_ID = "ri";
SFS2X.Requests.Game.InviteUsersRequest.MAX_INVITATIONS_FROM_CLIENT_SIDE = 8;
SFS2X.Requests.Game.InviteUsersRequest.MIN_EXPIRY_TIME = 5;
SFS2X.Requests.Game.InviteUsersRequest.MAX_EXPIRY_TIME = 300;
SFS2X.Requests.Game.InvitationReplyRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.InvitationReply);
        this._invitation = a;
        this._reply = b;
        this._params = c;
    },
    validate: function validate() {
        var a = [];
        null == this._invitation && a.push("Missing invitation object");
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("InvitationReplyRequest Error", a);
    },
    execute: function execute() {
        this._reqObj[this.constructor.KEY_INVITATION_ID] = this._invitation.id;
        this._reqObj[this.constructor.KEY_INVITATION_REPLY] = this._reply;
        null != this._params && (this._reqObj[this.constructor.KEY_INVITATION_PARAMS] = this._params);
    }
});
SFS2X.Requests.Game.InvitationReplyRequest.KEY_INVITATION_ID = "i";
SFS2X.Requests.Game.InvitationReplyRequest.KEY_INVITATION_REPLY = "r";
SFS2X.Requests.Game.InvitationReplyRequest.KEY_INVITATION_PARAMS = "p";
SFS2X.Requests.Game.CreateSFSGameRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a) {
        this._super(SFS2X.Requests.CreateSFSGame);
        this._settings = a;
        this._createRoomRequest = new SFS2X.Requests.System.CreateRoomRequest(a, !1, null);
    },
    validate: function validate(a) {
        var b = [];
        try {
            this._createRoomRequest.validate(a);
        } catch (c) {
            b = c.getErrors();
        }
        this._settings.minPlayersToStartGame > this._settings.maxUsers && b.push("Minimum number of players to start the game can't be greater than the Room's maximum number of users");
        (this._settings.invitationExpiryTime < SFS2X.Requests.Game.InviteUsersRequest.MIN_EXPIRY_TIME || this._settings.invitationExpiryTime > SFS2X.Requests.Game.InviteUsersRequest.MAX_EXPIRY_TIME) && b.push("Invitation expiration time value is out of range (min: " + SFS2X.Requests.Game.InviteUsersRequest.MIN_EXPIRY_TIME + "; max: " + SFS2X.Requests.Game.InviteUsersRequest.MAX_EXPIRY_TIME + ")");
        null != this._settings.invitedPlayers && this._settings.invitedPlayers.length > SFS2X.Requests.Game.InviteUsersRequest.MAX_INVITATIONS_FROM_CLIENT_SIDE && b.push("Can't invite more than " + SFS2X.Requests.Game.InviteUsersRequest.MAX_INVITATIONS_FROM_CLIENT_SIDE + " players from client side");
        if (0 < b.length) throw new SFS2X.Exceptions.SFSValidationError("CreateSFSGameRequest Error", b);
    },
    execute: function execute(a) {
        this._createRoomRequest.execute(a);
        this._reqObj = this._createRoomRequest._reqObj;
        this._reqObj[this.constructor.KEY_IS_PUBLIC] = this._settings.isPublic;
        this._reqObj[this.constructor.KEY_MIN_PLAYERS] = this._settings.minPlayersToStartGame;
        this._reqObj[this.constructor.KEY_INVITATION_EXPIRY] = this._settings.invitationExpiryTime;
        this._reqObj[this.constructor.KEY_LEAVE_ROOM] = this._settings.leaveLastJoinedRoom;
        this._reqObj[this.constructor.KEY_NOTIFY_GAME_STARTED] = this._settings.notifyGameStarted;
        null != this._settings.playerMatchExpression && (this._reqObj[this.constructor.KEY_PLAYER_MATCH_EXP] = this._settings.playerMatchExpression._toArray());
        null != this._settings.spectatorMatchExpression && (this._reqObj[this.constructor.KEY_SPECTATOR_MATCH_EXP] = this._settings.spectatorMatchExpression._toArray());
        if (null != this._settings.invitedPlayers) {
            var a = [],
                b;
            for (b in this._settings.invitedPlayers) {
                var c = this._settings.invitedPlayers[b];
                (c instanceof SFS2X.Entities.SFSUser || c instanceof SFS2X.Entities.SFSBuddy) && a.push(c.id);
            }
            this._reqObj[this.constructor.KEY_INVITED_PLAYERS] = a;
        }
        null != this._settings.searchableRooms && (this._reqObj[this.constructor.KEY_SEARCHABLE_ROOMS] = this._settings.searchableRooms);
        null != this._settings.invitationParams && (this._reqObj[this.constructor.KEY_INVITATION_PARAMS] = this._settings.invitationParams);
    }
});
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_IS_PUBLIC = "gip";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_MIN_PLAYERS = "gmp";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_INVITED_PLAYERS = "ginp";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_SEARCHABLE_ROOMS = "gsr";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_PLAYER_MATCH_EXP = "gpme";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_SPECTATOR_MATCH_EXP = "gsme";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_INVITATION_EXPIRY = "gie";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_LEAVE_ROOM = "glr";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_NOTIFY_GAME_STARTED = "gns";
SFS2X.Requests.Game.CreateSFSGameRequest.KEY_INVITATION_PARAMS = "ip";
SFS2X.Requests.Game.QuickJoinGameRequest = SFS2X.Requests._BaseRequest.extend({
    init: function init(a, b, c) {
        this._super(SFS2X.Requests.QuickJoinGame);
        this._matchExpression = a;
        this._whereToSearch = b;
        this._roomToLeave = c;
    },
    validate: function validate() {
        var a = [];
        null == this._whereToSearch || 1 > this._whereToSearch.length ? a.push("Missing lis of Rooms or Group name where to search the game to join") : this._whereToSearch.length > this.constructor.MAX_ROOMS && a.push("Too many Rooms specified in list where to search the game to join; client limit is: " + this.constructor.MAX_ROOMS);
        if (0 < a.length) throw new SFS2X.Exceptions.SFSValidationError("CreateSFSGameRequest Error", a);
    },
    execute: function execute() {
        if ("string" == typeof this._whereToSearch[0]) this._reqObj[this.constructor.KEY_GROUP_LIST] = this._whereToSearch;else if (this._whereToSearch[0] instanceof SFS2X.Entities.SFSRoom) {
            for (var a = [], b = 0; b < this._whereToSearch.length; b++) {
                var c = this._whereToSearch[b];
                c instanceof SFS2X.Entities.SFSRoom && a.push(c.id);
            }
            this._reqObj[this.constructor.KEY_ROOM_LIST] = a;
        } else throw new SFS2X.Exceptions.SFSError("Invalid type in whereToSearch parameter");
        null != this._roomToLeave && (this._reqObj[this.constructor.KEY_ROOM_TO_LEAVE] = this._roomToLeave.id);
        null != this._matchExpression && (this._reqObj[this.constructor.KEY_MATCH_EXPRESSION] = this._matchExpression._toArray());
    }
});
SFS2X.Requests.Game.QuickJoinGameRequest.KEY_ROOM_LIST = "rl";
SFS2X.Requests.Game.QuickJoinGameRequest.KEY_GROUP_LIST = "gl";
SFS2X.Requests.Game.QuickJoinGameRequest.KEY_ROOM_TO_LEAVE = "tl";
SFS2X.Requests.Game.QuickJoinGameRequest.KEY_MATCH_EXPRESSION = "me";
SFS2X.Requests.Game.QuickJoinGameRequest.MAX_ROOMS = 32;
SFS2X.Requests.Handshake = 0;
SFS2X.Requests.Login = 1;
SFS2X.Requests.Logout = 2;
SFS2X.Requests.JoinRoom = 4;
SFS2X.Requests.CreateRoom = 6;
SFS2X.Requests.GenericMessage = 7;
SFS2X.Requests.ChangeRoomName = 8;
SFS2X.Requests.ChangeRoomPassword = 9;
SFS2X.Requests.SetRoomVariables = 11;
SFS2X.Requests.SetUserVariables = 12;
SFS2X.Requests.CallExtension = 13;
SFS2X.Requests.LeaveRoom = 14;
SFS2X.Requests.SubscribeRoomGroup = 15;
SFS2X.Requests.UnsubscribeRoomGroup = 16;
SFS2X.Requests.SpectatorToPlayer = 17;
SFS2X.Requests.PlayerToSpectator = 18;
SFS2X.Requests.ChangeRoomCapacity = 19;
SFS2X.Requests.KickUser = 24;
SFS2X.Requests.BanUser = 25;
SFS2X.Requests.ManualDisconnection = 26;
SFS2X.Requests.FindRooms = 27;
SFS2X.Requests.FindUsers = 28;
SFS2X.Requests.PingPong = 29;
SFS2X.Requests.SetUserPosition = 30;
SFS2X.Requests.InitBuddyList = 200;
SFS2X.Requests.AddBuddy = 201;
SFS2X.Requests.BlockBuddy = 202;
SFS2X.Requests.RemoveBuddy = 203;
SFS2X.Requests.SetBuddyVariables = 204;
SFS2X.Requests.GoOnline = 205;
SFS2X.Requests.InviteUsers = 300;
SFS2X.Requests.InvitationReply = 301;
SFS2X.Requests.CreateSFSGame = 302;
SFS2X.Requests.QuickJoinGame = 303;
SFS2X.Requests.getRequestNameFromId = function (a) {
    for (var b in SFS2X.Requests) if (SFS2X.Requests[b] == a) return b;
    return null;
};
SFS2X.Requests.RoomSettings = Class.extend({
    init: function init(a) {
        this.name = a;
        this.password = "";
        this.groupId = "default";
        this.isGame = !1;
        this.maxUsers = 10;
        this.maxSpectators = 0;
        this.maxVariables = 5;
        this.variables = [];
        this.extension = this.events = this.permissions = null;
    }
});
SFS2X.Requests.Game.SFSGameSettings = SFS2X.Requests.RoomSettings.extend({
    init: function init(a) {
        this._super(a);
        this.isPublic = !0;
        this.minPlayersToStartGame = 2;
        this.searchableRooms = this.invitedPlayers = null;
        this.invitationExpiryTime = 15;
        this.leaveLastJoinedRoom = !0;
        this.notifyGameStarted = !1;
        this.invitationParams = this.spectatorMatchExpression = this.playerMatchExpression = null;
    }
});
SFS2X.Requests.MMO.MMORoomSettings = SFS2X.Requests.RoomSettings.extend({
    init: function init(a) {
        this._super(a);
        this.mapLimits = this.defaultAOI = null;
        this.userMaxLimboSeconds = 50;
        this.proximityListUpdateMillis = 250;
        this.sendAOIEntryPoint = !0;
    }
});
SFS2X.Requests.RoomPermissions = function () {
    this.allowPasswordStateChange = this.allowNameChange = !1;
    this.allowPublicMessages = !0;
    this.allowResizing = !1;
};
SFS2X.Requests.RoomEvents = function () {
    this.allowUserVariablesUpdate = this.allowUserExit = this.allowUserEnter = this.allowUserCountChange = !1;
};
SFS2X.Requests.RoomExtension = function (a, b) {
    this.id = a;
    this.className = b;
    this.propertiesFile = "";
};
SFS2X.Requests.MMO.MapLimits = function (a, b) {
    if (null == a || null == b) throw new SFS2X.Exceptions.SFSError("Map limits arguments must be both non null!");
    this.lowerLimit = a;
    this.higherLimit = b;
};
SFS2X.Requests.GenericMessageType = {};
SFS2X.Requests.GenericMessageType.PUBLIC_MSG = 0;
SFS2X.Requests.GenericMessageType.PRIVATE_MSG = 1;
SFS2X.Requests.GenericMessageType.MODERATOR_MSG = 2;
SFS2X.Requests.GenericMessageType.ADMING_MSG = 3;
SFS2X.Requests.GenericMessageType.OBJECT_MSG = 4;
SFS2X.Requests.GenericMessageType.BUDDY_MSG = 5;
SFS2X.Requests.MessageRecipientMode = function (a, b) {
    if (a < this.TO_USER || a > this.TO_ZONE) throw new SFS2X.Exceptions.SFSError("Illegal recipient mode: " + a);
    this.mode = a;
    this.target = b;
};
SFS2X.Requests.MessageRecipientMode.TO_USER = 0;
SFS2X.Requests.MessageRecipientMode.TO_ROOM = 1;
SFS2X.Requests.MessageRecipientMode.TO_GROUP = 2;
SFS2X.Requests.MessageRecipientMode.TO_ZONE = 3;
SFS2X.Requests.BanMode = {};
SFS2X.Requests.BanMode.BY_ADDRESS = 0;
SFS2X.Requests.BanMode.BY_NAME = 1;
SFS2X.SocketEngine = function (a) {
    this.isConnecting = this.isConnected = !1;
    this.reconnectionSeconds = 0;
    this._controllers = {};
    this._log = SFS2X.Logger;
    this._socket = null;
    this._maxMessageSize = 1E4;
    this._sfs = a;
    this._lastTcpPort = 0;
    this._reconnectionDelayMillis = 1E3;
    this._attemptingReconnection = this._isReconnecting = !1;
    this._eventDispatcher = new SFS2X.EventDispatcher();
    this._disconnectionReason = SFS2X.Utils.ClientDisconnectionReason.UNKNOWN;
};
SFS2X.SocketEngine.prototype.connect = function (a, b, c) {
    this.isConnected ? this._log.error("Connection is already active") : this.isConnecting ? this._log.error("A connection attempt is already in progress") : (this.isConnecting = !0, this._socket = new WebSocket("ws" + (c ? "s" : "") + "://" + a + ":" + b + "/websocket"), this._socket._scope = this, this._socket.onopen = this._onSocketConnect, this._socket.onclose = this._onSocketDisconnect, this._socket.onmessage = this._onSocketData, this._socket.onerror = this._onSocketError);
};
SFS2X.SocketEngine.prototype.disconnect = function (a) {
    this._disconnectionReason = a;
    this._socket.close();
};
SFS2X.SocketEngine.prototype.addEventListener = function (a, b, c) {
    this._eventDispatcher.addEventListener(a, b, c);
};
SFS2X.SocketEngine.prototype.removeEventListener = function (a, b) {
    this._eventDispatcher.removeEventListener(a, b);
};
SFS2X.SocketEngine.prototype.addController = function (a, b) {
    null == this._controllers[a] && (this._controllers[a] = b);
};
SFS2X.SocketEngine.prototype.removeController = function (a) {
    delete this._controllers[a];
};
SFS2X.SocketEngine.prototype.send = function (a) {
    a = this._encodeMessage(a);
    this._socket.send(a);
};
SFS2X.SocketEngine.prototype._decodeMessage = function (a) {
    return JSON.parse(a);
};
SFS2X.SocketEngine.prototype._encodeMessage = function (a) {
    return JSON.stringify(a);
};
SFS2X.SocketEngine.prototype._onSocketConnect = function () {
    this._scope.isConnected = !0;
    this._scope.isConnecting = !1;
    this._scope._log.debug("SOCKET CONNECTION OK");
    this._scope._eventDispatcher.dispatchEvent(SFS2X.SocketEvent.CONNECT, {
        success: !0,
        isReconnection: this._scope._attemptingReconnection
    });
};
SFS2X.SocketEngine.prototype._onSocketDisconnect = function () {
    this._scope.isConnected = !1;
    if (this._scope.isConnecting) {
        this._scope.isConnecting = !1;
        var a = {
            success: !1,
            isReconnection: this._scope._attemptingReconnection
        };
        this._scope._eventDispatcher.dispatchEvent(SFS2X.SocketEvent.CONNECT, a);
    } else a = {
        reason: this._scope._disconnectionReason
    }, this._scope._eventDispatcher.dispatchEvent(SFS2X.SocketEvent.DISCONNECT, a), this._scope._disconnectionReason = SFS2X.Utils.ClientDisconnectionReason.UNKNOWN;
};
SFS2X.SocketEngine.prototype._onSocketData = function (a) {
    this._scope._eventDispatcher.dispatchEvent(SFS2X.SocketEvent.DATA, this._scope._decodeMessage(a.data));
};
SFS2X.SocketEngine.prototype._onSocketError = function (a) {
    this._scope._eventDispatcher.dispatchEvent(SFS2X.SocketEvent.IOERROR, a.data);
};
SFS2X.SocketEvent = {
    CONNECT: "socketConnect",
    DISCONNECT: "socketDisconnect",
    DATA: "data",
    IOERROR: "socketIOError"
};
// modularize
module.exports = SFS2X;

cc._RFpop();
},{}],"SamConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '35794TQ611JOpMeZnHu/xYx', 'SamConstant');
// scripts\games\sam\SamConstant.js

module.exports = {

    Action: {
        DISCARD: 0,
        IGNORE: 1,
        ORDER_HANDS: 2,
        CHAT_HANG: 3,
        BAO_SAM: 4,
        WAITING_BAO_SAM: 5,
        BAO: 6,
        HUY_BAO_SAM: 7,
        DEN_LANG: 17
    },

    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        BAO_SAM: 4,
        PLAYING: 5,
        FINALIZING: 6,
        FINISH: 7
    },

    GameStateTLMN: {
        NONE: 0,
        WAITING_FOR_PLAYER: 'waitingForPlayer',
        WAITING_FOR_NEW_GAME: 'waitingDealing',
        PLAYING: 'playing',
        FINALIZING: 'finalizing',
        FINISH: 'finish'
    },

    PlayerState: {
        WAITING: 0,
        READY: 1,
        IN_TURN: 2,
        OUT_TURN: 3,
        WAITING_FOR_TURN: 4,
        FINISH: 5
    },

    ActionFinishType: {
        THANG_TRANG: 0,
        THUA_DEM_LA: 13,
        SAM_THANH_CONG: 16,
        SAM_THAT_BAI: 17,
        DEN_LANG_THOI_HAI: 18
    },

    Event: {
        FINISH_GAME: 'in_game.sam.finish_game',
        UPDATE_GAME: 'in_game.sam.update_game',
        UPDATE_HAND: 'in_game.sam.update_hand',
        WAITING_DEAL_CARD: 'in_game.sam.waiting_deal_card',
        WAITING_FOR_PLAYER: 'in_game.sam.waiting_for_player',
        TURN: 'in_game.sam.turn',
        DISCARD: 'in_game.sam.discard',
        REFRESH_GAME: 'in_game.sam.refresh_game',
        CHAT_HANG: 'in_game.sam.chag_hang',
        WAITING_BAO_SAM: 'in_game.sam.bao_sam',
        PLAYER_BAO_SAM: 'in_game.sam.player_bao_sam',
        PLAYER_BAO_MOT: 'in_game.sam.player_bao_mot',
        PLAYER_HUY_BAO_SAM: 'in_game.sam.huy_bao_sam'
    },

    TimeoutId: {
        DISCARD_MUSIC: 'TIMEOUT_DISCARD_MUSIC',
        BOLUOT_ANIMATION: 'TIMEOUT_BOLUOT_ANIMATION',
        CHANGE_TURN: 'TIMEOUT_CHANGE_TURN'
    },

    Effect: {
        THUA_CONG: 0,
        THANG_TRANG: 1,
        CHAN_SAM: 2,
        BAO_SAM: 3,
        BAO: 4,
        DEN_LANG: 5,
        DEN_TRANG: 6,
        HUY_BAO_SAM: 7,
        SAM_THAT_BAI: 8,
        SAM_THANH_CONG: 9,
        DANG_DOI: 10,
        HET_LUOT: 11
    }
};

cc._RFpop();
},{}],"SamGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3b56dlTZ9JOv5IqqCQHmfNW', 'SamGameManager');
// scripts\games\sam\SamGameManager.js

var BaseGameManager = require('BaseGameManager'),
    Utils = require('Utils'),
    SamConstant = require('SamConstant'),
    NetworkManager = require('NetworkManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    SamGameManager;
SamGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);
        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_HAND.ID, this.onUpdateHand, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaitingDealCard, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_PLAYER_ADDED.ID, this.onWaitingForPlayer, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.TURN.ID, this.onTurn, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onRefreshGame, this);

        // các action của game play
        this.eventDispatchers.playCmd.addEventListener(SamConstant.Action.WAITING_BAO_SAM, this.onWaitingBaoSam, this);
        this.eventDispatchers.playCmd.addEventListener(SamConstant.Action.CHAT_HANG, this.onChatHang, this);
        this.eventDispatchers.playCmd.addEventListener(SamConstant.Action.BAO_SAM, this.onBaoSam, this);
        this.eventDispatchers.playCmd.addEventListener(SamConstant.Action.BAO, this.onBaoMot, this);
        this.eventDispatchers.playCmd.addEventListener(SamConstant.Action.HUY_BAO_SAM, this.onHuyBaoSam, this);
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.onRefreshGame(params);
    },

    onWaitingBaoSam: function onWaitingBaoSam(params) {
        this.gameState = SamConstant.GameState.BAO_SAM;
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.WAITING_BAO_SAM, params);
    },

    onFinishGame: function onFinishGame(params) {
        this.gameState = SamConstant.GameState.FINISH;
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.FINISH_GAME, params);
    },

    onUpdateHand: function onUpdateHand(params) {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.UPDATE_HAND, params);
    },

    onWaitingForPlayer: function onWaitingForPlayer() {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.WAITING_FOR_PLAYER);
    },

    onWaitingDealCard: function onWaitingDealCard(params) {
        this.gameState = SamConstant.GameState.WAITING_FOR_NEW_GAME;
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.WAITING_DEAL_CARD, params);
    },

    onTurn: function onTurn(params) {
        this.gameState = SamConstant.GameState.PLAYING;
        if (params.lastPlayer) {
            if (params.cards) {
                this.eventDispatchers.local.dispatchEvent(SamConstant.Event.DISCARD, { cards: params.data.cards, userName: params.data.lastPlayer.userName });
            }
            if (params.toPlayer) {
                this.eventDispatchers.local.dispatchEvent(SamConstant.Event.TURN, { userName: params.data.toPlayer.userName, wait: 1, newTurn: params.data.newTurn, timeTurn: params.data.time });
            }
        } else {
            if (params.toPlayer) {
                this.eventDispatchers.local.dispatchEvent(SamConstant.Event.TURN, { userName: params.data.toPlayer.userName, wait: 0, newTurn: params.data.newTurn, timeTurn: params.data.time });
            }
        }
    },

    onChatHang: function onChatHang(params) {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.CHAT_HANG, params);
    },

    onBaoSam: function onBaoSam(params) {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.PLAYER_BAO_SAM, params.data.userName);
    },

    onBaoMot: function onBaoMot(params) {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.PLAYER_BAO_MOT, params.data.userName);
    },

    onHuyBaoSam: function onHuyBaoSam() {
        this.eventDispatchers.local.dispatchEvent(SamConstant.Event.PLAYER_HUY_BAO_SAM);
    },

    onRefreshGame: function onRefreshGame(params) {
        this.gameState = params.allData.gameState;
        switch (params.allData.gameState) {
            case SamConstant.GameState.WAITING_FOR_PLAYER:
                this.onWaitingForPlayer();
                break;
            case SamConstant.GameState.WAITING_FOR_NEW_GAME:
                this.onWaitingDealCard(params);
                break;
            case SamConstant.GameState.BAO_SAM:
                this.onWaitingBaoSam(params);
                this.onUpdateHand(params);
                break;
            case SamConstant.GameState.PLAYING:
                this.onTurn(params);
                this.onUpdateHand(params);
                if (params.data.trash) {
                    this.eventDispatchers.local.dispatchEvent(SamConstant.Event.REFRESH_GAME, params);
                }
                break;
            case SamConstant.GameState.FINALIZING:

                break;
            case SamConstant.GameState.FINISH:

                break;
        }
    },

    // ============================================================
    // Request API
    // ============================================================
    sendRequestStartGame: function sendRequestStartGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.DEAL_CARD.ID)
        });
    },

    sendRequestDiscard: function sendRequestDiscard(cards) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(SamConstant.Action.DISCARD),
            cards: NetworkManager.SmartFox.type.byteArray(cards)
        });
    },

    sendRequestBaoSam: function sendRequestBaoSam() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(SamConstant.Action.BAO_SAM)
        });
    },

    sendRequestBoQuaBaoSam: function sendRequestBoQuaBaoSam() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(SamConstant.Action.HUY_BAO_SAM)
        });
    }
});

module.exports = SamGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SamConstant":"SamConstant","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils"}],"SanThuongConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4de15e3dR1MVpCEDYHgcZA7', 'SanThuongConstant');
// scripts\games\san_thuong\SanThuongConstant.js

var Utils = require('Utils');

module.exports = {
    Action: {
        START_GAME: 0,
        BETTING: 1,
        ONPEN_HOP: 2,
        TURN_MASTER: 3,
        MASTER_SELL_POT: 4,
        TURN_START: 5,
        UPDATE_CHICKEN_JAR: 6,
        UPDATE_POTS: 9,
        PING: 10
    },
    GameState: {
        NONE: 0,
        EFFECT: 1,
        OPEN_HOP: 4,
        FINALIZING: 5
    },
    AwardType: {
        NONE: 0,
        MONEY: 1,
        FREE_PLAY: 2,
        HOPQUA: 3,
        MA_DU_THUONG: 4
    },
    ChipColor: {
        BLUE: {
            ID: 0,
            NAME: 'blue'
        },

        PURPLE: {
            ID: 1,
            NAME: 'purple'
        },

        GREEN: {
            ID: 2,
            NAME: 'green'
        },

        RED: {
            ID: 3,
            NAME: 'red'
        },

        findById: function findById(potId) {
            potId = parseInt(potId, 10);
            return Utils.Object.findObject(this, 'ID', potId);
        }
    },
    Event: {
        TURN_START: 'in_game.san_thuong.turn_start',
        EFFECT_STATE: 'in_game.san_thuong.change_state.effect',
        PLAYER_BETTING_STATE: 'in_game.san_thuong.change_state.player_betting',
        UPDATE_POTS: 'in_game.san_thuong.update_pots',
        FINISH: 'in_game.san_thuong.finish',
        SELECT_CHIP: 'in_game.san_thuong.select_chip',
        ADD_LIST_BETTING: 'in_game.san_thuong.add_list_betting',
        SET_RATIO: 'in_game.san_thuong.set_ratio',
        BETTING_UPDATEGAME: 'in_game.san_thuong.betting_updategame',
        UPDATE_CHICKEN_JAR: 'in_game.san_thuong.update_chicken_rar',
        CLEAR_FINISH: 'in_game.san_thuong.clear_finish',
        SHOW_PANEL_DAPHOP: 'in_game.san_thuong.show_panel_daphop',
        OPEN_HOP: 'in_game.san_thuong.open_hop',
        SET_RULE: 'in_game.san_thuong.set_rule',
        CHICKEN_CODE: 'in_game.san_thuong.checken_code'
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"SanThuongGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0d935R2kUxHiYghlzIYL2By', 'SanThuongGameManager');
// scripts\games\san_thuong\SanThuongGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    SanThuongConstant = require('SanThuongConstant'),
    Url = require('Url'),
    SanThuongGameManager;

SanThuongGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(gameCmd, roomId, logEnabled) {
        this.$super.constructor.call(this, gameCmd, roomId, logEnabled, true);

        this.DELAYED_COMMANDS = [SmartFoxConstant.Command.MESSAGE.ID, SmartFoxConstant.Command.DEAL_CARD.ID, SmartFoxConstant.Command.TURN.ID, SmartFoxConstant.Command.WAITING_DEAL_CARD.ID];

        this.lstHistory = [];
        this.countFreePlay = this.countOpenHopQua = this.countMoney = this.countMaDuThuong = this.countLucky = 0;
        this.stringKetQua = '';
        this.itemHistoryTmp = [];
        this.isOpenHop = false;
        this.autoPlay = false;
        this.currency = 'PI';
        this.countFreePlay = 0;

        this.lstPiBetting = [];
        this.lstXuBetting = [];
        this.moneyChickenXu = 0;
        this.moneyChickenPi = 0;
        this.moneyBet = 0;

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(SanThuongConstant.Action.TURN_START, this.onStartGame, this);
        this.eventDispatchers.playCmd.addEventListener(SanThuongConstant.Action.ONPEN_HOP, this.onOpenHop, this);

        this.eventDispatchers.globalCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateChickenJar, this);
    },

    sendOpenPopupMaDuThuong: function sendOpenPopupMaDuThuong() {
        var self = this,
            listDate = '',
            currentDate = new Date();
        for (var i = 0; i < 7; i += 1) {

            if (listDate.length > 0) {
                currentDate.setDate(currentDate.getDate() - 1);
                listDate += ',' + Utils.Date.format(currentDate, 'yyyy-mm-dd');
            } else {
                currentDate.setDate(currentDate.getDate());
                listDate += Utils.Date.format(currentDate, 'yyyy-mm-dd');
            }
        }
        NetworkManager.Http.fetch('GET', Url.Http.CHICKEN_CODE, {
            username: AuthUser.username,
            date_list: listDate
        }).success(function (tnResp) {
            self.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.CHICKEN_CODE, tnResp.data);
        });
    },

    sendOpentHop: function sendOpentHop(id) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(SanThuongConstant.Action.ONPEN_HOP),
            id: NetworkManager.SmartFox.type.byte(id)
        });
    },

    sendGetChickenJar: function sendGetChickenJar() {
        var self = this;
        NetworkManager.Http.fetch('GET', Url.Http.CHICKENJAR, {}, {
            cache: 900
        }).success(function (respDone) {
            self.moneyChickenXu = respDone.data.XU;
            self.moneyChickenPi = respDone.data.IP;
            self.onUpdateChickenJar();
        });
    },

    sendStartGame: function sendStartGame(autoPlay, moneyBet, pots, currency) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(SanThuongConstant.Action.START_GAME),
            betting: NetworkManager.SmartFox.type.long(moneyBet),
            pots: NetworkManager.SmartFox.type.byteArray(pots),
            currency: NetworkManager.SmartFox.type.utfString(currency)
        });
        if (currency === 'IP') {
            currency = 'PI';
        }
        this.currency = currency;
        this.moneyBet = pots.length * moneyBet;
        this.autoPlay = autoPlay;
    },

    _setHistoryOpenHop: function _setHistoryOpenHop() {
        if (this.isOpenHop) {
            this.itemHistoryTmp.push(Utils.Date.format(Date(), 'hh:MM:ss'));
            this.itemHistoryTmp.push('MỞ HỘP');
            this.itemHistoryTmp.push(' ');
            if (this.countLucky > 0) {
                this.stringKetQua += this.countLucky + ' chúc may mắn, ';
            }
            if (this.countOpenHopQua > 0) {
                this.stringKetQua += this.countOpenHopQua + ' hộp quà, ';
            }
            if (this.countMoney > 0) {
                this.stringKetQua += this.countMoney + ' lần tiền cược, ';
            }
            if (this.countFreePlay > 0) {
                this.stringKetQua += this.countFreePlay + ' lần quay miễn phí, ';
            }
            if (this.countMaDuThuong > 0) {
                this.stringKetQua += this.countMaDuThuong + ' mã dự thưởng ';
            }
            this.itemHistoryTmp.push(' ');
            this.itemHistoryTmp.push(this.stringKetQua.substring(0, this.stringKetQua.length - 2));
            this.stringKetQua = '';
            this.isOpenHop = false;
            this.lstHistory.unshift(this.itemHistoryTmp);
            if (this.lstHistory.length > 100) {
                this.lstHistory.pop();
            }
        }
    },

    onOpenHop: function onOpenHop(params) {
        //{summary: Object, results: Array[1], action: 2, command: 20}
        this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.OPEN_HOP, params);
        this.isOpenHop = true;
        for (var i = 0; i < params.results.length; i += 1) {
            switch (params.results[i].awardType) {
                case SanThuongConstant.AwardType.NONE:
                    this.countLucky += 1;
                    break;
                case SanThuongConstant.AwardType.HOPQUA:
                    this.countOpenHopQua += params.results[i].ratio;
                    break;
                case SanThuongConstant.AwardType.MONEY:
                    this.countMoney += params.results[i].ratio;
                    break;
                case SanThuongConstant.AwardType.FREE_PLAY:
                    this.countFreePlay += params.results[i].ratio;
                    break;
                case SanThuongConstant.AwardType.MA_DU_THUONG:
                    this.countMaDuThuong += params.results[i].ratio;
                    break;
            }
        }
    },

    onUpdateChickenJar: function onUpdateChickenJar(params) {
        //{money: 95551, action: 6, command: 25, currency: "IP"}
        if (params) {
            if (params.currency === 'IP') {
                this.moneyChickenPi = params.money;
            } else {
                this.moneyChickenXu = params.money;
            }
        }
        this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.UPDATE_CHICKEN_JAR);
    },

    onFinishGame: function onFinishGame(params) {
        var countFreePlay = 0,
            countOpenHopQua = 0,
            countMoney = 0,
            countMaDuThuong = 0,
            stringKetQua = '',
            itemHistoryTmp = [];
        this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.FINISH, params);
        itemHistoryTmp.push(Utils.Date.format(Date(), 'hh:MM:ss'));
        if (this.autoPlay) {
            if (this.countFreePlay > 0) {
                itemHistoryTmp.push('QUAY MIỄN PHÍ');
            } else {
                itemHistoryTmp.push('TỰ QUAY');
            }
        } else {
            if (this.countFreePlay > 0) {
                itemHistoryTmp.push('QUAY MIỄN PHÍ');
            } else {
                itemHistoryTmp.push('QUAY');
            }
        }
        if (this.countFreePlay <= 0) {
            itemHistoryTmp.push(Utils.Number.format(this.moneyBet) + ' ' + this.currency);
        } else {
            itemHistoryTmp.push(' ');
            this.countFreePlay -= 1;
        }
        for (var i = 0; i < params.awards.length; i += 1) {
            switch (params.awards[i].awardType) {
                case SanThuongConstant.AwardType.NONE:
                    break;
                case SanThuongConstant.AwardType.HOPQUA:
                    countOpenHopQua += params.awards[i].ratio;
                    break;
                case SanThuongConstant.AwardType.MONEY:
                    countMoney += params.awards[i].ratio;
                    break;
                case SanThuongConstant.AwardType.FREE_PLAY:
                    countFreePlay += params.awards[i].ratio;
                    break;
                case SanThuongConstant.AwardType.MA_DU_THUONG:
                    countMaDuThuong += params.awards[i].ratio;
                    break;
            }
        }

        if (countOpenHopQua > 0) {
            stringKetQua += countOpenHopQua + ' hộp quà, ';
        }
        if (countMoney > 0) {
            stringKetQua += countMoney + ' lần tiền cược, ';
        }
        if (countFreePlay > 0) {
            stringKetQua += countFreePlay + ' lần quay miễn phí, ';
            this.countFreePlay += countFreePlay;
        }
        if (countMaDuThuong > 0) {
            stringKetQua += countMaDuThuong + ' mã dự thưởng ';
        }
        itemHistoryTmp.push(Utils.Number.format(params.player.moneyExchange) + ' ' + this.currency);
        itemHistoryTmp.push(stringKetQua.substring(0, stringKetQua.length - 2));
        this.lstHistory.unshift(itemHistoryTmp);
        if (this.lstHistory.length > 100) {
            this.lstHistory.pop();
        }
    },

    onStartGame: function onStartGame(params) {
        this._setGameState(params.gameState);
        switch (params.gameState) {
            case SanThuongConstant.GameState.EFFECT:
                // if (this.countFreePlay > 0) {
                //     this.countFreePlay -= 1;
                // }
                this.countOpenHopQua = this.countMoney = this.countMaDuThuong = this.countLucky = 0;
                this.stringKetQua = '';
                this.itemHistoryTmp = [];
                this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.TURN_START, params.result);
                break;
            case SanThuongConstant.GameState.NONE:
                this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.CLEAR_FINISH);
                this._setHistoryOpenHop();
                break;
            case SanThuongConstant.GameState.OPEN_HOP:
                this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.SHOW_PANEL_DAPHOP);
                break;

        }
    },

    onUpdateGame: function onUpdateGame(params) {
        this._updateListBetting(params.bettingValues);
        this._showRulePot(params.itemsInfo);
    },

    _showRulePot: function _showRulePot(params) {
        this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.SET_RULE, params);
    },

    _updateListBetting: function _updateListBetting(params) {
        this.lstXuBetting = params.XU;
        this.lstPiBetting = params.IP;
        this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.ADD_LIST_BETTING, this.lstPiBetting);
    },

    _setGameState: function _setGameState(newGameState) {

        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            this.eventDispatchers.local.dispatchEvent(SanThuongConstant.Event.CHANGE_STATE);
        }
    }
});

module.exports = SanThuongGameManager;

cc._RFpop();
},{"AuthUser":"AuthUser","BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SanThuongConstant":"SanThuongConstant","SmartFoxConstant":"SmartFoxConstant","Url":"Url","Utils":"Utils"}],"Settings":[function(require,module,exports){
"use strict";
cc._RFpush(module, '96f4fn2L0pOypNhfixqdzjw', 'Settings');
// scripts\components\Settings.js

var Url = require('Url'),
    UiManager = require('UiManager'),
    AudioManager = require('AudioManager'),
    NetworkManager = require('NetworkManager'),
    PlatformImplement = require('PlatformImplement'),
    ToggleButton = require('ToggleButton');

cc.Class({
    'extends': cc.Component,

    properties: {
        hotlineLabel: cc.Label,

        backgroundMusicToggleButton: ToggleButton,
        soundEffectToggleButton: ToggleButton
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.fetchContactInfo();

        this.backgroundMusicToggleButton.isEnable = AudioManager.instance.getMusicVolume() === 1;
        this.soundEffectToggleButton.isEnable = AudioManager.instance.getEffectsVolume() === 1;
    },

    toggleBackgroundMusic: function toggleBackgroundMusic(toggleButton) {
        var volume = toggleButton.isEnable ? 1 : 0;
        AudioManager.instance.setMusicVolume(volume);
    },

    toggleSoundEffect: function toggleSoundEffect(toggleButton) {
        var volume = toggleButton.isEnable ? 1 : 0;
        AudioManager.instance.setEffectsVolume(volume);
    },

    updateMusicVolume: function updateMusicVolume(slideComponent) {
        cc.audioEngine.setMusicVolume(slideComponent.currentValue / 100);
    },

    fetchContactInfo: function fetchContactInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.CONTACT_INFO, {}, {
            cache: 1800
        }).success(function (respContact) {
            that.contactInfo = respContact.data;
            that.hotlineLabel.string = respContact.data.mobile;
        });
    },

    callHotline: function callHotline() {
        if (this.contactInfo) {
            PlatformImplement.callNumberPhone(this.contactInfo.mobile);
        }
    },

    logout: function logout() {
        UiManager.openConfirmModal('Bạn có chắc muốn thoát khỏi game không?', {
            oke_fn: function oke_fn() {
                PlatformImplement.logoutUser();
                NetworkManager.SmartFox.disconnect();
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AudioManager":"AudioManager","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","ToggleButton":"ToggleButton","UiManager":"UiManager","Url":"Url"}],"Slider":[function(require,module,exports){
"use strict";
cc._RFpush(module, '96876PXspBPBaUem0ZBQVkv', 'Slider');
// scripts\ui\Slider.js

var Utils = require('Utils');

cc.Class({
    'extends': cc.Component,

    properties: {
        progressBar: cc.ProgressBar,
        addButton: cc.Button,
        subButton: cc.Button,
        slideNode: cc.Node,
        backdropNode: cc.Node,
        minValueLabel: cc.Label,
        maxValueLabel: cc.Label,
        currentValueLabel: cc.Label,
        rounding: 1,
        rate: 0.01,
        isVertical: true,
        slideEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {

        var self = this;
        if (this.backdropNode) {
            this.backdropNode.on(cc.Node.EventType.TOUCH_START, function () {
                self.node.active = false;
            });
        }

        this.addButton.node.on(cc.Node.EventType.TOUCH_START, function () {
            var check = 1 - self.progressBar.progress;
            if (check > 0) {
                check = self.rate;
            }
            self.progressBar.progress += check;
            self.slideNode.y += self.progressBar.node.height * check;
            self.setCurrentValue();
        });

        this.subButton.node.on(cc.Node.EventType.TOUCH_START, function () {
            var check = 1 - self.progressBar.progress;
            if (check < 1) {
                check = self.rate;
            } else {
                check = self.progressBar.progress;
            }
            self.progressBar.progress -= check;
            self.slideNode.y -= self.progressBar.node.height * check;
            self.setCurrentValue();
        });

        this.slideNode.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
            var check;
            if (self.isVertical) {
                check = event.getDelta().y / self.progressBar.node.height;
            } else {
                check = event.getDelta().x / self.progressBar.node.height;
            }
            var preProgressBar = self.progressBar.progress;
            self.progressBar.progress += check;
            if (self.progressBar.progress > 1) {
                self.progressBar.progress = 1;
            } else if (self.progressBar.progress < 0) {
                self.progressBar.progress = 0;
            }
            this.y += self.progressBar.node.height * (self.progressBar.progress - preProgressBar);
            self.setCurrentValue();
        });
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    setDefaultValue: function setDefaultValue(minValue, maxValue, defaultProgress, betting) {
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.totalValue = maxValue - minValue;

        if (betting) {
            this.rate = betting / this.totalValue;
            this.rounding = betting;
        }
        if (this.minValueLabel) {
            this.minValueLabel.string = Utils.Number.format(minValue);
        }
        if (this.maxValueLabel) {
            this.maxValueLabel.string = Utils.Number.format(maxValue);
        }
        this.progressBar.progress = defaultProgress;
        this.slideNode.y = this.progressBar.node.y - this.progressBar.node.height / 2 + this.progressBar.node.height * defaultProgress;
        this.setCurrentValue();
    },

    setCurrentValue: function setCurrentValue() {
        this.currentValue = Math.floor(this.progressBar.progress * this.totalValue + this.minValue);
        if (this.currentValue > this.rounding) {
            this.currentValue = Math.ceil(this.currentValue / this.rounding) * this.rounding;
        }
        if (this.currentValue > this.maxValue) {
            this.currentValue = this.maxValue;
        } else if (this.currentValue < this.minValue) {
            this.currentValue = this.minValue;
        }
        this.currentValueLabel.string = Utils.Number.format(this.currentValue);
        for (var i = 0; i < this.slideEvents.length; i += 1) {
            this.slideEvents[i].emit([this]);
        }
    }
});

cc._RFpop();
},{"Utils":"Utils"}],"SlotInfor":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8e1baa70GBPwopzIB903jR5', 'SlotInfor');
// scripts\components\games\ui\SlotInfor.js

var BaseMainGameplay = require('BaseMainGameplay'),
    AuthUser = require('AuthUser'),
    Utils = require('Utils'),
    BauCuaConstant = require('BauCuaConstant'),
    XocDiaConstant = require('XocDiaConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        myMoneyLabel: cc.Label,
        totallMoneyLabel: cc.Label,
        ratioLabel: cc.Label,
        hieuUngThangSprite: cc.Sprite,
        sceneScript: BaseMainGameplay,
        pot: 0,
        btnCancelBet: cc.Sprite
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!this.chipFackeList) {
            this.init();
        }
    },

    init: function init() {
        if (!this.chipFackeList) {
            this.potX0 = this.potX1 = this.potX2 = this.potX3 = 0;
            this.playerBetList = {};
            this.chipFackeList = [];
            this.tmpCountChipList = [];
            this.countChipList = [];
            this.isWin = false;
            this.totallMoneyLong = 0;
            this.myMoneyLong = 0;
            var self = this;
            this.node.on(cc.Node.EventType.TOUCH_START, function () {
                if (this.sceneScript.gameManager.gameState === BauCuaConstant.GameState.PLAYER_BETTING || this.sceneScript.gameManager.gameState === XocDiaConstant.GameState.PLAYER_BETTING) {
                    self.bet();
                } else if (this.sceneScript.gameManager.gameState === BauCuaConstant.GameState.MASTER_CANEL_BET || this.sceneScript.gameManager.gameState === XocDiaConstant.GameState.MASTER_CANEL_BET) {
                    this.sellBetCancelBet();
                }
            }, this);
            this.setMoneyPot(0, 0);
        }
    },

    activeCancelPotXocDia: function activeCancelPotXocDia(isCancel) {
        if (this.btnCancelBet) {
            this.btnCancelBet.node.active = isCancel;
        }
    },

    activeSellPotBauCua: function activeSellPotBauCua(isSell) {
        if (isSell) {
            this.myMoneyLabel.node.color = new cc.color('#FFEB00');
            this.myMoneyLabel.string = 'BÁN';
        } else {
            this.myMoneyLabel.node.color = new cc.color('#FFFFFF');
            this.myMoneyLabel.string = Utils.Number.abbreviate(this.myMoneyLong);
        }
    },

    sellBetCancelBet: function sellBetCancelBet() {
        this.sceneScript.gameManager.sellBetCancelBet(this.pot);
    },

    bet: function bet() {
        this.sceneScript.gameManager.sendBet(this.pot, this.sceneScript.moneyBetSelect);
    },

    setRatioPot: function setRatioPot(ratio) {
        if (this.ratioLabel) {
            this.ratioLabel.string = '(1x' + ratio + ')';
        }
    },

    setMoneyPot: function setMoneyPot(myMoney, moneyBet) {
        this.totallMoneyLong += moneyBet;
        this.myMoneyLong += myMoney;
        this.myMoneyLabel.string = Utils.Number.abbreviate(this.myMoneyLong);
        this.totallMoneyLabel.string = Utils.Number.abbreviate(this.totallMoneyLong);
        if (moneyBet > 0) {
            // var action = [];
            // action.push(cc.delayTime(0));
            // action.push(cc.callFunc(function () {
            // self.caculateChip();
            // }));
            // self.node.runAction(cc.sequence(action));
        }
    },

    addPlayerBetToPot: function addPlayerBetToPot(player, money) {
        var moneyTemp = this.playerBetList[player];
        if (Utils.Type.isNumber(moneyTemp)) {
            this.playerBetList[player] = money + moneyTemp;
        } else {
            this.playerBetList[player] = money;
        }
    },

    removePlayerBet: function removePlayerBet(player) {
        delete this.playerBetList[player];
    },

    removeMoneyPot: function removeMoneyPot(username) {
        var moneyTemp = this.playerBetList[username];
        if (Utils.Type.isNumber(moneyTemp)) {
            if (this.totallMoneyLong > moneyTemp) {
                this.totallMoneyLong -= moneyTemp;
            } else {
                this.totallMoneyLong = 0;
            }
        }
        if (AuthUser.username === username) {
            this.myMoneyLong = 0;
        }

        this.myMoneyLabel.string = Utils.Number.abbreviate(this.myMoneyLong);
        if (this.totallMoneyLong <= 0) {
            this.destroyChipFacke(true);
        } else {
            this.caculateChip();
            this.totallMoneyLabel.string = Utils.Number.abbreviate(this.totallMoneyLong);
        }
        this.removePlayerBet(username);
    },

    showEfectWin: function showEfectWin(isShow) {
        this.node.color = new cc.color('#FFFFFF');
        this.hieuUngThangSprite.node.active = isShow;
        if (isShow) {
            var action = cc.repeatForever(cc.sequence(cc.fadeIn(0.8), cc.fadeOut(0.8)));
            this.hieuUngThangSprite.node.runAction(action);
        } else {
            this.hieuUngThangSprite.node.stopAllActions();
        }
    },

    disablePotEfect: function disablePotEfect() {
        this.node.color = new cc.color('#A07373');
    },

    caculateChip: function caculateChip() {
        this.destroyChipFacke(false);

        var moneyTemp = this.totallMoneyLong;
        var moneyBetting = this.sceneScript.gameManager.bettingList;
        this.tmpCountChipList = this.countChipList;
        var tempList = [];
        this.countChipList = [];
        for (var i = moneyBetting.length; i > 0; i -= 1) {
            if (moneyTemp >= moneyBetting[i - 1]) {
                var num = Math.floor(moneyTemp / moneyBetting[i - 1]);
                tempList.push(num);
                moneyTemp -= num * moneyBetting[i - 1];
            } else {
                tempList.push(0);
            }
        }

        this.countChipList = tempList.reverse();
        // cc.warn(this.countChipList + ' aaaaaaa ' + this.tmpCountChipList);
        // for (var j = 0; j < this.countChipList.length; j += 1) {
        //     if (this.countChipList[j] == 0) {
        //         this.destroyChipFackeColum(j);
        //     }
        // }
        this.setFakeChip();
    },

    // destroyChipFackeColum: function (colum) {
    //     var self = this;
    //     // var action = [];
    //     // action.push(cc.delayTime(0.3));
    //     // action.push(cc.callFunc(function () {
    //     for (var i = 0; i < self.chipFackeList.length; i += 1) {
    //         if (self.chipFackeList[i].parent) {
    //             if (self.chipFackeList[i]) {
    //                 if (self.chipFackeList[i].parent.name === colum) {
    //                     self.chipFackeList[i].destroy();
    //                 }
    //             }
    //         }
    //     }
    //     // }));
    //     self.potX0 = self.potX1 = self.potX2 = self.potX3 = 0;
    //     // self.node.runAction(cc.sequence(action));
    // },

    setFakeChip: function setFakeChip() {
        var self = this;
        var chipList = this.countChipList;
        // var action = [];
        // action.push(cc.delayTime(0.3));
        // action.push(cc.callFunc(function () {
        for (var i = 0; i < chipList.length; i += 1) {
            if (chipList[i] > 0) {
                for (var j = 0; j < chipList[i]; j += 1) {
                    var chip = cc.instantiate(self.sceneScript.chipPrefab);
                    var chipComponent = chip.getComponent('Chip');
                    chip.parent = self.node.getChildByName(i.toString());
                    chip.scale = cc.v2(0.5, 0.5);
                    chip.removeComponent('ButtonScaler');
                    chip.removeComponent(cc.Button);
                    switch (i) {
                        case 0:

                            chip.position = cc.v2(0, self.potX0);
                            self.potX0 += 3;
                            break;
                        case 1:
                            chip.position = cc.v2(0, self.potX1);
                            self.potX1 += 3;
                            break;
                        case 2:
                            chip.position = cc.v2(0, self.potX2);
                            self.potX2 += 3;
                            break;
                        case 3:
                            chip.position = cc.v2(0, self.potX3);
                            self.potX3 += 3;
                            break;

                    }

                    chipComponent.activeSelectChip(false);
                    chipComponent.init(self.sceneScript.gameManager.bettingList[i], BauCuaConstant.ChipColor.findById(i).NAME);
                    self.chipFackeList.push(chip);
                }
            }
        }
        // }));
        this.tmpChipFacke = this.chipFackeList;
        // this.node.runAction(cc.sequence(action));
    },

    destroyChipFacke: function destroyChipFacke(isClease) {
        if (this.chipFackeList) {
            for (var i = 0; i < this.chipFackeList.length; i += 1) {
                if (this.chipFackeList[i]) {
                    this.chipFackeList[i].destroy();
                }
            }
            this.chipFackeList = [];
        }
        this.potX0 = this.potX1 = this.potX2 = this.potX3 = 0;
        if (isClease) {
            this.chipFackeList = [];
            this.myMoneyLabel.string = 0;
            this.totallMoneyLabel.string = 0;
        }
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","BauCuaConstant":"BauCuaConstant","Utils":"Utils","XocDiaConstant":"XocDiaConstant"}],"SmartFoxConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '87edfMiLqVG2aB8vUGTPMBU', 'SmartFoxConstant');
// scripts\constant\SmartFoxConstant.js

var Utils = require('Utils');

module.exports = {
    PING_INTERVAL: 30000, // 30s

    Command: {
        EMPTY: {
            ID: -1,
            NAME: ''
        },
        IPLAY: {
            ID: -1,
            NAME: 'IPLAY'
        },
        GLOBAL_ENDPOINT: {
            ID: -1,
            NAME: 'pluginRequest'
        },
        GET_GAME_LIST: {
            ID: 1,
            NAME: 'GET_GAME_LIST'
        },
        GET_GAME_ROOM_LIST: {
            ID: 2,
            NAME: 'GET_GAME_ROOM_LIST'
        },
        UPDATE_USER_INFO: {
            ID: 6,
            NAME: 'UPDATE_USER_INFO'
        },
        MESSAGE: {
            ID: 7,
            NAME: 'MESSAGE'
        },
        KICK_PLAYER: {
            ID: 14,
            NAME: 'KICK_PLAYER'
        },
        PUSH_MESSAGE: {
            ID: 15,
            NAME: 'PUSH_MESSAGE'
        },
        PING: {
            ID: 16,
            NAME: 'PING'
        },
        GET_BETTING_VALUES: {
            ID: 19,
            NAME: 'GET_BETTING_VALUES'
        },
        UPDATE_PRIVATE_USER_MONEY: {
            ID: 100,
            NAME: 'UPDATE_PRIVATE_USER_MONEY'
        },
        DUPLICATE_LOGIN: {
            ID: 101,
            NAME: 'DUPLICATE_LOGIN'
        },
        GET_USER_IDLE_TIME: {
            ID: 102,
            NAME: 'GET_USER_IDLE_TIME'
        },

        PLAY: {
            ID: 20,
            NAME: 'PLAY'
        },
        CREATE_GAME: {
            ID: 21,
            NAME: 'CREATE_GAME'
        },
        PLAYER_ADDED: {
            ID: 22,
            NAME: 'PLAYER_ADDED'
        },
        PLAYER_REMOVED: {
            ID: 23,
            NAME: 'PLAYER_REMOVED'
        },
        UPDATE_HAND: {
            ID: 24,
            NAME: 'UPDATE_HAND'
        },
        UPDATE_GAME: {
            ID: 25,
            NAME: 'UPDATE_GAME'
        },
        UPDATE_GAME_STATE: {
            ID: 26,
            NAME: 'UPDATE_GAME_STATE'
        },
        UPDATE_ROOM_MASTER: {
            ID: 27,
            NAME: 'UPDATE_ROOM_MASTER'
        },
        DEAL_CARD: {
            ID: 28,
            NAME: 'DEAL_CARD'
        },
        TURN: {
            ID: 29,
            NAME: 'TURN'
        },
        FINISH_GAME: {
            ID: 30,
            NAME: 'FINISH_GAME'
        },
        WAITING_DEAL_CARD: {
            ID: 33,
            NAME: 'WAITING_DEAL_CARD'
        },
        WAITING_PLAYER_ADDED: {
            ID: 34,
            NAME: 'WAITING_PLAYER_ADDED'
        },
        WAITING_PLAYER_REMOVED: {
            ID: 35,
            NAME: 'WAITING_PLAYER_ADDED'
        },
        REFRESH_GAME: {
            ID: 36,
            NAME: 'REFRESH_GAME'
        },
        ENTER_GAME: {
            ID: 37,
            NAME: 'ENTER_GAME'
        },
        REG_QUIT_GAME: {
            ID: 38,
            NAME: 'REG_QUIT_GAME'
        },
        DEREG_QUIT_GAME: {
            ID: 39,
            NAME: 'DEREG_QUIT_GAME'
        },
        NEW_MATCH: {
            ID: 40,
            NAME: 'NEW_MATCH'
        },
        REQUEST_BANKER: {
            ID: 41,
            NAME: 'REQUEST_BANKER'
        },
        BANKER_RESIGN: {
            ID: 42,
            NAME: 'BANKER_RESIGN'
        },

        findById: function findById(cmdId) {
            return Utils.Object.findObject(this, 'ID', cmdId);
        }
    },

    KickReason: {
        NOT_ENOUGH_MONEY: 1
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"SmartFoxWebImplement":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2d06fobVGJP1YwZBw2D/aaj', 'SmartFoxWebImplement');
// scripts\network\SmartFoxWebImplement.js

var SFS2X = require('SFS2X'),
    Utils = require('Utils'),
    EventDispatcher = require('EventDispatcher'),
    base,
    misc,
    type;

base = {

    init: function init(configData) {
        this.configData = configData;
        this.sfs = null;
        this.extensionDispatcher = EventDispatcher.create();
    },

    connect: function connect(onConnection, onConnectionLost) {
        if (!this.isConnected()) {
            this.sfs = new SFS2X.SmartFox(this.configData);

            this.addEventListener(SFS2X.SFSEvent.CONNECTION, onConnection);
            this.addEventListener(SFS2X.SFSEvent.CONNECTION_LOST, onConnectionLost);

            this.sfs.connect();
        }
    },

    disconnect: function disconnect() {
        if (this.isConnected()) {
            var self = this;
            this.sfs.getJoinedRooms().forEach(function (room) {
                if (room) {
                    self.leaveRoom(room.id);
                }
            });
            this.sfs.disconnect();
        }
    },

    isConnected: function isConnected() {
        if (this.sfs === null || !this.sfs.isConnected()) {
            return false;
        }
        return true;
    },

    login: function login(username, accessToken, zone, onLogin, onLoginError, onLogout) {
        if (this.isConnected()) {
            var params = {
                accessToken: accessToken
            };

            this.addEventListener(SFS2X.SFSEvent.LOGIN, onLogin);
            this.addEventListener(SFS2X.SFSEvent.LOGIN_ERROR, onLoginError);
            this.addEventListener(SFS2X.SFSEvent.LOGOUT, onLogout);

            this.addEventListener(SFS2X.SFSEvent.EXTENSION_RESPONSE, (function (event) {
                this.extensionDispatcher.dispatchEvent(event.cmd, event);
            }).bind(this));

            zone = zone || this.configData.zone;
            this.sfs.send(new SFS2X.Requests.System.LoginRequest(username, '', params, zone));
        }
    },

    connectAndLogin: function connectAndLogin(username, accessToken, zone, onConnection, onConnectionLost, onLogin, onLoginError, onLogout) {
        this.connect(onConnection, onConnectionLost);
        if (this.sfs) {
            this.addEventListener(SFS2X.SFSEvent.CONNECTION, (function (event) {
                if (event.success) {
                    this.login(username, accessToken, zone, onLogin, onLoginError, onLogout);
                }
            }).bind(this));
        }
    },

    sendExtensionRequest: function sendExtensionRequest(extCmd, params, roomId) {
        if (this.isConnected()) {
            var room = this.sfs.getRoomById(roomId);
            this.sfs.send(new SFS2X.Requests.System.ExtensionRequest(extCmd, params, room));
        }
    },

    addExtensionHandler: function addExtensionHandler(extName, handler) {
        this.extensionDispatcher.addEventListener(extName, handler);
    },

    removeExtensionHandler: function removeExtensionHandler(extName, handler) {
        this.extensionDispatcher.removeEventListener(extName, handler);
    },

    addEventListener: function addEventListener(evtType, listener) {
        if (this.sfs && Utils.Type.isFunction(listener)) {
            this.sfs.addEventListener(evtType, listener);
        }
    },

    removeEventListener: function removeEventListener(evtType, listener) {
        if (this.sfs && Utils.Type.isFunction(listener)) {
            this.sfs.removeEventListener(evtType, listener);
        }
    },

    onJoinRoom: function onJoinRoom(onRoomJoinSuccess, onRoomJoinError) {
        this.addEventListener(SFS2X.SFSEvent.ROOM_JOIN, onRoomJoinSuccess);
        this.addEventListener(SFS2X.SFSEvent.ROOM_JOIN_ERROR, onRoomJoinError);
    },

    offJoinRoom: function offJoinRoom(onRoomJoinSuccess, onRoomJoinError) {
        this.removeEventListener(SFS2X.SFSEvent.ROOM_JOIN, onRoomJoinSuccess);
        this.removeEventListener(SFS2X.SFSEvent.ROOM_JOIN_ERROR, onRoomJoinError);
    },

    onLeaveRoom: function onLeaveRoom(onLeaveRoomSuccess) {
        this.addEventListener(SFS2X.SFSEvent.USER_EXIT_ROOM, onLeaveRoomSuccess);
    },

    offLeaveRoom: function offLeaveRoom(onLeaveRoomSuccess) {
        this.removeEventListener(SFS2X.SFSEvent.USER_EXIT_ROOM, onLeaveRoomSuccess);
    },

    onPublicMessage: function onPublicMessage(_onPublicMessage) {
        this.addEventListener(SFS2X.SFSEvent.PUBLIC_MESSAGE, _onPublicMessage);
    },

    offPublicMessage: function offPublicMessage(onPublicMessage) {
        this.removeEventListener(SFS2X.SFSEvent.PUBLIC_MESSAGE, onPublicMessage);
    },

    joinRoom: function joinRoom(roomId, password) {
        if (this.isConnected()) {
            this.sfs.send(new SFS2X.Requests.System.JoinRoomRequest(roomId, password, -1));
        }
    },

    leaveRoom: function leaveRoom(roomId) {
        if (this.isConnected()) {
            var room = this.sfs.getRoomById(roomId);
            if (room) {
                this.sfs.send(new SFS2X.Requests.System.LeaveRoomRequest(room));
            }
        }
    },

    sendPublicMessageRequest: function sendPublicMessageRequest(message, roomId) {
        if (this.isConnected()) {
            var room = this.sfs.getRoomById(roomId);
            if (room) {
                this.sfs.send(new SFS2X.Requests.System.PublicMessageRequest(message, null, room));
            }
        }
    },

    isJoinedInRoom: function isJoinedInRoom(roomId) {
        if (this.isConnected()) {
            var user = this.sfs.mySelf,
                room = this.sfs.getRoomById(roomId);
            if (user && room) {
                return user.isJoinedInRoom(room);
            }
        }
        return false;
    },

    getJoinedRooms: function getJoinedRooms() {
        if (this.isConnected()) {
            return this.sfs.getJoinedRooms();
        }
        return [];
    },

    internalCleanResources: function internalCleanResources() {
        this.sfs = null;
        this.extensionDispatcher.clear();
    }

};

misc = {
    parseClientDisconnectionReason: function parseClientDisconnectionReason(event) {
        var result = {
            isManual: event.reason === SFS2X.Utils.ClientDisconnectionReason.MANUAL,
            isKick: event.reason === SFS2X.Utils.ClientDisconnectionReason.KICK,
            isBan: event.reason === SFS2X.Utils.ClientDisconnectionReason.BAN,
            isIdle: event.reason === SFS2X.Utils.ClientDisconnectionReason.IDLE,
            isUnknown: event.reason === SFS2X.Utils.ClientDisconnectionReason.UNKNOWN
        };
        return result;
    }
};

function identify(value) {
    return value;
}

type = {
    bool: identify,
    boolArray: identify,

    byte: identify,
    byteArray: identify,

    short: identify,
    shortArray: identify,

    int: identify,
    intArray: identify,

    long: identify,
    longArray: identify,

    float: identify,
    floatArray: identify,

    double: identify,
    doubleArray: identify,

    utfString: identify,
    utfStringArray: identify,

    sfsObject: identify,
    sfsArray: identify,

    getValue: identify
};

module.exports = {
    base: base,
    misc: misc,
    type: type
};

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","SFS2X":"SFS2X","Utils":"Utils"}],"SmartFox":[function(require,module,exports){
"use strict";
cc._RFpush(module, '9b0bbEeMkFAxoOczzgQq1sB', 'SmartFox');
// scripts\network\SmartFox.js

var Utils = require('Utils'),
    UiManager = require('UiManager'),
    AuthUser = require('AuthUser'),
    PlatformImplement = require('PlatformImplement'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant'),
    CommonConstant = require('CommonConstant'),
    GameManagerConstant = require('GameManagerConstant'),
    SmartFoxConstant = require('SmartFoxConstant');

module.exports = {

    // ============================================================
    // Connect - Auth - Event/Extension API
    // ============================================================

    init: function init(configData) {
        if (configData && configData.port) {
            configData.port = parseInt(configData.port, 10);
        }

        this.implement = require('SmartFoxWebImplement');
        this.implement.base.init(configData);
        this.type = this.implement.type;

        this.pingIntervalId = null;
        this.duplicateLogin = false;

        this.defaultEventHandlers = {
            onConnection: (function (event) {
                if (!event.success) {
                    this._cleanResources();
                    UiManager.openModal('Kết nối với máy chủ thất bại');
                    EventDispatcher.dispatchEvent(EventDispatcherConstant.AUTH.LOGOUT);
                } else {
                    this.addExtensionHandler(SmartFoxConstant.Command.EMPTY.NAME, function (event) {
                        var params = event && event.params,
                            messageType;
                        if (params) {
                            // push message
                            if (params.command === SmartFoxConstant.Command.PUSH_MESSAGE.ID) {
                                if ('displayType' in params) {
                                    Utils.Object.replaceProperty(params, 'displayType', 'messageType');
                                }

                                messageType = CommonConstant.PushMessageType.findById(params.messageType);
                                if (messageType) {
                                    EventDispatcher.dispatchEvent(messageType.EVENT, params);
                                }
                            }
                        }
                    });

                    this.addExtensionHandler(SmartFoxConstant.Command.IPLAY.NAME, (function (event) {
                        var params = event && event.params;
                        if (params) {
                            // update user money
                            if (params.command === SmartFoxConstant.Command.UPDATE_USER_INFO.ID) {
                                EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_MONEY, {
                                    username: AuthUser.username,
                                    currency: params.currency,
                                    money: params.money
                                });
                            }
                            // duplicate login
                            else if (params.command === SmartFoxConstant.Command.DUPLICATE_LOGIN.ID) {
                                    this.duplicateLogin = true;
                                }
                        }
                    }).bind(this));
                }
            }).bind(this),

            onConnectionLost: (function (event) {
                var reason = this.implement.misc.parseClientDisconnectionReason(event),
                    username = AuthUser.username;
                if (username && reason.isUnknown && this.duplicateLogin) {
                    PlatformImplement.displayLogoutMessage('Tài khoản "' + username + '" của bạn đã được đăng nhập trên thiết bị khác');
                } else if (!reason.isManual) {
                    PlatformImplement.displayLogoutMessage('Mất kết nối với máy chủ');
                }
                this._cleanResources();
                EventDispatcher.dispatchEvent(EventDispatcherConstant.AUTH.LOGOUT);
            }).bind(this),

            onLogin: (function () {
                this._schedulePing();
                this.onJoinRoom(function (event) {
                    EventDispatcher.dispatchEvent(GameManagerConstant.Event.JOIN_ROOM, event.room);
                }, function (event) {
                    UiManager.openModal(event.errorMessage);
                    EventDispatcher.dispatchEvent(GameManagerConstant.Event.JOIN_ROOM_ERROR, event);
                });
                this.onLeaveRoom(function (event) {
                    var user = event.user;
                    if (user.isItMe) {
                        EventDispatcher.dispatchEvent(GameManagerConstant.Event.LEAVE_ROOM, event.room);
                    }
                });
                EventDispatcher.dispatchEvent(EventDispatcherConstant.AUTH.LOGIN);
            }).bind(this),

            onLoginError: function onLoginError(event) {
                UiManager.openModal(event.errorMessage);
            },

            onLogout: (function () {
                this.disconnect();
            }).bind(this)
        };

        this.globalEndpointCmdHandlerRegistered = {};
    },

    connectAndLogin: function connectAndLogin(username, accessToken, zone) {
        this.implement.base.connectAndLogin(username, accessToken, zone, this.defaultEventHandlers.onConnection, this.defaultEventHandlers.onConnectionLost, this.defaultEventHandlers.onLogin, this.defaultEventHandlers.onLoginError, this.defaultEventHandlers.onLogout);
    },

    disconnect: function disconnect() {
        this.implement.base.disconnect();
    },

    sendExtensionRequest: function sendExtensionRequest(extCmd, params, roomId) {
        this.implement.base.sendExtensionRequest(extCmd, this.type.sfsObject(params), roomId);
    },

    addExtensionHandler: function addExtensionHandler(extName, handler) {
        this.implement.base.addExtensionHandler(extName, handler);
    },

    removeExtensionHandler: function removeExtensionHandler(extName, handler) {
        this.implement.base.removeExtensionHandler(extName, handler);
    },

    onJoinRoom: function onJoinRoom(onRoomJoinSuccess, onRoomJoinError) {
        this.implement.base.onJoinRoom(onRoomJoinSuccess, onRoomJoinError);
    },

    offJoinRoom: function offJoinRoom(onRoomJoinSuccess, onRoomJoinError) {
        this.implement.base.offJoinRoom(onRoomJoinSuccess, onRoomJoinError);
    },

    onLeaveRoom: function onLeaveRoom(onLeaveRoomSuccess) {
        this.implement.base.onLeaveRoom(onLeaveRoomSuccess);
    },

    offLeaveRoom: function offLeaveRoom(onLeaveRoomSuccess) {
        this.implement.base.offLeaveRoom(onLeaveRoomSuccess);
    },

    joinRoom: function joinRoom(roomId, password) {
        this.implement.base.joinRoom(roomId, password);
    },

    leaveRoom: function leaveRoom(roomId) {
        this.implement.base.leaveRoom(roomId);
    },

    sendPublicMessageRequest: function sendPublicMessageRequest(message, roomId) {
        if (Utils.Type.isString(message)) {
            message = message.trim();
            this.implement.base.sendPublicMessageRequest(message, roomId);
        }
    },

    onPublicMessage: function onPublicMessage(_onPublicMessage) {
        this.implement.base.onPublicMessage(_onPublicMessage);
    },

    offPublicMessage: function offPublicMessage(onPublicMessage) {
        this.implement.base.offPublicMessage(onPublicMessage);
    },

    sendGlobalEndpoint: function sendGlobalEndpoint(params, callback) {
        var cmdId = this.type.getValue(params.command),
            cmd,
            handler;

        if (Utils.Type.isNumber(cmdId)) {
            cmd = SmartFoxConstant.Command.findById(cmdId);
            if (cmd) {
                if (this._markGlobalEndpointCmdHandlerRegistered(cmd.NAME)) {
                    this.addExtensionHandler(cmd.NAME, function (event) {
                        var params = event && event.params || {};
                        if (params.result === 0) {
                            UiManager.openModal(params.message);
                        }
                    });
                }

                if (Utils.Type.isFunction(callback)) {
                    handler = (function (event) {
                        var params = event && event.params || {};
                        this.removeExtensionHandler(cmd.NAME, handler);
                        callback(params);
                    }).bind(this);
                    this.addExtensionHandler(cmd.NAME, handler);
                }
            }
        }

        this.sendExtensionRequest(SmartFoxConstant.Command.GLOBAL_ENDPOINT.NAME, params, null);
    },

    getUserIdleTime: function getUserIdleTime(callback) {
        this.sendGlobalEndpoint({
            command: this.type.byte(SmartFoxConstant.Command.GET_USER_IDLE_TIME.ID)
        }, callback);
    },

    isJoinedInRoom: function isJoinedInRoom(roomId) {
        return this.implement.base.isJoinedInRoom(roomId);
    },

    getJoinedRooms: function getJoinedRooms() {
        return this.implement.base.getJoinedRooms();
    },

    _markGlobalEndpointCmdHandlerRegistered: (function () {
        var EXCLUSIVE_COMMANDS = [SmartFoxConstant.Command.PING.NAME];

        return function (cmdName) {
            var success = false;
            if (EXCLUSIVE_COMMANDS.indexOf(cmdName) === -1 && !this.globalEndpointCmdHandlerRegistered[cmdName]) {
                this.globalEndpointCmdHandlerRegistered[cmdName] = true;
                success = true;
            }
            return success;
        };
    })(),

    _schedulePingByInterval: function _schedulePingByInterval(interval) {
        this._cancelPing();
        this.pingIntervalId = setInterval((function () {
            if (this.implement.base.isConnected()) {
                this.sendGlobalEndpoint({
                    command: this.type.byte(SmartFoxConstant.Command.PING.ID)
                });
            } else {
                this._cancelPing();
            }
        }).bind(this), interval);
    },

    _schedulePing: function _schedulePing() {
        var self = this;
        this.getUserIdleTime(function (params) {
            var time = params && params.time;
            if (time > 0) {
                time *= 1000;
                time /= 2.1;
                self._schedulePingByInterval(time);
            }
        });
    },

    _cancelPing: function _cancelPing() {
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
            this.pingIntervalId = null;
        }
    },

    _cleanResources: function _cleanResources() {
        this._cancelPing();
        this.duplicateLogin = false;
        this.implement.base.internalCleanResources();
    }

};

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","GameManagerConstant":"GameManagerConstant","PlatformImplement":"PlatformImplement","SmartFoxConstant":"SmartFoxConstant","SmartFoxWebImplement":"SmartFoxWebImplement","UiManager":"UiManager","Utils":"Utils"}],"SortCardLayoutMauBinh":[function(require,module,exports){
"use strict";
cc._RFpush(module, '79232xlpoNDeJ9kJPy8SAQh', 'SortCardLayoutMauBinh');
// scripts\components\games\mau_binh\SortCardLayoutMauBinh.js

var Card = require('Card'),
    CardUI = require('CardUI'),
    ChiMauBinh = require('ChiMauBinh'),
    MauBinhConstant = require('MauBinhConstant'),
    BaseGameManager = require('BaseGameManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        lblChiList: {
            'default': [],
            type: cc.Label
        },
        cardNodeList: {
            'default': [],
            type: cc.Node
        },
        frameCardNode: cc.Node,
        cardPrefab: cc.Prefab,
        imgTouchingCard: cc.Node,
        imgCollisionCard: cc.Node,
        imgBinhLung: cc.Node,
        imgThangTrang: cc.Node,
        gameManager: BaseGameManager
    },

    setGameParam: function setGameParam(gamePlay, gameManager) {
        this.gamePlay = gamePlay;
        this.gameManager = gameManager;
    },

    onLoad: function onLoad() {
        // Reset
        this._initFirstTime();

        // Touch Event
        var size = cc.winSize,
            maxX = size.width / 2 + 20,
            maxY = size.height / 2 + 20;

        var i,
            self = this;
        self.node.on(cc.Node.EventType.TOUCH_START, function (event) {
            if (self.gameManager.gameState !== MauBinhConstant.GameState.ORDER_CARDS || self.isFinish) {
                return;
            }
            self.resetCardPosition();
            var oldCardTouchIndex = self.cardTouchingIndex;
            var target = event.getCurrentTarget().parent;
            var locationInNode = target.convertToNodeSpace(event.getLocation());
            self.cardTouchingIndex = -1;
            for (i = 0; i < self.cardNodeList.length; i += 1) {
                if (self.cardNodeList[i].getBoundingBox().contains(locationInNode)) {
                    self.cardTouchingIndex = i;
                    self.cardTouchingPosition = self.cardPositionList[i];
                    self.deltaPosition = self.cardTouchingPosition.sub(locationInNode);
                    self.cardNodeList[i].zIndex = 1;
                    self.gamePlay.audioManager.playBaiChon();
                    break;
                } else {
                    self.cardNodeList[i].zIndex = 0;
                }
            }

            // Swap If Touch Card 2
            if (self.imgTouchingCard.active && self.cardTouchingIndex !== -1 && oldCardTouchIndex !== -1 && oldCardTouchIndex !== self.cardTouchingIndex) {
                var oldCardTouch = self.cardNodeList[oldCardTouchIndex];
                var newCardTouch = self.cardNodeList[self.cardTouchingIndex];
                var delta = oldCardTouch.position.sub(newCardTouch.position);
                var timeMove = self._distanceVec2(delta) / 2300;
                oldCardTouch.runAction(cc.moveTo(timeMove, self.cardPositionList[self.cardTouchingIndex]));
                newCardTouch.runAction(cc.moveTo(timeMove, self.cardPositionList[oldCardTouchIndex]));
                self._swapCard(self.cardTouchingIndex, oldCardTouchIndex);
                self.imgTouchingCard.active = false;
                self.imgTouchingCard.position = self.cardPositionList[self.cardTouchingIndex];
                self.cardTouchingIndex = -1;
                self._onSortCard();
            } else if (self.cardTouchingIndex !== -1) {
                // Show Card Touch Effect
                self.imgTouchingCard.active = true;
                self.imgTouchingCard.position = self.cardTouchingPosition;
            }
        });
        self.node.on(cc.Node.EventType.TOUCH_MOVE, function (event) {
            if (self.gameManager.gameState !== MauBinhConstant.GameState.ORDER_CARDS || self.isFinish) {
                return;
            }
            var target = event.getCurrentTarget().parent;
            var locationInNode = target.convertToNodeSpace(event.getLocation());
            if (self.cardTouchingIndex >= 0) {
                // Move Card Touching
                var cardTouchingNode = self.cardNodeList[self.cardTouchingIndex];
                cardTouchingNode.position = locationInNode.add(self.deltaPosition);
                var deltaPosX = Math.abs(cardTouchingNode.x - self.cardTouchingPosition.x);
                var deltaPosY = Math.abs(cardTouchingNode.y - self.cardTouchingPosition.y);
                if (deltaPosX >= 3 || deltaPosY >= 3) {
                    self.imgTouchingCard.active = false;
                }

                // Check Collision
                self.cardCollisionIndex = -1;
                self.imgCollisionCard.active = false;
                for (var i = 0; i < self.cardNodeList.length; i += 1) {
                    if (cardTouchingNode === self.cardNodeList[i]) {
                        continue;
                    }
                    if (self._isCollision(self.cardNodeList[i], cardTouchingNode)) {
                        self.cardCollisionIndex = i;
                        self.imgCollisionCard.active = true;
                        self.imgCollisionCard.position = self.cardNodeList[i].position;
                    }
                }

                // Check Card Move Out Sight
                var cardSizeWidth = cardTouchingNode.width * 0.72;
                var cardSizeHeight = cardTouchingNode.height * 0.72;
                if (cardTouchingNode.x + cardSizeWidth / 2 >= maxX || cardTouchingNode.x - cardSizeWidth / 2 <= -maxX || cardTouchingNode.y + cardSizeHeight / 2 >= maxY || cardTouchingNode.y - cardSizeHeight / 2 <= -maxY) {
                    cardTouchingNode.runAction(cc.moveTo(0.2, self.cardTouchingPosition));
                    self.cardTouchingIndex = -1;
                }
            }
        });
        self.node.on(cc.Node.EventType.TOUCH_END, function () {
            if (self.gameManager.gameState !== MauBinhConstant.GameState.ORDER_CARDS || self.isFinish) {
                return;
            }
            if (self.cardTouchingIndex >= 0) {
                // Swap Card
                var delta = self.cardNodeList[self.cardTouchingIndex].position.sub(self.cardTouchingPosition);
                var timeMove = self._distanceVec2(delta) / 3000;
                if (self.cardCollisionIndex >= 0) {
                    // Move
                    self.cardNodeList[self.cardCollisionIndex].zIndex = 1;
                    var collisionPosition = self.cardNodeList[self.cardCollisionIndex].position;
                    self.cardNodeList[self.cardTouchingIndex].runAction(cc.moveTo(0.1, collisionPosition));
                    self.cardNodeList[self.cardCollisionIndex].runAction(cc.moveTo(timeMove, self.cardTouchingPosition));

                    // Swap Card
                    var cardTmp = self.cardNodeList[self.cardTouchingIndex];
                    self.cardNodeList[self.cardTouchingIndex] = self.cardNodeList[self.cardCollisionIndex];
                    self.cardNodeList[self.cardCollisionIndex] = cardTmp;
                    self._onSortCard();
                    self.gamePlay.audioManager.playBaiBay();
                } else {
                    self.cardNodeList[self.cardTouchingIndex].runAction(cc.moveTo(timeMove, self.cardTouchingPosition));
                }

                // Reset ZIndex
                self.cardNodeList[self.cardTouchingIndex].zIndex = 0;
                self.imgCollisionCard.active = false;
            }
            for (var j = 0; j < self.cardNodeList.length; j += 1) {
                self.cardNodeList[j].opacity = 255;
            }

            // Reset Collision Card
            self.cardCollisionIndex = -1;

            // Reset Card Touch If Move
            if (!self.imgTouchingCard.active) {
                self.cardTouchingIndex = -1;
            }
        });
    },

    setCards: function setCards(cards) {
        // Reset
        this._initFirstTime();

        for (var i = 0; i < cards.length; i += 1) {
            // Card Info
            this.cardNodeList[i].getComponent(CardUI).setCard(Card.fromId(cards[i]));

            // Effect
            var cardNode = this.cardNodeList[i],
                foldNode = cardNode.getChildByName('Fold'),
                scale = 0.72;
            foldNode.active = true;
            cardNode.runAction(cc.sequence(cc.delayTime(0.02 * i), cc.scaleTo(0.05, 0, scale), cc.callFunc((function () {
                this.getChildByName('Fold').active = false;
            }).bind(cardNode)), cc.scaleTo(0.15, scale, scale)));
        }
        this._calculateChi();
    },

    getCards: function getCards() {
        var cards = [];
        for (var i = 0; i < this.cardNodeList.length; i += 1) {
            cards.push(this.cardNodeList[i].getComponent(CardUI).getCardId());
        }
        return cards;
    },

    reset: function reset() {
        // Init First Time
        this._initFirstTime();

        // Stop All Action
        for (var i = 0; i < this.cardNodeList.length; i += 1) {
            this.cardNodeList[i].stopAllActions();
        }

        // Reset
        this.isFinish = false;
        this.node.active = false;
        this.imgCollisionCard.active = false;
        this.imgTouchingCard.active = false;
        this.imgBinhLung.active = false;
        this.imgThangTrang.active = false;
        this.resetCardPosition();
    },

    resetCardPosition: function resetCardPosition() {
        for (var i = 0; i < this.cardNodeList.length; i += 1) {
            this.cardNodeList[i].opacity = 255;
            this.cardNodeList[i].position = this.cardPositionList[i];
        }
    },

    setFinishOrder: function setFinishOrder() {
        // Reset
        this._initFirstTime();

        this.isFinish = true;
        this.node.active = false;
        this.reset();
    },

    swapChi: function swapChi() {
        if (this.swapping) {
            return;
        }
        this.swapping = true;
        var i;
        for (i = 0; i < 5; i += 1) {
            this.cardNodeList[i].runAction(cc.moveTo(0.3, this.cardPositionList[i + 5]));
        }
        for (i = 5; i < 10; i += 1) {
            this.cardNodeList[i].runAction(cc.sequence(cc.moveTo(0.3, this.cardPositionList[i - 5]), cc.callFunc((function () {
                this._onSortCard();
                this.swapping = false;
            }).bind(this))));
        }
        for (i = 0; i < 5; i += 1) {
            this._swapCard(i, i + 5);
        }
    },

    _swapCard: function _swapCard(i, j) {
        var tmp = this.cardNodeList[i];
        this.cardNodeList[i] = this.cardNodeList[j];
        this.cardNodeList[j] = tmp;
    },

    _isCollision: function _isCollision(cardNode1, cardNode2) {
        var dx = Math.abs(cardNode1.position.x - cardNode2.position.x);
        var dy = Math.abs(cardNode1.position.y - cardNode2.position.y);
        if (cardNode1.getBoundingBox().intersects(cardNode2.getBoundingBox()) && dx <= 60 && dy <= 80) {
            return true;
        } else {
            return false;
        }
    },

    _calculateChi: function _calculateChi() {
        var i;
        var chiMauBinh = new ChiMauBinh(this.getCards());
        var result = chiMauBinh.getResult();
        // cc.log(result[0].NAME + ' - ' + result[1].NAME + ' - ' + result[2].NAME);
        this.imgBinhLung.active = chiMauBinh.isBinhLung();
        this.imgThangTrang.active = chiMauBinh.isThangTrang();
        this.imgThangTrang.getComponentInChildren(cc.Label).string = result[0].NAME;
        for (i = 0; i < this.lblChiList.length; i += 1) {
            this.lblChiList[i].string = result[i].NAME;
            this.lblChiList[i].node.active = !chiMauBinh.isThangTrang();
        }

        // Lam Toi Mau Quan Bai Khong Co Ca
        for (i = 0; i < this.cardNodeList.length; i += 1) {
            var isInChi = false;
            var cardId = this.cardNodeList[i].getComponent('CardUI').card.getId();
            isInChi = this._isCardInChi(cardId, chiMauBinh.cardsInChi);

            // Tang Chi At
            if (!isInChi && cardId < 4) {
                cardId += 52;
                isInChi = this._isCardInChi(cardId, chiMauBinh.cardsInChi);
            }
            this.cardNodeList[i].getComponent(CardUI).showTransparentBlackNode(!isInChi);
        }
    },

    _isCardInChi: function _isCardInChi(cardId, cardsInChi) {
        for (var j = 0; j < 3; j += 1) {
            for (var k = 0; k < cardsInChi[j].length; k += 1) {
                if (cardId === cardsInChi[j][k]) {
                    return true;
                }
            }
        }
        return false;
    },

    _onSortCard: function _onSortCard() {
        this.gameManager.sendRequestOrderCard(this.getCards(), false);
        this._calculateChi();
    },

    _distanceVec2: function _distanceVec2(vec2) {
        return Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
    },

    _initFirstTime: function _initFirstTime() {
        if (this.isInitFirstTime) {
            return;
        }
        this.isInitFirstTime = true;
        this.isFinish = false;
        this.deltaPosition = cc.v2();
        this.cardTouchingIndex = -1;
        this.cardCollisionIndex = -1;
        this.cardTouchingPosition = cc.v2();
        this.cardPositionList = [];
        this.imgTouchingCard.active = false;
        this.imgCollisionCard.active = false;
        this.imgBinhLung.active = false;
        this.imgThangTrang.active = false;

        // Get Position Card List
        var i;
        var length = this.cardNodeList.length;
        for (i = 0; i < length; i += 1) {
            this.cardPositionList.push(this.cardNodeList[i].position);
        }

        // Remove All Card
        this.frameCardNode.removeAllChildren();

        // Re Add Child
        for (i = 0; i < length; i += 1) {
            var node = cc.instantiate(this.cardPrefab);
            node.position = this.cardPositionList[i];
            node.scale = 0.72;
            this.frameCardNode.addChild(node);
            var cardUI = node.getComponent(CardUI);
            cardUI.foldNode.active = false;
            cardUI.unfoldNode.active = true;
            this.cardNodeList[i] = node;
        }
    }
});

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","Card":"Card","CardUI":"CardUI","ChiMauBinh":"ChiMauBinh","MauBinhConstant":"MauBinhConstant"}],"Splash":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'cd1d177/2VL4rLVLTSNlb3r', 'Splash');
// scripts\components\Splash.js

var PlatformImplement = require('PlatformImplement'),
    NetworkManager = require('NetworkManager'),
    GameConstant = require('GameConstant'),
    SysConfig = require('SysConfig'),
    AuthUser = require('AuthUser'),
    Utils = require('Utils'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,
    properties: {
        loadingProgressBar: cc.ProgressBar
    },

    // use this for initialization
    onLoad: function onLoad() {
        var that = this,
            maxLoad = 4,
            currentLoad = 0;
        function updateProgress() {
            currentLoad += 1;
            that.loadingProgressBar.progress = currentLoad / maxLoad;
        }

        GameConstant.loadIconsAtlas(function () {

            updateProgress();
            NetworkManager.Http.fetch('GET', Url.Http.RT_SV_IP, {}).success(function (rtsvipResp) {
                var username = Utils.Cookie.get(SysConfig.CookieName.USERNAME),
                    accessToken = Utils.Cookie.get(SysConfig.CookieName.ACCESSTOKEN),
                    rtsvipData = rtsvipResp.data;

                updateProgress();
                if (username && accessToken) {
                    NetworkManager.Http.fetch('GET', Url.Http.CHECK_VER, {
                        version_code: SysConfig.VERSION_CODE,
                        platform: SysConfig.PLATFORM
                    }).success(function (versionData) {
                        GameConstant.updateIconsServer(versionData.data.game_icons);
                        GameConstant.updateGamePriorities(versionData.data.game_priorities);

                        updateProgress();
                        NetworkManager.Http.fetch('GET', Url.Http.GAME_ACCOUNT, {
                            username: username,
                            accesstoken: accessToken
                        }).success(function (accResp) {
                            var realtimeConfig = rtsvipData.realtime && rtsvipData.realtime[0],
                                host = null,
                                port = null,
                                zone = null,
                                useSSL = false;

                            updateProgress();
                            AuthUser.updateInfo(accResp.data);
                            if (realtimeConfig) {
                                zone = realtimeConfig.zone;
                                if (location.protocol === 'http:') {
                                    host = realtimeConfig.ws_host;
                                    port = realtimeConfig.ws_port;
                                } else if (location.protocol === 'https:') {
                                    host = realtimeConfig.wss_host;
                                    port = realtimeConfig.wss_port;
                                    useSSL = true;
                                }

                                if (host && port && zone) {
                                    NetworkManager.SmartFox.init({
                                        host: host,
                                        port: port,
                                        useSSL: useSSL,
                                        zone: zone
                                    });
                                    NetworkManager.SmartFox.connectAndLogin(username, accessToken);

                                    window.onbeforeunload = function () {
                                        return 'Bạn có chắc chắn muốn thoát khỏi game không ?';
                                    };
                                }
                            }
                        });
                    });
                } else {
                    PlatformImplement.returnLoginPage();
                }
            });
        });
    }
});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {
// },

cc._RFpop();
},{"AuthUser":"AuthUser","GameConstant":"GameConstant","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","SysConfig":"SysConfig","Url":"Url","Utils":"Utils"}],"SysConfig":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2803dPdVpdDKIId2D7Sv/CP', 'SysConfig');
// scripts\constant\SysConfig.js

// config for production
var SysConfig = {
    VERSION_CODE: 1,
    CP: 'VBH00000',
    GAME: 'IPLAY',
    PLATFORM: 'WEB', // ANDROID, IOS, WINPHONE
    // IAP_PROVIDER: 'GOOGLE', // GOOGLE, APPLE
    IplayHttp: {
        HOST: 'vuabai.club',
        PORT: '443',
        PROTOCOL: 'https',
        AUTH_USER: '',
        AUTH_PASS: ''
    },
    CookieName: {
        USERNAME: 'i_username',
        ACCESSTOKEN: 'i_accesstoken'
    }
};

// config for development
SysConfig = {
    VERSION_CODE: 1,
    CP: 'VBH00000',
    GAME: 'IPLAY',
    PLATFORM: 'WEB', // ANDROID, IOS, WINPHONE
    // IAP_PROVIDER: 'GOOGLE', // GOOGLE, APPLE
    IplayHttp: {
        HOST: '192.168.100.12',
        PORT: '7777',
        PROTOCOL: 'http',
        AUTH_USER: '',
        AUTH_PASS: ''
    },
    CookieName: {
        USERNAME: 'i_username',
        ACCESSTOKEN: 'i_accesstoken'
    }
};

module.exports = SysConfig;

cc._RFpop();
},{}],"TLMNConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '665a6EW1alMp4cY0ui/2Oul', 'TLMNConstant');
// scripts\games\tlmn\TLMNConstant.js

module.exports = {

    Action: {
        DISCARD: 0,
        IGNORE: 1,
        ORDER_HANDS: 2,
        CHAT_HANG: 3,
        BAO_SAM: 4,
        WAITING_BAO_SAM: 5,
        BAO: 6,
        HUY_BAO_SAM: 7,
        DEN_LANG: 17
    },

    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        BAO_SAM: 4,
        PLAYING: 5,
        FINALIZING: 6,
        FINISH: 7
    },

    GameStateTLMN: {
        NONE: 0,
        WAITING_FOR_PLAYER: 'waitingForPlayer',
        WAITING_FOR_NEW_GAME: 'waitingDealing',
        PLAYING: 'playing',
        FINALIZING: 'finalizing',
        FINISH: 'finish'
    },

    PlayerState: {
        WAITING: 0,
        READY: 1,
        IN_TURN: 2,
        OUT_TURN: 3,
        WAITING_FOR_TURN: 4,
        FINISH: 5
    },

    ActionFinishType: {
        THANG_TRANG: 0,
        THUA_DEM_LA: 13,
        SAM_THANH_CONG: 16,
        SAM_THAT_BAI: 17,
        DEN_LANG_THOI_HAI: 18
    },

    Event: {
        FINISH_GAME: 'in_game.sam.finish_game',
        UPDATE_GAME: 'in_game.sam.update_game',
        UPDATE_HAND: 'in_game.sam.update_hand',
        WAITING_DEAL_CARD: 'in_game.sam.waiting_deal_card',
        WAITING_FOR_PLAYER: 'in_game.sam.waiting_for_player',
        TURN: 'in_game.sam.turn',
        DISCARD: 'in_game.sam.discard',
        REFRESH_GAME: 'in_game.sam.refresh_game',
        CHAT_HANG: 'in_game.sam.chag_hang',
        WAITING_BAO_SAM: 'in_game.sam.bao_sam',
        PLAYER_BAO_SAM: 'in_game.sam.player_bao_sam',
        PLAYER_BAO_MOT: 'in_game.sam.player_bao_mot',
        PLAYER_HUY_BAO_SAM: 'in_game.sam.huy_bao_sam'
    },

    TimeoutId: {
        DISCARD_MUSIC: 'TIMEOUT_DISCARD_MUSIC',
        BOLUOT_ANIMATION: 'TIMEOUT_BOLUOT_ANIMATION',
        CHANGE_TURN: 'TIMEOUT_CHANGE_TURN'
    },

    Effect: {
        THUA_CONG: 0,
        THANG_TRANG: 1,
        CHAN_SAM: 2,
        BAO_SAM: 3,
        BAO: 4,
        DEN_LANG: 5,
        DEN_TRANG: 6,
        HUY_BAO_SAM: 7,
        SAM_THAT_BAI: 8,
        SAM_THANH_CONG: 9,
        DANG_DOI: 10,
        HET_LUOT: 11
    }
};

cc._RFpop();
},{}],"TLMNGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '87fafqOsvNAL4Ceb8muYxMX', 'TLMNGameManager');
// scripts\games\tlmn\TLMNGameManager.js

var BaseGameManager = require('BaseGameManager'),
    NetworkManager = require('NetworkManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    TLMNConstant = require('TLMNConstant'),
    Utils = require('Utils'),
    TLMNGameManager;

TLMNGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);
        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_HAND.ID, this.onUpdateHand, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaitingDealCard, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_PLAYER_ADDED.ID, this.onWaitingForPlayer, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.TURN.ID, this.onTurn, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onRefreshGame, this);

        // các action của game play
        this.eventDispatchers.playCmd.addEventListener(TLMNConstant.Action.CHAT_HANG, this.onChatHang, this);
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.onRefreshGame(params);
    },

    onFinishGame: function onFinishGame(params) {
        this.gameState = TLMNConstant.GameStateTLMN.FINISH;
        this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.FINISH_GAME, params);
    },

    onUpdateHand: function onUpdateHand(params) {
        this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.UPDATE_HAND, params);
    },

    onWaitingForPlayer: function onWaitingForPlayer() {
        this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.WAITING_FOR_PLAYER);
    },

    onWaitingDealCard: function onWaitingDealCard(params) {
        this.gameState = TLMNConstant.GameStateTLMN.WAITING_FOR_NEW_GAME;
        this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.WAITING_DEAL_CARD, params);
    },

    onTurn: function onTurn(params) {
        this.gameState = TLMNConstant.GameStateTLMN.PLAYING;
        if (params.lastPlayer) {
            if (params.cards) {
                this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.DISCARD, { cards: params.cards, userName: params.lastPlayer.userName });
            }
            if (params.toPlayer) {
                this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.TURN, { userName: params.toPlayer.userName, wait: 1, newTurn: params.newTurn, timeTurn: params.time });
            }
        } else {
            if (params.toPlayer) {
                this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.TURN, { userName: params.toPlayer.userName, wait: 0, newTurn: params.newTurn, timeTurn: params.time });
            }
        }
    },

    onRefreshGame: function onRefreshGame(params) {
        this.gameState = params.allData.gameState;
        switch (params.allData.gameState) {
            case TLMNConstant.GameStateTLMN.WAITING_FOR_PLAYER:
                this.onWaitingForPlayer();
                break;
            case TLMNConstant.GameStateTLMN.WAITING_FOR_NEW_GAME:
                this.onWaitingDealCard(params);
                break;
            case TLMNConstant.GameStateTLMN.PLAYING:
                this.onTurn(params);
                this.onUpdateHand(params);
                if (params.data.trash) {
                    this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.REFRESH_GAME, params);
                }
                break;
            case TLMNConstant.GameStateTLMN.FINALIZING:

                break;
            case TLMNConstant.GameStateTLMN.FINISH:

                break;
        }
    },

    onChatHang: function onChatHang(params) {
        if (params.data.action === TLMNConstant.Action.CHAT_HANG) {
            this.eventDispatchers.local.dispatchEvent(TLMNConstant.Event.CHAT_HANG, params);
        }
    },
    // ============================================================
    // Request API
    // ============================================================
    sendRequestStartGame: function sendRequestStartGame() {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.DEAL_CARD.ID)
        });
    },

    sendRequestDiscard: function sendRequestDiscard(cards) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(TLMNConstant.Action.DISCARD),
            cards: NetworkManager.SmartFox.type.byteArray(cards)
        });
    }
});

module.exports = TLMNGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","TLMNConstant":"TLMNConstant","Utils":"Utils"}],"TabActivateAccount":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'beda3ByUHdLnrfqcZz5xqGt', 'TabActivateAccount');
// scripts\components\profile\TabActivateAccount.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    PlatformImplement = require('PlatformImplement');

cc.Class({
    'extends': cc.Component,

    properties: {
        statusEmailLabel: cc.Label,
        statusSmsLabel: cc.Label,
        activeEmailButton: cc.Button,
        activeSmsButton: cc.Button,
        emailLabel: cc.Label,
        SmsLabel: cc.Label
    },
    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.SmsLabel.string = AuthUser.username;
        this.emailLabel.string = AuthUser.email;
        if (AuthUser.email_active) {
            this.statusEmailLabel.string = 'Đã kích hoạt email';
            this.activeEmailButton.interactable = false;
        } else {
            this.statusEmailLabel.string = 'Chưa kích hoạt email';
            this.activeEmailButton.interactable = true;
        }
        if (AuthUser.mobile_active_time) {
            this.statusSmsLabel.string = 'Đã kích hoạt SMS';
            this.activeSmsButton.interactable = false;
        } else {
            this.statusSmsLabel.string = 'Chưa kích hoạt SMS';
            this.activeSmsButton.interactable = true;
        }
    },

    activeEmail: function activeEmail(event) {
        NetworkManager.Http.fetch('POST', Url.Http.USER_ACTIVE_EMAIL, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }).success(function () {
            UiManager.openModal('Đã gửi thư kích hoạt đến email của bạn, hãy kiểm tra ở hòm thư!');
        }).setWaitingButton(event.target);
    },

    activeSms: function activeSms(event) {
        NetworkManager.Http.fetch('GET', Url.Http.USER_ACTIVE_PHONE, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken
        }).success(function (respDone) {
            var info = respDone.data;
            UiManager.openConfirmModal(info.note, {
                oke_fn: function oke_fn() {
                    PlatformImplement.guiTinNhan(info.number, info.syntax);
                }
            });
        }).setWaitingButton(event.target);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","UiManager":"UiManager","Url":"Url"}],"TabChangePassword":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7e2abgleVxNA4bbKKCnyJTI', 'TabChangePassword');
// scripts\components\profile\TabChangePassword.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        oldPassEditBox: cc.EditBox,
        newPassEditBox: cc.EditBox,
        rePassEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.clearInput();
    },

    onButtonChangePass: function onButtonChangePass(event) {
        var self = this;

        if (this.oldPassEditBox.string === '' || this.rePassEditBox.string === '' || this.newPassEditBox.string === '') {
            return UiManager.openModal('Bạn cần nhập đầy đủ thông tin để đổi.');
        }
        if (this.rePassEditBox.string !== this.newPassEditBox.string) {
            return UiManager.openModal('Mật khẩu mới nhập không khớp.');
        }
        if (this.oldPassEditBox.string === this.newPassEditBox.string) {
            return UiManager.openModal('Mật khẩu cũ và mới trùng nhau.');
        }

        NetworkManager.Http.fetch('POST', Url.Http.USER_CHANGE_PASSWORD, {
            username: AuthUser.username,
            old_pass: this.oldPassEditBox.string,
            new_pass: this.newPassEditBox.string
        }).success(function () {
            self.clearInput();
            UiManager.openModal('Bạn đã thay đổi mật khẩu thành công.');
        }).setWaitingButton(event.target);
    },

    clearInput: function clearInput() {
        this.oldPassEditBox.string = '';
        this.newPassEditBox.string = '';
        this.rePassEditBox.string = '';
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"TabInformation":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'c5cc0qSoXFPpKnZc38eXbK8', 'TabInformation');
// scripts\components\profile\TabInformation.js

var Url = require('Url'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    NetworkManager = require('NetworkManager'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        emailEditBox: cc.EditBox,
        userNameLabel: cc.Label,
        fullNameEditBox: cc.EditBox
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.userNameLabel.string = AuthUser.username;
        this.emailEditBox.string = AuthUser.email || '';
        this.fullNameEditBox.string = AuthUser.display_name;
    },

    onButtonChangeInfo: function onButtonChangeInfo(event) {
        var emailInput = '',
            fullName = '',
            firstName = '',
            lastName = '';

        if (this.emailEditBox.string === '' || this.fullNameEditBox.string === '') {
            UiManager.openModal('Bạn cần nhập đầy đủ thông tin để đổi.');
        } else {
            fullName = this.fullNameEditBox.string.split(' ');
            firstName = fullName[0];
            lastName = fullName[1] || '';
            fullName = this.fullNameEditBox.string;
            emailInput = this.emailEditBox.string;

            NetworkManager.Http.fetch('POST', Url.Http.USER_UPDATE_INFO, {
                username: AuthUser.username,
                email: emailInput,
                firstname: firstName,
                lastname: lastName,
                accesstoken: AuthUser.accesstoken
            }).success(function (accResp) {
                AuthUser.updateInfo(accResp.data);
                EventDispatcher.dispatchEvent(EventDispatcherConstant.PROFILE.UPDATE_INFO);
                UiManager.openModal('Bạn đã thay đổi thông tin thành công.');
            }).setWaitingButton(event.target);
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","NetworkManager":"NetworkManager","UiManager":"UiManager","Url":"Url"}],"TabSupport":[function(require,module,exports){
"use strict";
cc._RFpush(module, '82c28LctCtG26l4XaWMs/St', 'TabSupport');
// scripts\components\message_box\TabSupport.js

var PlatformImplement = require('PlatformImplement'),
    NetworkManager = require('NetworkManager'),
    UiManager = require('UiManager'),
    AuthUser = require('AuthUser'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        mobileLabel: cc.Label,
        fbPageLabel: cc.Label,

        titleEditBox: cc.EditBox,
        contentEditBox: cc.EditBox
    },

    fetchContactInfo: function fetchContactInfo() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.CONTACT_INFO, {}, {
            cache: 1800
        }).success(function (respContact) {
            that.contactInfo = respContact.data;
            that.mobileLabel.string = respContact.data.mobile;
            that.fbPageLabel.string = respContact.data.fb_page;
        });
    },

    callHotline: function callHotline() {
        if (this.contactInfo) {
            PlatformImplement.callNumberPhone(this.contactInfo.mobile);
        }
    },

    openFacebookPage: function openFacebookPage() {
        if (this.contactInfo) {
            PlatformImplement.openWebUrl(this.contactInfo.fb_page);
        }
    },

    sendFeedback: function sendFeedback(event) {
        var self = this,
            title = this.titleEditBox.string,
            body = this.contentEditBox.string;
        if (this.titleEditBox.string === '' || this.contentEditBox.string === '') {
            UiManager.openModal('Bạn cần nhập đầy đủ thông tin gửi.');
        } else {
            NetworkManager.Http.fetch('POST', Url.Http.FEEDBACK, {
                accesstoken: AuthUser.accesstoken,
                username: AuthUser.username,
                subject: title,
                content: body
            }).success(function () {
                self.clearInputFeedback();
                UiManager.openModal('Bạn đã gửi phản hồi thành công.');
            }).setWaitingButton(event.target);
        }
    },

    clearInputFeedback: function clearInputFeedback() {
        this.contentEditBox.string = '';
        this.titleEditBox.string = '';
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.clearInputFeedback();
    }

});

cc._RFpop();
},{"AuthUser":"AuthUser","NetworkManager":"NetworkManager","PlatformImplement":"PlatformImplement","UiManager":"UiManager","Url":"Url"}],"TabVatPham":[function(require,module,exports){
"use strict";
cc._RFpush(module, '8b43cEpHHZFHaDJfq3EjFxY', 'TabVatPham');
// scripts\components\doi_thuong\TabVatPham.js

var NetworkManager = require('NetworkManager'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemVatPhamPrefab: cc.Prefab,
        contentNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.loadDataItems();
    },

    loadDataItems: function loadDataItems() {
        var self = this;
        self.contentNode.removeAllChildren();
        NetworkManager.Http.fetch('GET', Url.Http.DOI_THUONG_GET_ITEMS_INFO, {}, {
            cache: 1800
        }).success(function (respDone) {
            var itemVatPham;
            for (var i = 0; i < respDone.data.length; i += 1) {
                itemVatPham = cc.instantiate(self.itemVatPhamPrefab);
                itemVatPham.getComponent('ItemVatPham').updateData(respDone.data[i]);
                self.contentNode.addChild(itemVatPham);
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"NetworkManager":"NetworkManager","Url":"Url"}],"TabView":[function(require,module,exports){
"use strict";
cc._RFpush(module, '0c3f6P5cAlLjKotwwKYbxJx', 'TabView');
// scripts\ui\TabView.js

cc.Class({
    'extends': cc.Component,

    properties: {
        activeSprite: {
            'default': null,
            type: cc.SpriteFrame
        },
        normalSprite: {
            'default': null,
            type: cc.SpriteFrame
        },
        activeColor: {
            'default': new cc.Color(255, 255, 255)
        },
        normalColor: {
            'default': new cc.Color(255, 0, 0)
        },
        selectEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        var tabsNode = this.node.getChildByName('Tabs'),
            tabs = tabsNode.children,
            that = this;
        for (var i = 0; i < tabs.length; i += 1) {
            tabs[i].on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        }
        tabsNode.on('child-removed', function (event) {
            var contentsNode = that.node.getChildByName('Contents');
            contentsNode.getChildByName(event.detail.name).removeFromParent();
        });
    },

    onEnable: function onEnable() {
        var tabs = this.node.getChildByName('Tabs').children;
        // trigger first tab to be active
        if (tabs.length > 0 && !this.activeTabName) {
            this.activeByName(tabs[0].name);
        }
    },

    addTab: function addTab(tabNode, contentNode) {
        var tabs = this.node.getChildByName('Tabs'),
            contents = this.node.getChildByName('Contents'),
            tabName = 'Tab' + tabs.children.length;
        contentNode.name = tabNode.name = tabName;
        tabs.addChild(tabNode);
        tabNode.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        contents.addChild(contentNode);
    },

    removeAllTabs: function removeAllTabs() {
        this.node.getChildByName('Tabs').removeAllChildren();
        this.node.getChildByName('Contents').removeAllChildren();
    },

    _onTouchBegan: function _onTouchBegan(event) {
        this._activeByName(event.target.name);
        event.stopPropagation();
    },

    _activeByName: function _activeByName(name) {
        var tabs = this.node.getChildByName('Tabs').children,
            contentsNode = this.node.getChildByName('Contents'),
            i,
            sprite,
            contentNode,
            labelNode,
            that = this;
        if (this.activeTabName === name) {
            return;
        }
        for (i = 0; i < tabs.length; i += 1) {
            contentNode = contentsNode.getChildByName(tabs[i].name);
            labelNode = tabs[i].getComponentInChildren(cc.Label).node;
            sprite = tabs[i].getComponent(cc.Sprite);
            if (tabs[i].name === name) {
                this.activeTabName = name;
                contentNode.active = true;
                labelNode.color = this.activeColor;
                sprite.spriteFrame = this.activeSprite;
                // contentNode.scaleX = 0;
                // contentNode.runAction(cc.spawn([cc.scaleTo(0.05, 1, 1), cc.fadeIn(0.05)]));

                that.selectEvents.forEach(function (selectEvent) {
                    selectEvent.emit([tabs[i], contentNode]);
                });
            } else {
                contentNode.active = false;
                labelNode.color = this.normalColor;
                sprite.spriteFrame = this.normalSprite;
            }
        }
    },

    activeByName: function activeByName(name) {
        var selectedTab = this.node.getChildByName('Tabs').getChildByName(name),
            buttonComponent = selectedTab.getComponent(cc.Button),
            i;
        this._activeByName(name);
        if (buttonComponent) {
            for (i = 0; i < buttonComponent.clickEvents.length; i += 1) {
                buttonComponent.clickEvents[i].emit(selectedTab);
            }
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{}],"TaiXiuConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '9ac4egzr6RO9bsrOPuuKq0v', 'TaiXiuConstant');
// scripts\games\tai_xiu\TaiXiuConstant.js

var Utils = require('Utils');

module.exports = {
    Action: {
        BETTING: 1,
        CHANGE_STATE: 5,
        UPDATE_POTS: 9,
        PING: 10
    },
    GameState: {
        NONE: 0,
        EFFECT: 1,
        PLAYER_BETTING: 2,
        FINISH: 4,
        FINALIZING: 5
    },
    GameStateName: {
        BETTING: 'Người chơi đặt cửa!',
        FINISH: 'Tính tiền!'
    },
    Pot: {
        BIG: {
            ID: 0,
            NAME: 'Tài'
        },
        LITTLE: {
            ID: 1,
            NAME: 'Xỉu'
        },

        findById: function findById(potId) {
            potId = parseInt(potId, 10);
            return Utils.Object.findObject(this, 'ID', potId);
        }
    },
    Event: {
        CHANGE_STATE: 'in_game.tai_xiu.change_state',
        EFFECT_STATE: 'in_game.tai_xiu.change_state.effect',
        PLAYER_BETTING_STATE: 'in_game.tai_xiu.change_state.player_betting',
        UPDATE_POTS: 'in_game.tai_xiu.update_pots',
        BETTING_SUCCESS: 'in_game.tai_xiu.betting_success',
        UPDATE_TEMP_BETTING: 'in_game.tai_xiu.update_temp_betting',
        FINISH: 'in_game.tai_xiu.finish'
    },
    TimeoutId: {
        SWITCH_CURRENCY: 'SWITCH_CURRENCY',
        ROTATE_DICE: 'ROTATE_DICE',
        SHOW_HISTORY_TRAY: 'SHOW_HISTORY_TRAY'
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"TaiXiuGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4ca13QfmglIArJ0xJoN4weZ', 'TaiXiuGameManager');
// scripts\games\tai_xiu\TaiXiuGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    TaiXiuConstant = require('TaiXiuConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    TaiXiuGameManager;

TaiXiuGameManager = Utils.Class({

    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this.DELAYED_COMMANDS = [SmartFoxConstant.Command.MESSAGE.ID];

        this.idleTime = -1;
        this.pingIntervalTime = -1;
        this.pingIntervalId = null;
        this.pingEnabled = false;
        this.lastPingTime = -1;
        this.history = [];
        this._setGameState(TaiXiuConstant.GameState.NONE);
        this._reinitDataEachRound();

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(TaiXiuConstant.Action.BETTING, this.onBettingSuccess, this);
        this.eventDispatchers.playCmd.addEventListener(TaiXiuConstant.Action.UPDATE_POTS, this.onUpdatePots, this);
        this.eventDispatchers.playCmd.addEventListener(TaiXiuConstant.Action.CHANGE_STATE, this.onChangeState, this);
    },

    startGame: function startGame() {
        this._reinitDataEachRound();
    },

    destroy: function destroy() {
        this.$super.destroy.call(this);
        this._cancelPing();
    },

    _reinitDataEachRound: function _reinitDataEachRound() {
        this.bettingTimeLeft = 0;
        this.pots = {};
        this.current.bettingInfo = {};
        this.current.tempBettingInfo = {};
    },

    // ============================================================
    // Send API
    // ============================================================

    bet: function bet(pot, betting, currency) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(TaiXiuConstant.Action.BETTING),
            pot: NetworkManager.SmartFox.type.byte(pot),
            money: NetworkManager.SmartFox.type.long(betting),
            currency: NetworkManager.SmartFox.type.utfString(currency)
        });
    },

    enablePing: function enablePing() {
        this.pingEnabled = true;
        this._schedulePing();
    },

    disablePing: function disablePing() {
        this.pingEnabled = false;
        this._cancelPing();
    },

    _isEagerToPing: function _isEagerToPing() {
        return this.lastPingTime < 0 || Date.now() - this.lastPingTime >= this.pingIntervalTime;
    },

    _ping: function _ping() {
        this.lastPingTime = Date.now();
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(TaiXiuConstant.Action.PING)
        });
    },

    _schedulePing: function _schedulePing() {
        if (!this.pingIntervalId && this.pingIntervalTime > 0 && this.pingEnabled) {
            this.pingIntervalId = Utils.Scheduler.setInterval(this._ping.bind(this), this.pingIntervalTime, this._isEagerToPing());
        }
    },

    _cancelPing: function _cancelPing() {
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
            this.pingIntervalId = null;
        }
    },

    // ============================================================
    // Receive API
    // ============================================================

    onUpdateGame: function onUpdateGame(params) {
        this.idleTime = params.idleTime;
        if (this.idleTime > 0) {
            this.pingIntervalTime = this.idleTime / 2.5;
            this._schedulePing();
        }

        if (params.potsList) {
            this.pots = params.potsList;
        }

        if (params.gameState === TaiXiuConstant.GameState.PLAYER_BETTING && params.time >= 0) {
            this.bettingTimeLeft = Math.max(Date.now() + params.time - (params.__execInfo__ && params.__execInfo__.dt || 0), 0);
        } else if (params.gameState === TaiXiuConstant.GameState.FINISH && params.time >= 0) {
            this.waitingForNewGameTimeLeft = Math.max(Date.now() + params.time - (params.__execInfo__ && params.__execInfo__.dt || 0), 0);
        }
        this._setGameState(params.gameState);
    },

    onBettingSuccess: function onBettingSuccess(params) {
        if (this.isCurrentPlayer(params.username)) {
            this.current.bettingInfo[params.currency] = this.current.bettingInfo[params.currency] || {};
            this.current.bettingInfo[params.currency][params.pot] = this.current.bettingInfo[params.currency][params.pot] || 0;
            this.current.bettingInfo[params.currency][params.pot] += params.money;
            this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.BETTING_SUCCESS);
        }
    },

    onUpdatePots: function onUpdatePots(params) {
        this.bettingTimeLeft = Math.max(Date.now() + params.time - (params.__execInfo__ && params.__execInfo__.dt || 0), 0);
        cc.js.mixin(this.pots, params.potsList);
        this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.UPDATE_POTS);
    },

    onChangeState: function onChangeState(params) {
        cc.js.mixin(this.pots, params.potsList);
        this._setGameState(params.gameState);
        switch (this.gameState) {
            case TaiXiuConstant.GameState.EFFECT:
                this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.EFFECT_STATE, params);
                break;

            case TaiXiuConstant.GameState.PLAYER_BETTING:
                this.bettingTimeLeft = Math.max(Date.now() + params.time - (params.__execInfo__ && params.__execInfo__.dt || 0), 0);
                this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.PLAYER_BETTING_STATE);
                break;
        }
    },

    onFinishGame: function onFinishGame(params) {
        this._setGameState(TaiXiuConstant.GameState.FINISH);

        // save history
        if (this.isCurrentPlayer(params.player) && !Utils.Object.isEmpty(this.current.bettingInfo)) {
            var potWin = params.potWin && params.potWin[0],
                currency,
                potBettingMap,
                historyItem;
            if (Utils.Type.isNumber(potWin)) {
                for (currency in this.current.bettingInfo) {
                    potBettingMap = this.current.bettingInfo[currency];
                    historyItem = {
                        time: Utils.Date.currentTime(),
                        potWin: potWin,
                        potBettingMap: potBettingMap,
                        currency: currency,
                        moneyExchange: params.player[currency].moneyExchange
                    };
                    this.history.unshift(historyItem);
                }
            }
        }

        this.waitingForNewGameTimeLeft = Math.max(Date.now() + params.time - (params.__execInfo__ && params.__execInfo__.dt || 0), 0);

        this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.FINISH, params);
    },

    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.CHANGE_STATE);
        }
    },

    // ============================================================
    // Action API
    // ============================================================

    addTempBetting: function addTempBetting(pot, betting, currency) {
        if (this.current.tempBettingInfo.pot !== pot || this.current.tempBettingInfo.currency !== currency) {
            this.current.tempBettingInfo = {
                pot: pot,
                currency: currency,
                betting: 0
            };
        }
        this.current.tempBettingInfo.betting += betting;
        this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.UPDATE_TEMP_BETTING);
    },

    cancelTempBetting: function cancelTempBetting() {
        this.current.tempBettingInfo = {};
        this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.UPDATE_TEMP_BETTING);
    },

    acceptTempBetting: function acceptTempBetting() {
        if (this.current.tempBettingInfo.currency && this.current.tempBettingInfo.betting > 0 && this.current.tempBettingInfo.pot >= 0) {
            this.bet(this.current.tempBettingInfo.pot, this.current.tempBettingInfo.betting, this.current.tempBettingInfo.currency);
        }
        this.current.tempBettingInfo = {};
        this.eventDispatchers.local.dispatchEvent(TaiXiuConstant.Event.UPDATE_TEMP_BETTING);
    },

    getFormattedBettingTimeLeft: function getFormattedBettingTimeLeft() {
        return this._formatTime((this.bettingTimeLeft - Date.now()) / 1000);
    },

    getFormattedWaitingForNewGameTimeLeft: function getFormattedWaitingForNewGameTimeLeft() {
        return this._formatTime((this.waitingForNewGameTimeLeft - Date.now()) / 1000);
    },

    getFormattedCurrentTimeLeft: function getFormattedCurrentTimeLeft() {
        var time = '00:00';
        if (this.gameState === TaiXiuConstant.GameState.PLAYER_BETTING) {
            time = this.getFormattedBettingTimeLeft();
        } else if (this.gameState === TaiXiuConstant.GameState.FINISH) {
            time = this.getFormattedWaitingForNewGameTimeLeft();
        }
        return time;
    },

    _formatTime: function _formatTime(elapsedTime) {
        if (elapsedTime >= 0) {
            elapsedTime = Math.floor(elapsedTime);
            var mins = Math.floor(elapsedTime / 60),
                seconds = elapsedTime % 60;
            return Utils.Number.fillZero(mins, 2) + ':' + Utils.Number.fillZero(seconds, 2);
        }
        return '00:00';
    },

    getStateLabel: function getStateLabel() {
        var label = '';
        if (this.gameState === TaiXiuConstant.GameState.PLAYER_BETTING) {
            label = TaiXiuConstant.GameStateName.BETTING;
        } else if (this.gameState === TaiXiuConstant.GameState.FINISH) {
            label = TaiXiuConstant.GameStateName.FINISH;
        }
        return label;
    }

});

module.exports = TaiXiuGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","TaiXiuConstant":"TaiXiuConstant","Utils":"Utils"}],"TinhNangManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3eb06XEuWZEOoZsHffrvkaY', 'TinhNangManager');
// scripts\TinhNangManager.js

var EventDispatcherConstant = require('EventDispatcherConstant'),
    EventDispatcher = require('EventDispatcher'),
    CommonConstant = require('CommonConstant'),
    Utils = require('Utils');

var TinhNangManager = {
    tn: [],
    ex_tn: ['ni'],
    choPhep: function choPhep(tn) {
        if (this.tn && this.tn.indexOf(tn) < 0) {
            return false;
        } else if (this.ex_tn.indexOf(tn) >= 0) {
            return false;
        }
        return true;
    }
};

EventDispatcher.addEventListener(CommonConstant.PushMessageType.TAT_TN.EVENT, function (params) {
    if (params && params.content) {
        var content = JSON.parse(params.content),
            i,
            tn,
            gid;
        // in native must check 'ch' param
        if (content && content.tn) {
            TinhNangManager.tn = [];
            for (i = 0; i < content.tn.length; i += 2) {
                tn = content.tn.substr(i, 2);
                gid = parseInt(tn);
                TinhNangManager.tn.push(gid > 0 ? gid : tn);
            }
            if (TinhNangManager.tn.indexOf('hi') < 0) {
                // if show iap only, disable deposit sms, card, xu functions
                Utils.Array.remove(TinhNangManager.tn, 'ns');
                Utils.Array.remove(TinhNangManager.tn, 'nr');
                Utils.Array.remove(TinhNangManager.tn, 'ix');
            }

            EventDispatcher.dispatchEvent(EventDispatcherConstant.TINH_NANG.NEW);
        }
    }
});

module.exports = TinhNangManager;

cc._RFpop();
},{"CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","Utils":"Utils"}],"TinhNang":[function(require,module,exports){
"use strict";
cc._RFpush(module, '1a236AwPxpFVKwaEuyA3M4Z', 'TinhNang');
// scripts\ui\TinhNang.js

var TinhNangManager = require('TinhNangManager'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

var TinhNangNode = cc.Class({
    name: 'TinhNangNode',
    properties: {
        target: {
            'default': null,
            type: cc.Node
        },
        tinhNang: {
            'default': ''
        }
    },

    init: function init() {
        this.targetParent = this.target.parent;
        this.targetIndex = this.target.getSiblingIndex();
    },
    remove: function remove() {
        if (this.target.parent) {
            this.target.removeFromParent(false);
        }
    },
    add: function add() {
        if (!this.target.parent) {
            this.targetParent.addChild(this.target);
            this.target.setSiblingIndex(this.targetIndex);
        }
    }
});

cc.Class({
    'extends': cc.Component,

    properties: {
        tinhNangNodes: {
            'default': [],
            type: TinhNangNode
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.tinhNangNodes.forEach(function (tinhNangNode) {
            tinhNangNode.init();
        });
        this.kiemTraTinhNang();
        EventDispatcher.addEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.kiemTraTinhNang, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.TINH_NANG.NEW, this.kiemTraTinhNang, this);
    },

    kiemTraTinhNang: function kiemTraTinhNang() {
        this.tinhNangNodes.forEach(function (tinhNangNode) {
            if (TinhNangManager.choPhep(tinhNangNode.tinhNang)) {
                tinhNangNode.add();
            } else {
                tinhNangNode.remove();
            }
        });
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{"EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","TinhNangManager":"TinhNangManager"}],"ToggleButton":[function(require,module,exports){
"use strict";
cc._RFpush(module, '7f9011RBSJDs5SWIvKKzV57', 'ToggleButton');
// scripts\ui\ToggleButton.js

cc.Class({
    'extends': cc.Component,

    properties: {
        enableSprite: cc.SpriteFrame,
        disableSprite: cc.SpriteFrame,
        isEnable: false,
        toggleEvents: {
            'default': [],
            type: cc.Component.EventHandler
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.toogleNode = this.node.getChildByName('ToogleNode');
        this.node.on(cc.Node.EventType.TOUCH_START, this.toggleState, this);
        this.updateState();
    },

    setEnable: function setEnable() {
        var that = this,
            x = (this.node.width - this.toogleNode.width) / 2;
        this.isEnable = true;
        this.toogleNode.runAction(cc.moveTo(0.1, cc.p(x, 0)));
        this.node.getComponent(cc.Sprite).spriteFrame = this.enableSprite;
        that.toggleEvents.forEach(function (toggleEvent) {
            toggleEvent.emit([that]);
        });
    },

    setDisable: function setDisable() {
        var that = this,
            x = (this.toogleNode.width - this.node.width) / 2;
        this.isEnable = false;
        this.toogleNode.runAction(cc.moveTo(0.1, cc.p(x, 0)));
        this.node.getComponent(cc.Sprite).spriteFrame = this.disableSprite;
        that.toggleEvents.forEach(function (toggleEvent) {
            toggleEvent.emit([that]);
        });
    },

    updateState: function updateState() {
        if (this.isEnable) {
            this.setEnable();
        } else {
            this.setDisable();
        }
    },

    toggleState: function toggleState() {
        if (this.isEnable) {
            this.setDisable();
        } else {
            this.setEnable();
        }
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"ToggleCurrency":[function(require,module,exports){
"use strict";
cc._RFpush(module, '01ae6xN/hFGwLO3WDtJy4VN', 'ToggleCurrency');
// scripts\components\games\ui\ToggleCurrency.js

var Utils = require('Utils'),
    CommonConstant = require('CommonConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        currencySpriteFrames: {
            'default': [],
            type: cc.SpriteFrame
        },
        clickable: true
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.index = 0;
        this.switchTo(this.index);
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    switchTo: function switchTo(indexOrCurrency) {
        var currencyType, index;
        if (Utils.Type.isNumber(indexOrCurrency)) {
            index = indexOrCurrency;
        } else if (Utils.Type.isString(indexOrCurrency)) {
            currencyType = CommonConstant.CurrencyType.findByName(indexOrCurrency);
            if (!currencyType) {
                return;
            }
            index = currencyType.ID;
        } else if (Utils.Type.isObject(indexOrCurrency)) {
            index = indexOrCurrency.ID;
        } else {
            return;
        }

        var sprite = this.node.getComponent(cc.Sprite);
        if (sprite && this.index >= 0 && this.index < this.currencySpriteFrames.length) {
            this.index = index;
            sprite.spriteFrame = this.currencySpriteFrames[this.index];
        }
    },

    next: function next() {
        this._incrIndex();
        this.switchTo(this.index);
    },

    back: function back() {
        this._incrIndex();
        this.switchTo(this.index);
    },

    click: function click() {
        if (this.clickable) {
            this.next();
        }
    },

    _incrIndex: function _incrIndex() {
        this.index += 1;
        if (this.index >= this.currencySpriteFrames.length) {
            this.index = 0;
        }
    },

    _decrIndex: function _decrIndex() {
        this.index -= 1;
        if (this.index <= 0) {
            this.index = this.currencySpriteFrames.length - 1;
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","Utils":"Utils"}],"TopPanelInGame":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'af2a0JqofRONrQCT8xE88VK', 'TopPanelInGame');
// scripts\components\games\ui\TopPanelInGame.js

var NetworkManager = require('NetworkManager'),
    BaseMainGameplay = require('BaseMainGameplay'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    CommonConstant = require('CommonConstant'),
    GameManagerConstant = require('GameManagerConstant'),
    LOCAL_CONSTANTS = {
    CHAT_CACHE: {
        KEY: 'top_panel_in_game.chat',
        MAX_ITEMS: 8,
        DEFAULT_MESSAGES: ['Nhanh đi anh', 'Nghĩ gì mà lâu vậy?', 'Where are you now?', 'Câu giờ max level', 'Sao lâu vậy má?', 'Khi nào nghĩ xong thì phone em nha', 'Lót dép hóng', 'Lêu lêu']
    }
};

cc.Class({
    'extends': cc.Component,

    properties: {
        bettingLabel: cc.Label,
        optionLabel: cc.Label,

        backdropNode: cc.Node,
        menuDropDownNode: cc.Node,
        toggleChatButton: cc.Button,

        // chatHistoryLabel: cc.Label,
        chatHistoryLabel: cc.RichText,
        chatPanelNode: cc.Node,
        chatControlPanelNode: cc.Node,
        chatEditBox: cc.EditBox,
        chatScrollView: cc.ScrollView,
        quickChatNode: cc.Node,
        quickChatTemplateButtonNode: cc.Node,
        mainUsernameColor: cc.Color,
        normalUsernameColor: cc.Color,

        checkboxQuitGameNode: cc.Node,
        registerQuitGameNode: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        var self = this;

        if (self.chatPanelNode) {
            self.chatEditBox.enabled = false;
            self.chatPanelNode.opacity = 0;
            self.chatPanelNode.active = true;
        }

        self.menuDropDownNode.opacity = 0;
        self.menuDropDownNode.active = true;
        self.backdropNode.active = true;

        self._timeoutId = setTimeout(function () {
            if (!self.isValid) {
                return;
            }

            self.menuDropDownNode.active = false;
            self.menuDropDownNode.opacity = 255;
            self.backdropNode.active = false;

            if (self.chatPanelNode) {
                self.chatControlPanelNodePosition = self.chatControlPanelNode.position;
                self.chatControlPanelNodeHidePosition = cc.v2(self.chatControlPanelNode.position.x, self.chatControlPanelNode.position.y - self.chatControlPanelNode.height);

                self.chatScrollViewPosition = self.chatScrollView.node.position;
                self.chatScrollViewHidePosition = cc.v2(self.chatScrollView.node.position.x, self.chatScrollView.node.position.y + self.chatScrollView.node.height);

                self.chatScrollView.node.getComponent(cc.Widget).enabled = false;
                self.chatControlPanelNode.getComponent(cc.Widget).enabled = false;

                self.chatPanelNode.active = false;
                self.chatPanelNode.opacity = 255;
                self.chatEditBox.enabled = true;
            }
        }, 500);
    },

    onDestroy: function onDestroy() {
        if (this.gameManager) {
            this.gameManager.eventDispatchers.local.removeEventListener(GameManagerConstant.Event.UPDATE_REGISTER_QUIT_GAME_STATUS, this.onUpdateRegisterQuitGameStatus, this);

            this.gameManager.eventDispatchers.local.removeEventListener(GameManagerConstant.Event.UPDATE_BETTING_VALUES, this.onUpdateBettingValues, this);

            NetworkManager.SmartFox.offPublicMessage(this.onPublicMessage);
        }

        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            this._timeoutId = null;
        }
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init(sceneScript) {
        if (!(sceneScript instanceof BaseMainGameplay.constructor)) {
            throw 'sceneScript must be an instance of "BaseMainGameplay"';
        }

        var self = this;

        this.sceneScript = sceneScript;
        this.gameRuntimeConfigs = this.sceneScript.gameRuntimeConfigs;
        this.gameManager = this.sceneScript.gameManager;
        this.game = this.gameRuntimeConfigs.game;

        var configs = this.game && this.game.CONFIG && this.game.CONFIG.TOP_PANEL_IN_GAME;
        if (configs) {
            if (!configs.CHAT) {
                this.toggleChatButton.node.active = false;
                this.toggleChatButton = null;

                this.chatPanelNode.active = false;
                this.chatPanelNode = null;
            }

            if (!configs.REGISTER_QUIT_GAME) {
                this.registerQuitGameNode.active = false;
                this.registerQuitGameNode = null;
            }
        }

        this.chatHistoryLabel.string = '';
        this._createAllQuickChatButtonsFromCache();

        this.setBettingLabel('');
        this.setOptionLabel('');

        if (this.toggleChatButton) {
            this.onPublicMessage = (function (event) {
                var roomId = event && event.room && event.room.id,
                    senderName = event && event.sender && event.sender.name,
                    senderDisplayName = senderName,
                    message,
                    playerNode;
                if (this.gameManager && this.gameManager.roomId === roomId && senderName) {
                    playerNode = this.sceneScript.findPlayerNodeByName(senderName);
                    message = event.message;
                    if (playerNode) {
                        senderDisplayName = playerNode.player && playerNode.player.data && playerNode.player.data.displayName || senderDisplayName;
                        playerNode.setChatMessage(message);
                    }
                    this._addHistoryItem(senderDisplayName, message);
                }
            }).bind(this);
            NetworkManager.SmartFox.onPublicMessage(this.onPublicMessage);
        }

        if (this.checkboxQuitGameNode) {
            this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.UPDATE_REGISTER_QUIT_GAME_STATUS, this.onUpdateRegisterQuitGameStatus, this);
        }

        this.gameManager.eventDispatchers.local.addEventListener(GameManagerConstant.Event.UPDATE_BETTING_VALUES, this.onUpdateBettingValues, this);

        cc.eventManager.addListener({
            event: cc.EventListener.KEYBOARD,
            onKeyReleased: function onKeyReleased(keyCode) {
                switch (keyCode) {
                    case cc.KEY.enter:
                        self.sendChatMessage();
                        break;
                }
            }
        }, this.chatEditBox.node);

        this.onUpdateBettingValues();
        this.onUpdateOption();
    },

    openPopupNapXien: function openPopupNapXien() {
        UiManager.openNapXienModal();
    },

    openSettings: function openSettings() {
        this.hideMenu();
        UiManager.openPopupSettings();
    },

    openHelp: function openHelp() {
        this.hideMenu();
        this.gameManager.openHelpModal();
    },

    openChatPanel: function openChatPanel() {
        var self = this;

        if (!self.chatScrollViewPosition) {
            return;
        }

        self.chatScrollView.node.stopAllActions();
        self.chatControlPanelNode.stopAllActions();

        self.chatScrollView.node.position = self.chatScrollViewHidePosition;
        self.chatControlPanelNode.position = self.chatControlPanelNodeHidePosition;
        this.chatPanelNode.active = true;

        self.chatScrollView.node.runAction(cc.sequence(cc.moveTo(0.2, self.chatScrollViewPosition).easing(cc.easeIn(3))));

        self.chatControlPanelNode.runAction(cc.sequence(cc.moveTo(0.2, self.chatControlPanelNodePosition).easing(cc.easeIn(3))));
    },

    closeChatPanel: function closeChatPanel() {
        var self = this;

        if (!self.chatScrollViewPosition) {
            return;
        }

        self.chatScrollView.node.stopAllActions();
        self.chatControlPanelNode.stopAllActions();

        self.chatScrollView.node.position = self.chatScrollViewPosition;
        self.chatScrollView.node.runAction(cc.sequence(cc.moveTo(0.2, self.chatScrollViewHidePosition).easing(cc.easeIn(3))));

        self.chatControlPanelNode.position = self.chatControlPanelNodePosition;
        self.chatControlPanelNode.runAction(cc.sequence(cc.moveTo(0.2, self.chatControlPanelNodeHidePosition).easing(cc.easeIn(3)), cc.callFunc(function () {
            self.chatPanelNode.active = false;
        })));
    },

    toggleMenu: function toggleMenu() {
        this.menuDropDownNode.active = !this.menuDropDownNode.active;
        this.backdropNode.active = this.menuDropDownNode.active;
    },

    hideMenu: function hideMenu() {
        this.menuDropDownNode.active = false;
        this.backdropNode.active = false;
    },

    openLeaveRoomConfirmModal: function openLeaveRoomConfirmModal() {
        this.hideMenu();
        UiManager.openConfirmModal('Khi thoát khỏi phòng, bạn sẽ bị tính như thua cuộc và bị trừ tiền. Bạn có chắc vẫn muốn thoát không?', {
            oke_fn: (function () {
                this.gameManager.leaveRoom();
            }).bind(this)
        });
    },

    toggleRegisterQuitGame: function toggleRegisterQuitGame() {
        var player = this.gameManager.current.player;
        if (player) {
            if (player.data.isRegisteredToQuitGame) {
                this.gameManager.deregisterQuitGame();
            } else {
                this.gameManager.registerQuitGame();
            }
        }
        this.hideMenu();
    },

    onUpdateRegisterQuitGameStatus: function onUpdateRegisterQuitGameStatus() {
        var player = this.gameManager.current.player;
        if (player) {
            this.checkboxQuitGameNode.active = player.data.isRegisteredToQuitGame;
        }
    },

    onUpdateBettingValues: function onUpdateBettingValues() {
        if (this.gameManager.bettingInfo.currency) {
            var gameName = this.gameRuntimeConfigs && this.gameRuntimeConfigs.game && this.gameRuntimeConfigs.game.CONFIG && this.gameRuntimeConfigs.game.CONFIG.NAME,
                prefix = (gameName || 'Mức cược') + ': ';
            this.setBettingLabel(prefix + Utils.Number.abbreviate(this.gameManager.bettingInfo.betting) + ' ' + CommonConstant.CurrencyType.findByName(this.gameManager.bettingInfo.currency).DISPLAY_NAME);
        }
    },

    onUpdateOption: function onUpdateOption() {
        if (this.sceneScript) {
            var topPanelInGameData = this.sceneScript.topPanelInGameData;
            if (topPanelInGameData) {
                var optionLabel = topPanelInGameData.optionLabel || '';
                this.setOptionLabel(optionLabel);
            }
        }
    },

    setBettingLabel: function setBettingLabel(text) {
        this.bettingLabel.string = text;
    },

    setOptionLabel: function setOptionLabel(text) {
        this.optionLabel.string = text;
    },

    sendChatMessage: function sendChatMessage() {
        var msg = this.chatEditBox.string;
        this.chatEditBox.string = '';
        this._sendChatMessage(msg);
    },

    _sendChatMessage: function _sendChatMessage(message) {
        this.closeChatPanel();
        if (message) {
            this.gameManager.sendChatMessage(message);
            this._saveNewMessage(message);
        }
    },

    _addHistoryItem: function _addHistoryItem(name, message) {
        var prefix = this.chatHistoryLabel.string ? '\n' : '';
        var stringChat = '';
        if (name === AuthUser.username) {
            stringChat = prefix + '<color=#FFDE00>' + name + ':</color> ' + message;
        } else {
            stringChat = prefix + '<color=#02bbff>' + name + ':</color> ' + message;
        }
        this.chatHistoryLabel.string += stringChat;
        if (this.chatHistoryLabel.node.height < this.chatScrollView.node.height - 12) {
            this.chatScrollView.scrollToTop();
        } else {
            this.chatScrollView.scrollToBottom();
        }
    },

    _createQuickChatButton: function _createQuickChatButton(msg) {
        var node = cc.instantiate(this.quickChatTemplateButtonNode);
        node.getComponentInChildren(cc.Label).string = msg;
        node.on(cc.Node.EventType.TOUCH_END, function (event) {
            event.stopPropagation();
            this._sendChatMessage(msg);
        }, this);
        return node;
    },

    _createAllQuickChatButtons: function _createAllQuickChatButtons(msgList) {
        var i;
        this.quickChatNode.removeAllChildren();
        for (i = 0; i < msgList.length; i += 1) {
            this.quickChatNode.addChild(this._createQuickChatButton(msgList[i]));
        }
    },

    _createAllQuickChatButtonsFromCache: function _createAllQuickChatButtonsFromCache() {
        var msgList = this._getCacheMessages();
        this._createAllQuickChatButtons(msgList);
    },

    _saveNewMessage: function _saveNewMessage(msg) {
        var msgList = this._getCacheMessages();
        msgList.unshift(msg);
        msgList = this._truncateAndSaveCacheMessages(msgList);
        this._createAllQuickChatButtons(msgList);
    },

    _getCacheMessages: function _getCacheMessages() {
        var msgList = cc.sys.localStorage.getItem(LOCAL_CONSTANTS.CHAT_CACHE.KEY),
            delta,
            i;
        try {
            msgList = msgList ? JSON.parse(msgList) : [];
            if (msgList.length > LOCAL_CONSTANTS.CHAT_CACHE.MAX_ITEMS) {
                msgList = this._truncateAndSaveCacheMessages(msgList);
            }
        } catch (e) {
            msgList = [];
        }

        delta = LOCAL_CONSTANTS.CHAT_CACHE.MAX_ITEMS - msgList.length;
        if (delta) {
            for (i = 0; i < delta; i += 1) {
                msgList.unshift(LOCAL_CONSTANTS.CHAT_CACHE.DEFAULT_MESSAGES[i]);
            }
            msgList = this._truncateAndSaveCacheMessages(msgList);
        }
        return msgList;
    },

    _truncateAndSaveCacheMessages: function _truncateAndSaveCacheMessages(msgList) {
        msgList = Utils.Array.unique(msgList);
        Utils.Array.trimRight(msgList, LOCAL_CONSTANTS.CHAT_CACHE.MAX_ITEMS);
        cc.sys.localStorage.setItem(LOCAL_CONSTANTS.CHAT_CACHE.KEY, JSON.stringify(msgList));
        return msgList;
    }
});

cc._RFpop();
},{"AuthUser":"AuthUser","BaseMainGameplay":"BaseMainGameplay","CommonConstant":"CommonConstant","GameManagerConstant":"GameManagerConstant","NetworkManager":"NetworkManager","UiManager":"UiManager","Utils":"Utils"}],"TopPanelOutGameWrapper":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f51a5sD8CRM4r/97RWKCEoz', 'TopPanelOutGameWrapper');
// scripts\components\top_panel_out_game\TopPanelOutGameWrapper.js

cc.Class({
    'extends': cc.Component,

    properties: {
        topPanelOutGamePlaceHolder: cc.Node
    },

    // use this for initialization
    onLoad: function onLoad() {
        var self = this;
        cc.loader.loadRes('TopPanelOutGame', function (err, prefab) {
            var newNode = cc.instantiate(prefab);
            self.node.addChild(newNode);
            if (self.topPanelOutGamePlaceHolder) {
                newNode.setSiblingIndex(self.topPanelOutGamePlaceHolder.getSiblingIndex());
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{}],"TopPanelOutGame":[function(require,module,exports){
"use strict";
cc._RFpush(module, '59354R5YL9D+LvDhtClRnLf', 'TopPanelOutGame');
// scripts\components\top_panel_out_game\TopPanelOutGame.js

var Utils = require('Utils'),
    UrlImage = require('UrlImage'),
    AuthUser = require('AuthUser'),
    UiManager = require('UiManager'),
    CommonConstant = require('CommonConstant'),
    EventDispatcher = require('EventDispatcher'),
    EventDispatcherConstant = require('EventDispatcherConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        usernameLabel: cc.Label,
        ipLabelList: {
            'default': [],
            type: cc.Label
        },
        xuLabelList: {
            'default': [],
            type: cc.Label
        },
        expLabel: cc.Label,
        vipLabel: cc.Label,
        userAvatar: UrlImage,
        eventCountNode: cc.Node,
        messageCountNode: cc.Node,
        effectAvatar: cc.Prefab
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.usernameLabel.string = AuthUser.username;
        this.userAvatar.loadImage(AuthUser.avatar);
        this.updateUserMoney();
        this.updateUserExp();
        this.updateUserVip();
        this.updateEventCount();
        this.updateMessageCount();

        // Effect Avatar
        if (this.effectAvatar) {
            var effectNode = cc.instantiate(this.effectAvatar);
            effectNode.position = cc.v2(0, 0);
            this.userAvatar.node.parent.parent.addChild(effectNode);
        }

        // Event
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_EXP, this.updateUserExp, this);
        EventDispatcher.addEventListener(EventDispatcherConstant.PROFILE.UPDATE_UNREAD_MESS_COUNT, this.updateMessageCount, this);
    },

    onDestroy: function onDestroy() {
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_MONEY, this.updateUserMoney, this);
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_EXP, this.updateUserExp, this);
        EventDispatcher.removeEventListener(EventDispatcherConstant.PROFILE.UPDATE_UNREAD_MESS_COUNT, this.updateMessageCount, this);
    },

    openProfile: function openProfile() {
        Utils.Director.loadScene(CommonConstant.Scene.PROFILE);
    },

    openMessageBox: function openMessageBox() {
        UiManager.openPopupMessageBox();
    },

    openEvent: function openEvent() {
        UiManager.openPopupEvent();
        AuthUser.event_count = 0;
        this.updateEventCount();
    },

    openNapXien: function openNapXien() {
        UiManager.openNapXienModal();
    },

    updateEventCount: function updateEventCount() {
        var labelComp = this.eventCountNode.getComponentInChildren(cc.Label);
        if (AuthUser.event_count > 0) {
            this.eventCountNode.active = true;
            labelComp.string = AuthUser.event_count;
        } else {
            this.eventCountNode.active = false;
            labelComp.string = '';
        }
    },

    updateMessageCount: function updateMessageCount() {
        var labelComp = this.messageCountNode.getComponentInChildren(cc.Label);
        if (AuthUser.unread_mess_count > 0) {
            this.messageCountNode.active = true;
            labelComp.string = AuthUser.unread_mess_count;
        } else {
            this.messageCountNode.active = false;
            labelComp.string = '';
        }
    },

    updateUserMoney: function updateUserMoney() {
        this.xuLabelList.forEach(function (label) {
            label.string = AuthUser.currencies[CommonConstant.CurrencyType.Xu.NAME].balance;
            label.string = Utils.Number.format(label.string);
        });
        this.ipLabelList.forEach(function (label) {
            label.string = AuthUser.currencies[CommonConstant.CurrencyType.Ip.NAME].balance;
            label.string = Utils.Number.format(label.string);
        });
    },

    updateUserExp: function updateUserExp() {
        this.expLabel.string = AuthUser.experience;
        this.expLabel.string = Utils.Number.format(this.expLabel.string);
    },

    updateUserVip: function updateUserVip() {
        this.vipLabel.string = AuthUser.vip_level || 0;
        this.vipLabel.string = Utils.Number.format(this.vipLabel.string);
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher","EventDispatcherConstant":"EventDispatcherConstant","UiManager":"UiManager","UrlImage":"UrlImage","Utils":"Utils"}],"TopTableMiniPoker":[function(require,module,exports){
"use strict";
cc._RFpush(module, '2c3f9yJLTNPSpssygWG9ufV', 'TopTableMiniPoker');
// scripts\components\games\mini_poker\TopTableMiniPoker.js

var Utils = require('Utils'),
    Url = require('Url'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemPrefab: {
            'default': null,
            type: cc.Prefab
        },
        contentItem: {
            'default': null,
            type: cc.Node
        }
    },

    onLoad: function onLoad() {
        // Get Top User
        var self = this;
        NetworkManager.Http.fetch('GET', Url.Http.MINI_POKER_GET_TOP, {}, {
            cache: 900,
            delay: 500
        }).success(function (results) {
            if (results) {
                if (!self.isValid) {
                    return;
                }
                self.contentItem.removeAllChildren();
                for (var i = 0; i < results.data.length; i += 1) {
                    var historyData = results.data[i];
                    var itemNode = cc.instantiate(self.itemPrefab);
                    itemNode.getChildByName('1').getComponent(cc.Label).string = historyData.created_time;
                    itemNode.getChildByName('2').getComponent(cc.Label).string = historyData.username;
                    itemNode.getChildByName('3').getComponent(cc.Label).string = Utils.Number.format(historyData.bet);
                    itemNode.getChildByName('4').getComponent(cc.Label).string = Utils.Number.format(historyData.win_amount);
                    itemNode.getChildByName('5').getComponent(cc.Label).string = historyData.win_type;
                    itemNode.enabled = true;
                    self.contentItem.addChild(itemNode);
                }
            }
        });
    }
});

cc._RFpop();
},{"NetworkManager":"NetworkManager","Url":"Url","Utils":"Utils"}],"TopTableTaiXiu":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'edf54l7Q+NKrqjKAe2CgX5s', 'TopTableTaiXiu');
// scripts\components\games\tai_xiu\TopTableTaiXiu.js

var Url = require('Url'),
    Utils = require('Utils'),
    CommonConstant = require('CommonConstant'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': cc.Component,

    properties: {
        itemPrefab: cc.Prefab,
        contentTopWin: cc.Node,
        contentTopLose: cc.Node,
        topWinScrollview: cc.ScrollView,
        topLostScrollview: cc.ScrollView,
        lblTime: cc.Label
    },

    onLoad: function onLoad() {},

    getData: function getData(currency, time) {
        // Var
        this.currency = currency;
        this.currentTime = time;

        // Remove All Item
        this.reset();

        // Date co data 2016-08-26
        var self = this;
        this.lblTime.string = 'Ngày ' + Utils.Date.format(this.currentTime, 'dd/mm/yyyy');
        var isShowTopPi = currency === CommonConstant.CurrencyType.Ip.NAME;
        NetworkManager.Http.fetch('GET', Url.Http.TAI_XIU_GET_DAILY_TOP, {
            date: Utils.Date.format(this.currentTime, 'yyyy-mm-dd')
        }, {
            cache: 900,
            delay: 500
        }).success(function (results) {
            if (!self.isValid) {
                return;
            }

            // Remove All Item
            self.reset();

            if (results) {
                var topData = results.data[isShowTopPi ? CommonConstant.CurrencyType.Ip.NAME : CommonConstant.CurrencyType.Xu.NAME],
                    i;
                if (!topData) {
                    return;
                }
                var topWin = topData.top_win_users,
                    topLost = topData.top_lost_users,
                    node,
                    labelListNode;
                for (i = 0; i < topWin.length; i += 1) {
                    node = cc.instantiate(self.itemPrefab);
                    labelListNode = node.getComponentsInChildren(cc.Label);
                    labelListNode[0].string = i + 1;
                    labelListNode[1].string = topWin[i].username;
                    labelListNode[2].string = topWin[i].max_consecutive_win;
                    self.contentTopWin.addChild(node);
                }
                for (i = 0; i < topLost.length; i += 1) {
                    node = cc.instantiate(self.itemPrefab);
                    labelListNode = node.getComponentsInChildren(cc.Label);
                    labelListNode[0].string = i + 1;
                    labelListNode[1].string = topLost[i].username;
                    labelListNode[2].string = topLost[i].max_consecutive_lost;
                    self.contentTopLose.addChild(node);
                }
            }
        });
    },

    reset: function reset() {
        this.contentTopWin.removeAllChildren();
        this.topWinScrollview.scrollToTop();
        this.contentTopLose.removeAllChildren();
        this.topLostScrollview.scrollToTop();
    },

    onClickLeft: function onClickLeft() {
        this.currentTime = this.currentTime - 24 * 60 * 60 * 1000;
        this.getData(this.currency, this.currentTime);
    },

    onClickRight: function onClickRight() {
        this.currentTime = this.currentTime + 24 * 60 * 60 * 1000;
        this.getData(this.currency, this.currentTime);
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","NetworkManager":"NetworkManager","Url":"Url","Utils":"Utils"}],"TopUsers":[function(require,module,exports){
"use strict";
cc._RFpush(module, '9b1a2zeJgxO/JXs/XIocpg7', 'TopUsers');
// scripts\components\top_users\TopUsers.js

var NetworkManager = require('NetworkManager'),
    TabView = require('TabView'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        topTabView: TabView,

        itemTopPrefab: cc.Prefab,

        tabTopPrefab: cc.Prefab,
        contentTopPrefab: cc.Prefab,
        subTabTopPrefab: cc.Prefab,
        subContentTopPrefab: cc.Prefab
    },

    // use this for initialization
    onLoad: function onLoad() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.TOP_TYPES, {}, {
            cache: 900
        }).success(function (topResp) {
            var topItems = topResp.data;
            that.topTabView.removeAllTabs();
            for (var i = 0; i < topItems.length; i += 1) {
                that._initTopTabView(topItems[i], !i);
            }
        });
    },

    _initTopTabView: function _initTopTabView(topType, isEnable) {
        var subTopTabView,
            that = this,
            eventHandler = new cc.Component.EventHandler(),
            tabNode = cc.instantiate(this.tabTopPrefab),
            contentNode = cc.instantiate(this.contentTopPrefab);
        tabNode.getComponentInChildren(cc.Label).string = topType.name;
        tabNode.getComponentInChildren('UrlImage').loadImage(topType.icon);
        subTopTabView = contentNode.getComponent(TabView);
        topType.sub_types.forEach(function (subTopType) {
            that._initSubTopTabView(subTopTabView, subTopType);
        });

        eventHandler.target = this.node;
        eventHandler.component = 'TopUsers';
        eventHandler.handler = 'getTopUsers';
        subTopTabView.selectEvents.push(eventHandler);

        if (!isEnable) {
            contentNode.active = false;
        }
        this.topTabView.addTab(tabNode, contentNode);
        if (isEnable) {
            this.topTabView.activeByName(tabNode.name);
        }
    },

    _initSubTopTabView: function _initSubTopTabView(subTopTabView, subTopType) {
        var tabNode = cc.instantiate(this.subTabTopPrefab),
            contentNode = cc.instantiate(this.subContentTopPrefab);
        tabNode.getComponentInChildren(cc.Label).string = subTopType.name;
        contentNode.topData = subTopType;
        subTopTabView.addTab(tabNode, contentNode);
    },

    getTopUsers: function getTopUsers(tab, content) {
        var that = this,
            containerNode = content.getComponent(cc.ScrollView).content;
        NetworkManager.Http.fetch('GET', content.topData.url, {}, {
            cache: 900,
            delay: 500
        }).success(function (topResp) {
            var topItemNode,
                topComponent,
                topItems = topResp.data;
            containerNode.removeAllChildren();
            for (var i = 0; i < topItems.length; i += 1) {
                topItemNode = cc.instantiate(that.itemTopPrefab);
                topComponent = topItemNode.getComponent('ItemTopUser');
                topComponent.updateData(i + 1, topItems[i]);
                containerNode.addChild(topItemNode);
            }
        });
    }
});

cc._RFpop();
},{"NetworkManager":"NetworkManager","TabView":"TabView","Url":"Url"}],"UiManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '3887abLoURCv5UL5XoPD5LA', 'UiManager');
// scripts\ui\UiManager.js

var EventDispatcher = require('EventDispatcher'),
    CommonConstant = require('CommonConstant'),
    AuthUser = require('AuthUser'),
    AudioManager = require('AudioManager'),
    UiManager;

UiManager = {
    openModal: function openModal(message, settings) {
        if (message) {
            cc.loader.loadRes('Modal', function (err, prefab) {
                var newNode = cc.instantiate(prefab);
                newNode.zIndex = CommonConstant.ZINDEX.MODAL;
                var comp = newNode.getComponent('Modal');
                comp.content.string = message;
                cc.game.addPersistRootNode(newNode);
                settings = settings || {};
                if (settings.close_fn) {
                    comp.closeCallback = settings.close_fn;
                }
            });
        }
    },

    openConfirmModal: function openConfirmModal(message, settings) {
        if (message) {
            settings = settings || {};
            cc.loader.loadRes('ConfirmModal', function (err, prefab) {
                var newNode = cc.instantiate(prefab);
                newNode.zIndex = CommonConstant.ZINDEX.MODAL;
                var modalComp = newNode.getComponent('Modal'),
                    comp = newNode.getComponent('ConfirmModal');
                modalComp.content.string = message;
                if (settings.oke_fn) {
                    comp.okeCallback = settings.oke_fn;
                }
                if (settings.cancel_fn) {
                    comp.cancelCallback = settings.cancel_fn;
                }
                if (settings.isPersistent) {
                    cc.game.addPersistRootNode(newNode);
                } else {
                    cc.director.getScene().addChild(newNode);
                }
            });
        }
    },

    openModalByName: function openModalByName(modalName, callback, options) {
        var that = this,
            key = this._generateModalName(modalName),
            node = this[key];
        if (node && node.isValid) {
            // not open if exists
            if (callback) {
                try {
                    callback(node);
                } catch (e) {}
            }
            return;
        }
        this[key] = {
            isValid: true
        };
        cc.loader.loadRes(modalName, function (err, prefab) {
            var newNode = cc.instantiate(prefab);
            options = options || {};
            if (options.isPersistent) {
                cc.game.addPersistRootNode(newNode);
            } else {
                cc.director.getScene().addChild(newNode);
            }
            that[key] = newNode;
            if (callback) {
                try {
                    callback(newNode);
                } catch (e) {}
            }
        });
    },

    destroyModalByName: function destroyModalByName(modalName) {
        var key = this._generateModalName(modalName),
            node = this[key];
        if (node) {
            node.destroy();
        }
        delete this[key];
    },

    openWebView: function openWebView(url, title, callback) {
        this.openModalByName('WebView', function (newNode) {
            var params = 'username=' + AuthUser.username + '&accesstoken=' + AuthUser.accesstoken;
            url += (url.indexOf('?') > 0 ? '&' : '?') + params;
            newNode.getComponentInChildren(cc.WebView).url = url;
            newNode.getComponentInChildren(cc.Label).string = title || 'WebView';
            if (callback) {
                try {
                    callback();
                } catch (e) {}
            }
        });
    },

    openNapXienModal: function openNapXienModal() {
        this.openModalByName('NapXien');
    },

    openTopUsersModal: function openTopUsersModal() {
        this.openModalByName('TopUsers');
    },

    openPopupMessageBox: function openPopupMessageBox() {
        this.openModalByName('MessageBox');
    },

    openPopupDoiThuong: function openPopupDoiThuong() {
        this.openModalByName('DoiThuong');
    },

    openPopupEvent: function openPopupEvent(eventId) {
        this.openModalByName('Event', function (newNode) {
            newNode.getComponent('Event').openEventId = eventId;
        });
    },

    openPopupHotEvent: function openPopupHotEvent() {
        this.openModalByName('HotEvent');
    },

    openPopupDaiLy: function openPopupDaiLy() {
        this.openModalByName('DaiLy');
    },

    openPopupKiemXu: function openPopupKiemXu() {
        this.openModalByName('KiemXu');
    },

    openPopupSettings: function openPopupSettings() {
        this.openModalByName('Settings');
    },

    openHelpModal: function openHelpModal(message, options) {
        if (message) {
            options = options || {};
            cc.loader.loadRes('HelpModal', function (err, prefab) {
                var newNode = cc.instantiate(prefab);
                setTimeout(function () {
                    var modalComp = newNode.getComponent('Modal'),
                        scrollViewComp = newNode.getComponentInChildren(cc.ScrollView);
                    if (scrollViewComp) {
                        scrollViewComp.scrollToTop();
                    }
                    modalComp.content.string = message;
                }, options.delay || 0);
                cc.director.getScene().addChild(newNode);
            });
        }
    },

    openWarningMessage: (function () {
        var eventListened = false,
            prefabNode;

        function open(message, duration) {
            if (!eventListened) {
                eventListened = true;
                // clear warning message
                cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, function () {
                    if (prefabNode) {
                        var comp = prefabNode.getComponent('WarningMessage');
                        comp.closeImmediately();
                    }
                });
            }

            if (prefabNode) {
                var comp = prefabNode.getComponent('WarningMessage'),
                    scene = cc.director.getScene();
                comp.open(message, duration);
                if (!prefabNode.isChildOf(scene)) {
                    scene.addChild(prefabNode);
                }
                AudioManager.instance.playError();
            }
        }

        return function (message, duration) {
            if (message) {
                if (!prefabNode) {
                    cc.loader.loadRes('WarningMessage', function (err, prefab) {
                        if (!prefabNode) {
                            prefabNode = cc.instantiate(prefab);
                            cc.game.addPersistRootNode(prefabNode);
                        }
                        open(message, duration);
                    });
                } else {
                    open(message, duration);
                }
            }
        };
    })(),

    _generateModalName: function _generateModalName(modalName) {
        return '$_modal_' + modalName;
    }
};

// open popup message
EventDispatcher.addEventListener(CommonConstant.PushMessageType.POPUP.EVENT, function (params) {
    UiManager.openModal(params && params.content);
});

module.exports = UiManager;

cc._RFpop();
},{"AudioManager":"AudioManager","AuthUser":"AuthUser","CommonConstant":"CommonConstant","EventDispatcher":"EventDispatcher"}],"UrlImage":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'f4b5avmip5A0LpfsyMb9/0s', 'UrlImage');
// scripts\ui\UrlImage.js

cc.Class({
    'extends': cc.Component,

    properties: {
        url: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (this.url) {
            this.loadImage(this.url);
        }
    },

    loadImage: function loadImage(url) {
        var self = this;

        cc.loader.load({
            id: url,
            type: 'png'
        }, function (err, texture) {
            if (err) {
                cc.error(err);
            } else if (self.node) {
                var sprite = self.node.getComponent(cc.Sprite);
                sprite.spriteFrame = new cc.SpriteFrame(texture);
                self.node.runAction(cc.fadeIn(0.5));
            }
        });
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RFpop();
},{}],"Url":[function(require,module,exports){
"use strict";
cc._RFpush(module, '42ba75zMcpO0525HerN/QUv', 'Url');
// scripts\constant\Url.js

/**
    Muddle urls info

    btoa(JSON.stringify({
    Http: {
        RT_SV_IP: '/gamecore/v1/game_rt_server_ip',
        GAME_ACCOUNT: '/gamecore/v1/account',

        ...
    }
}))

    module.exports = JSON.parse(atob('encoded_string'));

 */

module.exports = {
        Http: {
                RT_SV_IP: '/gamecore/v1/game_rt_server_ip',
                CHECK_VER: '/gamecore/v1/check_ver',
                GAME_ACCOUNT: '/gamecore/v1/account',

                TIN_NHAN_TYPES: '/gamecore/v1/payment/sms_type',
                THE_CAO_TYPES: '/gamecore/v1/payment/sctype',
                NAP_THE_CAO: '/gamecore/v1/payment/scratch_card_charging',
                IAP_TYPES: '/gamecore/v1/payment/iap/products',

                TOP_TYPES: '/gamecore/v1/top/types',

                USER_LOGIN: '/user/v1/login',
                USER_CHANGE_PASSWORD: '/user/v1/change_pass',
                USER_UPDATE_INFO: '/user/v1/update_info',
                USER_UPDATE_AVATAR: '/user/v1/upload_avatar',
                USER_ACTIVE_PHONE: '/user/v1/active_mobile_syntax',
                USER_ACTIVE_EMAIL: '/user/v1/active_email',

                BANNER: '/gamecore/v1/iplay/banner',
                GAME_HELP: '/gamecore/v1/iplay/help_game',
                FEEDBACK: '/gamecore/v1/iplay/feedback',
                CONTACT_INFO: '/gamecore/v1/iplay/contact_info',
                MESSAGE_BOX: '/gamecore/v1/account/msg',
                DETAIL_MESSAGE_BOX: '/gamecore/v1/account/msg/',

                DOI_THUONG_GET_CARD_INFO: '/gamecore/v1/doithe/cards_info',
                DOI_THUONG_GET_CARD: '/gamecore/v1/doithe/get_card',
                DOI_THUONG_GET_ITEMS_INFO: '/gamecore/v1/doithe/items_info',
                DOI_THUONG_CARDS_HISTORY: '/gamecore/v1/doithe/user_bill_list',

                MINI_POKER_GET_JAR: '/gamecore/v1/mini_poker/jar',
                MINI_POKER_GET_TOP: '/gamecore/v1/mini_poker/top',

                CHICKENJAR: '/gamecore/v1/chicken_fund/jar',
                CHICKEN_CODE: '/gamecore/v1/chicken_fund/codelist',

                TAI_XIU_GET_DAILY_TOP: '/gamecore/v1/tai_xiu/daily_top',

                TRANSFER: '/gamecore/v1/transfer',
                TRANSFER_LOG: '/gamecore/v1/transfer_log',
                MONEY_EX: '/gamecore/v1/money/exchange',

                EVENT_LIST: '/gamecore/v1/event_list',

                DAILY_LIST: '/gamecore/v1/transfer_partner/list',

                INVITE_CODE: '/gamecore/v1/friend/invitecode',
                GIFT_CODE: '/gamecore/v1/giftcode',
                SHARE_FACEBOOK: '/gamecore/v1/facebook/share',
                INVITE_FACEBOOK: '/gamecore/v1/friend/invitefb',

                XOSO_BET: '/gamecore/v1/xoso/bet',
                XOSO_TYPES: '/gamecore/v1/xoso/types',
                XOSO_RESULT: '/gamecore/v1/xoso/result',
                XOSO_BET_LIST: '/gamecore/v1/xoso/bet_list',
                XOSO_USER_BET_LIST: '/gamecore/v1/xoso/user_bet_list',

                TOP_WIN_GAME: '/gamecore/v1/top/win_game'
        }
};

cc._RFpop();
},{}],"Utils":[function(require,module,exports){
"use strict";
cc._RFpush(module, '81e08iMOOdNnJkrQb09toT+', 'Utils');
// scripts\lib\Utils.js

var Utils = {
    String: {
        param: function param(abj) {
            var s = [],
                rbracket = /\[\]$/,
                isArray = function isArray(obj) {
                return Array.isArray(obj);
            },
                add = function add(k, v) {
                v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;
                s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);
            },
                buildParams = function buildParams(prefix, obj) {
                var i, len, key;

                if (prefix) {
                    if (isArray(obj)) {
                        for (i = 0, len = obj.length; i < len; i += 1) {
                            if (rbracket.test(prefix)) {
                                add(prefix, obj[i]);
                            } else {
                                buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i]);
                            }
                        }
                    } else if (obj && String(obj) === '[object Object]') {
                        for (key in obj) {
                            buildParams(prefix + '[' + key + ']', obj[key]);
                        }
                    } else {
                        add(prefix, obj);
                    }
                } else if (isArray(obj)) {
                    for (i = 0, len = obj.length; i < len; i += 1) {
                        add(obj[i].name, obj[i].value);
                    }
                } else {
                    for (key in obj) {
                        buildParams(key, obj[key]);
                    }
                }
                return s;
            };

            return buildParams('', abj).join('&').replace(/%20/g, '+');
        },

        deparam: function deparam(query) {
            var pair,
                query_string = {},
                vars = query.split('̃&');
            for (var i = 0; i < vars.length; i += 1) {
                pair = vars[i].split('=');
                pair[0] = decodeURIComponent(pair[0]);
                pair[1] = decodeURIComponent(pair[1]);
                // If first entry with this name
                if (typeof query_string[pair[0]] === 'undefined') {
                    query_string[pair[0]] = pair[1];
                    // If second entry with this name
                } else if (typeof query_string[pair[0]] === 'string') {
                        var arr = [query_string[pair[0]], pair[1]];
                        query_string[pair[0]] = arr;
                        // If third or later entry with this name
                    } else {
                            query_string[pair[0]].push(pair[1]);
                        }
            }
            return query_string;
        },

        removeRichText: (function () {
            var REGEXES = [/<i>(.*)<\/i>/i, /<b>(.*)<\/b>/i, /<color(?:=[^>]*)*>(.+)<\/color>/i];
            return function (string) {
                var i;
                for (i = 0; i < REGEXES.length; i += 1) {
                    string = string.replace(REGEXES[i], '$1');
                }
                return string;
            };
        })()
    },

    Array: {
        removeRef: function removeRef(arr, elem) {
            var i = arr.indexOf(elem);
            if (i > -1) {
                arr.splice(i, 1);
            }
        },

        remove: function remove(arr, elem) {
            var i = Utils.Array.indexOf(arr, elem);
            if (i > -1) {
                arr.splice(i, 1);
            }
        },

        /**
         * Iterate an array and touch each its element, even if the array can be modified.
         *
         * @param  {Array} arr     array
         * @param  {Function} handler same as callback of ``Array.prototype.forEach()``
         */
        forEach: function forEach(arr, handler) {
            arr.slice().forEach(handler);
        },

        trimLeft: function trimLeft(arr, size) {
            while (arr.length > size) {
                arr.shift();
            }
        },

        trimRight: function trimRight(arr, size) {
            while (arr.length > size) {
                arr.pop();
            }
        },

        /**
         * Same as Array.prototype.indexOf() but deal with equality better.
         */
        indexOf: function indexOf(arr, val) {
            var i;
            for (i = 0; i < arr.length; i += 1) {
                if (Utils.Object.isEqual(arr[i], val)) {
                    return i;
                }
            }
            return -1;
        },

        unique: function unique(arr) {
            var result = [],
                val,
                i;
            for (i = 0; i < arr.length; i += 1) {
                val = arr[i];
                if (result.indexOf(val) === -1) {
                    result.push(val);
                }
            }
            return result;
        },

        pushUnique: function pushUnique(arr, val) {
            if (Utils.Array.indexOf(arr, val) === -1) {
                arr.push(val);
                return true;
            }
            return false;
        },

        createCircular: (function () {
            function Circular(array) {
                this._array = array;
                this._index = -1;
            }

            Circular.prototype.next = function () {
                this._index += 1;
                if (this._index >= this._array.length) {
                    this._index = 0;
                }
                return this._array[this._index];
            };

            Circular.prototype.prev = function () {
                this._index -= 1;
                if (this._index < 0) {
                    this._index = this._array.length - 1;
                }
                return this._array[this._index];
            };

            return function (array) {
                return new Circular(array);
            };
        })()
    },

    Set: {
        compare: function compare(set1, set2) {
            var same = [],
                diff12 = [],
                diff21 = [];

            if (set1 === set2) {
                same = set1.slice();
            } else {
                var i, j, v1, v2;
                diff12 = set1.slice();
                diff21 = set2.slice();
                for (i = 0; i < set1.length; i += 1) {
                    v1 = set1[i];
                    for (j = 0; j < set2.length; j += 1) {
                        v2 = set2[j];
                        if (Utils.Object.isEqual(v1, v2)) {
                            same.push(v1);
                            Utils.Array.remove(diff12, v1);
                            Utils.Array.remove(diff21, v1);
                            break;
                        }
                    }
                }
            }

            return {
                same: same,
                diff12: diff12,
                diff21: diff21
            };
        }
    },

    Object: {
        isEqual: function isEqual(o1, o2) {
            if (o1 === o2) {
                return true;
            }

            if (typeof o1 !== typeof o2) {
                return false;
            }

            if (o1 === undefined || o1 === null || typeof o1 === 'number' && isNaN(o1) && isNaN(o2)) {
                return true;
            }

            var isDate1 = Utils.Type.isDate(o1),
                isDate2 = Utils.Type.isDate(o2);

            if (isDate1 && !isDate2 || !isDate1 && isDate2) {
                return false;
            }
            if (isDate1 && isDate2) {
                return o1.getTime() === o2.getTime();
            }

            var isRegExp1 = Utils.Type.isRegExp(o1),
                isRegExp2 = Utils.Type.isRegExp(o2);

            if (isRegExp1 && !isRegExp2 || !isRegExp1 && isRegExp2) {
                return false;
            }
            if (isRegExp1 && isRegExp2) {
                return o1.toString() === o2.toString();
            }

            if (Utils.Type.isObject(o1) && Utils.Type.isObject(o2)) {
                var o1Props = Object.getOwnPropertyNames(o1),
                    o2Props = Object.getOwnPropertyNames(o2),
                    i;

                if (o1Props.length !== o2Props.length) {
                    return false;
                }

                for (i = 0; i < o1Props.length; i += 1) {
                    if (!Utils.Object.isEqual(o1[o1Props[i]], o2[o2Props[i]])) {
                        return false;
                    }
                }

                return true;
            } else {
                return o1 === o2;
            }
        },

        /**
         * Find object inside parent object whose value of prop name is equality with specified value.
         *
         * @param  {Object} obj       parent object to find
         * @param  {String} propName  property name
         * @param  {*}      propValue property value
         * @return {Object}           found object or null
         */
        findObject: function findObject(obj, propName, propValue) {
            var prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    var val = obj[prop];
                    if (Utils.Type.isObject(val) && val[propName] === propValue) {
                        return val;
                    }
                }
            }
            return null;
        },

        replaceProperty: function replaceProperty(obj, oldProp, newProp) {
            var value = obj[oldProp];
            delete obj[oldProp];
            obj[newProp] = value;
        },

        isEmpty: function isEmpty(obj) {
            return Object.getOwnPropertyNames(obj).length === 0;
        },

        /**
         * Return new object with same properties of original object, but all its props
         * are unchangable.
         *
         * @param  {Object} obj original object
         * @return {Object}     constant object
         */
        toConstant: function toConstant(obj) {
            var r = {},
                prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    var val = obj[prop];
                    if (Utils.Type.isObject(val)) {
                        val = Utils.Object.toConstant(val);
                    }
                    Object.defineProperty(r, prop, {
                        value: val,
                        writable: false,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
            return r;
        },

        values: function values(obj) {
            if (Utils.Type.isFunction(Object.values)) {
                return Object.values(obj);
            }

            var values = [],
                prop;
            for (prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    values.push(obj[prop]);
                }
            }
            return values;
        }
    },

    Type: {
        isString: function isString(obj) {
            return typeof obj === 'string';
        },

        isNumber: function isNumber(obj) {
            return typeof obj === 'number' && !isNaN(obj);
        },

        isObject: function isObject(obj) {
            return typeof obj === 'object' && obj !== null;
        },

        isFunction: function isFunction(obj) {
            return typeof obj === 'function';
        },

        isUndefined: function isUndefined(obj) {
            return typeof obj === 'undefined';
        },

        isDefined: function isDefined(obj) {
            return !this.isUndefined(obj) && obj !== null;
        },

        isArray: function isArray(obj) {
            return Array.isArray(obj);
        },

        isDate: function isDate(obj) {
            return obj instanceof Date;
        },

        isRegExp: function isRegExp(obj) {
            return obj instanceof RegExp;
        }
    },

    Number: {
        format: function format(number) {
            var numberStr = Math.abs(number).toString(),
                intStrPartNew = '',
                parts,
                intStrPart,
                floatPart,
                i,
                j;
            numberStr = numberStr.replace('.', ',');
            parts = numberStr.split(',');
            intStrPart = parts[0];
            floatPart = parts[1];
            for (i = intStrPart.length - 1, j = 1; i >= 0; i -= 1, j += 1) {
                intStrPartNew = intStrPart[i] + intStrPartNew;
                if (j % 3 === 0 && i !== 0) {
                    intStrPartNew = '.' + intStrPartNew;
                }
            }
            return (number < 0 ? '-' : '') + intStrPartNew + (floatPart ? ',' + floatPart : '');
        },

        abbreviate: function abbreviate(number, decPlaces) {
            // 2 decimal places => 100, 3 => 1000, etc
            decPlaces = Math.pow(10, decPlaces || 2);

            // Enumerate number abbreviations
            var abbrev = ['K', 'M', 'B', 'T'],
                str = number < 0 ? '-' : '',
                size;

            number = Math.abs(number);

            // Go through the array backwards, so we do the largest first
            for (var i = abbrev.length - 1; i >= 0; i -= 1) {
                // Convert array index to '1000', '1000000', etc
                size = Math.pow(10, (i + 1) * 3);
                // If the number is bigger or equal do the abbreviation
                if (size <= number) {
                    // Here, we multiply by decPlaces, round, and then divide by decPlaces.
                    // This gives us nice rounding to a particular decimal place.
                    number = Math.floor(number * decPlaces / size) / decPlaces;
                    // Handle special case where we round up to the next abbreviation
                    if (number === 1000 && i < abbrev.length - 1) {
                        number = 1;
                        i += 1;
                    }
                    // Add the letter for the abbreviation
                    number += abbrev[i];
                    // We are done... stop
                    break;
                }
            }
            return str + number;
        },

        fillZero: function fillZero(number, maxSize) {
            var s = '' + number;
            while (s.length < maxSize) {
                s = '0' + s;
            }
            return s;
        },

        random: function random(from, to) {
            var add = from === 0 || to === 0 ? 1 : 0;
            return Math.floor(Math.random() * (to + add) + from);
        }
    },

    Date: {
        currentTime: function currentTime() {
            var date = new Date();
            return Utils.Number.fillZero(date.getHours(), 2) + ':' + Utils.Number.fillZero(date.getMinutes(), 2) + ':' + Utils.Number.fillZero(date.getSeconds(), 2);
        },
        /**
         * Convert "2016-11-17 17:50:00" to Date(2016, 11, 17, 17, 50, 00)
         */
        fromString: function fromString(s) {
            var year = s.slice(0, 4),
                month = s.slice(5, 7) - 1,
                day = s.slice(8, 10),
                hour = s.slice(11, 13),
                minute = s.slice(14, 16),
                second = s.slice(17, 19);
            return new Date(year, month, day, hour, minute, second);
        },
        format: (function () {
            var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
            var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
            var timezoneClip = /[^-+\dA-Z]/g;

            function getDayOfWeek(date) {
                var dow = date.getDay();
                if (dow === 0) {
                    dow = 7;
                }
                return dow;
            }

            function getWeek(date) {
                // Remove time components of date
                var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                // Change date to Thursday same week
                targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);

                // Take January 4th as it is always in week 1 (see ISO 8601)
                var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

                // Change date to Thursday same week
                firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);

                // Check if daylight-saving-time-switch occured and correct for it
                var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
                targetThursday.setHours(targetThursday.getHours() - ds);

                // Number of weeks between target Thursday and first Thursday
                var weekDiff = (targetThursday - firstThursday) / (86400000 * 7);
                return 1 + Math.floor(weekDiff);
            }

            // Regexes and supporting functions are cached through closure
            var dateFormat = function dateFormat(date, mask, utc, gmt) {

                // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
                if (arguments.length === 1 && typeof date === 'string' === 'string' && !/\d/.test(date)) {
                    mask = date;
                    date = undefined;
                }

                date = date || new Date();

                if (!(date instanceof Date)) {
                    date = new Date(date);
                }

                if (isNaN(date)) {
                    throw TypeError('Invalid date');
                }

                mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);

                // Allow setting the utc/gmt argument via the mask
                var maskSlice = mask.slice(0, 4);
                if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
                    mask = mask.slice(4);
                    utc = true;
                    if (maskSlice === 'GMT:') {
                        gmt = true;
                    }
                }

                var pad = Utils.Number.fillZero;
                var _ = utc ? 'getUTC' : 'get';
                var d = date[_ + 'Date']();
                var D = date[_ + 'Day']();
                var m = date[_ + 'Month']();
                var y = date[_ + 'FullYear']();
                var H = date[_ + 'Hours']();
                var M = date[_ + 'Minutes']();
                var s = date[_ + 'Seconds']();
                var L = date[_ + 'Milliseconds']();
                var o = utc ? 0 : date.getTimezoneOffset();
                var W = getWeek(date);
                var N = getDayOfWeek(date);
                var flags = {
                    d: d,
                    dd: pad(d, 2),
                    ddd: dateFormat.i18n.dayNames[D],
                    dddd: dateFormat.i18n.dayNames[D + 7],
                    m: m + 1,
                    mm: pad(m + 1, 2),
                    mmm: dateFormat.i18n.monthNames[m],
                    mmmm: dateFormat.i18n.monthNames[m + 12],
                    yy: String(y).slice(2),
                    yyyy: y,
                    h: H % 12 || 12,
                    hh: pad(H % 12 || 12, 2),
                    H: H,
                    HH: pad(H, 2),
                    M: M,
                    MM: pad(M, 2),
                    s: s,
                    ss: pad(s, 2),
                    l: pad(L, 3),
                    L: pad(Math.round(L / 10), 2),
                    t: H < 12 ? 'a' : 'p',
                    tt: H < 12 ? 'am' : 'pm',
                    T: H < 12 ? 'A' : 'P',
                    TT: H < 12 ? 'AM' : 'PM',
                    Z: gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
                    o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 !== 10) * d % 10],
                    W: W,
                    N: N
                };

                return mask.replace(token, function (match) {
                    if (match in flags) {
                        return flags[match];
                    }
                    return match.slice(1, match.length - 1);
                });
            };

            dateFormat.masks = {
                'default': 'ddd mmm dd yyyy HH:MM:ss',
                'shortDate': 'm/d/yy',
                'mediumDate': 'mmm d, yyyy',
                'longDate': 'mmmm d, yyyy',
                'fullDate': 'dddd, mmmm d, yyyy',
                'shortTime': 'h:MM TT',
                'mediumTime': 'h:MM:ss TT',
                'longTime': 'h:MM:ss TT Z',
                'isoDate': 'yyyy-mm-dd',
                'isoTime': 'HH:MM:ss',
                'isoDateTime': 'yyyy-mm-dd\'T\'HH:MM:sso',
                'isoUtcDateTime': 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
                'expiresHeaderFormat': 'ddd, dd mmm yyyy HH:MM:ss Z'
            };

            // Internationalization strings
            dateFormat.i18n = {
                dayNames: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
            };

            return dateFormat;
        })()
    },

    Cookie: {
        get: function get(name) {
            var value, cookies, cookieItem;
            cookies = document.cookie.split('; ');
            for (var i = 0; i < cookies.length; i += 1) {
                cookieItem = cookies[i].split('=');
                if (cookieItem[0] === name) {
                    value = cookieItem[1];
                }
            }
            return value;
        },
        set: function set(name, value, expires, path, domain, secure) {
            var cookieStr = name + '=' + value + '; ';
            if (expires) {
                expires = this._setExpiration(expires);
                cookieStr += 'expires=' + expires + '; ';
            }
            if (path) {
                cookieStr += 'path=' + path + '; ';
            }
            if (domain) {
                cookieStr += 'domain=' + domain + '; ';
            }
            if (secure) {
                cookieStr += 'secure; ';
            }
            document.cookie = cookieStr;
        },
        _setExpiration: function _setExpiration(cookieLife) {
            var today = new Date();
            var expr = new Date(today.getTime() + cookieLife * 24 * 60 * 60 * 1000);
            return expr.toGMTString();
        }
    },

    /**
     * Usage:
     *
     * var SuperClass = Utils.Class({
     *     $$constructor: function (param) {
     *         this.param = param;
     *     },
     *
     *     $$static: {
     *         STATIC_VAR: 100,
     *         staticMethod: function () {}
     *     },
     *
     *     someMethod: function (extraParam) {
     *         // use 'extraParam' and 'this.param'
     *     }
     * });
     *
     * var DerivedClass = Utils.Class({
     *     $$extends: SuperClass,
     *
     *     $$constructor: function (param, extraParam) {
     *         // call super constructor
     *         this.$super.constructor.call(this, param);
     *         this.extraParam = extraParam;
     *     },
     *
     *     someMethod: function (extraParam, extraExtraParam) {
     *         // call super method
     *         this.$super.someMethod.call(this, extraParam);
     *         // use 'extraExtraParam'
     *     },
     *
     *     otherMethod: function (extraParam) {
     *         // use 'extraParam', 'this.param' and 'this.extraParam'
     *     }
     * })
     *
     */
    Class: (function () {
        var RESERVED_KEYWORDS = ['$$constructor', '$$extends', '$$static'];

        return function (objSpec) {
            var F = objSpec.$$constructor || function () {},
                prop,
                value,
                staticProp;

            for (prop in objSpec) {
                if (objSpec.hasOwnProperty(prop)) {
                    value = objSpec[prop];
                    if (prop === '$$static') {
                        for (staticProp in value) {
                            if (value.hasOwnProperty(staticProp)) {
                                F[staticProp] = value[staticProp];
                            }
                        }
                    } else if (prop === '$$extends') {
                        F.prototype = Object.create(value.prototype);
                        F.prototype.$super = Object.create(value.prototype);
                        F.prototype.constructor = F;
                    } else if (RESERVED_KEYWORDS.indexOf(prop) === -1) {
                        F.prototype[prop] = value;
                    }
                }
            }

            return F;
        };
    })(),

    Node: {
        getChild: function getChild(parentNode, dottedName) {
            var names = dottedName.split('.'),
                node = parentNode,
                i;
            for (i = 0; i < names.length; i += 1) {
                if (node === null) {
                    break;
                }
                node = node.getChildByName(names[i]);
            }
            return node;
        },

        stopPropagation: function stopPropagation(node) {
            function disableEventFn(event) {
                event.stopPropagation();
            }

            node.on(cc.Node.EventType.TOUCH_START, disableEventFn);
            node.on(cc.Node.EventType.TOUCH_END, disableEventFn);
            node.on(cc.Node.EventType.TOUCH_MOVE, disableEventFn);
            node.on(cc.Node.EventType.MOUSE_DOWN, disableEventFn);
            node.on(cc.Node.EventType.MOUSE_UP, disableEventFn);
            node.on(cc.Node.EventType.MOUSE_MOVE, disableEventFn);

            return function () {
                node.off(cc.Node.EventType.TOUCH_START, disableEventFn);
                node.off(cc.Node.EventType.TOUCH_END, disableEventFn);
                node.off(cc.Node.EventType.TOUCH_MOVE, disableEventFn);
                node.off(cc.Node.EventType.MOUSE_DOWN, disableEventFn);
                node.off(cc.Node.EventType.MOUSE_UP, disableEventFn);
                node.off(cc.Node.EventType.MOUSE_MOVE, disableEventFn);
            };
        },

        destroyAllChildrenInNode: function destroyAllChildrenInNode(node) {
            for (var i = node.childrenCount - 1; i >= 0; i -= 1) {
                node.children[i].destroy();
            }
        }
    },

    Director: (function () {
        var loadingScenes = [],
            currentSceneName,
            previousSceneName;

        return {
            loadScene: function loadScene(sceneName, onLaunched) {
                if (currentSceneName) {
                    previousSceneName = currentSceneName;
                }
                currentSceneName = sceneName;

                var pushSuccess = Utils.Array.pushUnique(loadingScenes, {
                    sceneName: sceneName,
                    onLaunched: onLaunched
                });
                if (pushSuccess) {
                    if (loadingScenes.length === 1) {
                        this._loadScene(sceneName, onLaunched);
                    }
                }
            },

            getPreviousSceneName: function getPreviousSceneName() {
                return previousSceneName;
            },

            preloadScene: function preloadScene(sceneName, onLaunched) {
                cc.director.preloadScene(sceneName, onLaunched);
            },

            _loadScene: function _loadScene(sceneName, onLaunched) {
                var self = this;
                self.preloadScene(sceneName, function () {
                    cc.director.loadScene(sceneName, function () {
                        Utils.Array.remove(loadingScenes, {
                            sceneName: sceneName,
                            onLaunched: onLaunched
                        });
                        if (Utils.Type.isFunction(onLaunched)) {
                            onLaunched();
                        }
                        if (loadingScenes.length > 0) {
                            var sceneConfigs = loadingScenes[0];
                            self._loadScene(sceneConfigs.sceneName, sceneConfigs.onLaunched);
                        }
                    });
                });
            }
        };
    })(),

    Scheduler: {
        /**
         * Schedule function execution by interval.
         *
         * @param {Function}  func     function to execute
         * @param {Number}    interval interval in ms
         * @param {Boolean}   isEager  execute first time if true
         */
        setInterval: (function (_setInterval) {
            function setInterval(_x, _x2, _x3) {
                return _setInterval.apply(this, arguments);
            }

            setInterval.toString = function () {
                return _setInterval.toString();
            };

            return setInterval;
        })(function (func, interval, isEager) {
            if (interval > 0 && Utils.Type.isFunction(func)) {
                if (isEager) {
                    func();
                }
                return setInterval(func, interval);
            }
            return null;
        })
    },

    Module: {
        get: function get(moduleName) {
            if (Utils.Type.isString(moduleName)) {
                try {
                    return require(moduleName);
                } catch (e) {
                    return null;
                }
            }
            return null;
        }
    },

    Game: (function () {
        var _isFocus = true;

        function onShow() {
            _isFocus = true;
        }

        function onHide() {
            _isFocus = false;
        }

        cc.game.on(cc.game.EVENT_SHOW, onShow, this);
        cc.game.on(cc.game.EVENT_HIDE, onHide, this);

        return {
            isFocus: function isFocus() {
                return _isFocus;
            }
        };
    })()
};

module.exports = Utils;

cc._RFpop();
},{}],"VienBi":[function(require,module,exports){
"use strict";
cc._RFpush(module, '5d08dmRTCdAQLQ8Dc32D9X6', 'VienBi');
// scripts\components\games\roulte\VienBi.js

var BaseMainGameplay = require('BaseMainGameplay');

cc.Class({
    'extends': cc.Component,

    properties: {
        sceneScript: BaseMainGameplay
    },
    onEnable: function onEnable() {
        cc.director.getCollisionManager().enabled = true;
        // cc.director.getCollisionManager().enabledDebugDraw = true;
    },

    onDisable: function onDisable() {
        cc.director.getCollisionManager().enabled = false;
        cc.director.getCollisionManager().enabledDebugDraw = false;
    },

    onCollisionEnter: function onCollisionEnter(other, self) {
        // this.node.parent.stopAllActions();
        this.sceneScript.stopVienBi();
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"BaseMainGameplay":"BaseMainGameplay"}],"WarningMessage":[function(require,module,exports){
"use strict";
cc._RFpush(module, '16c0d0Drd5Ezpv9B97mc6gF', 'WarningMessage');
// scripts\components\games\ui\WarningMessage.js

var Utils = require('Utils'),
    CommonConstant = require('CommonConstant');

cc.Class({
    'extends': cc.Component,

    properties: {
        contentLabel: cc.Label,
        duration: 3
    },

    start: function start() {
        this.node.zIndex = CommonConstant.ZINDEX.WARNING_MESSAGE;
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    open: function open(message, duration) {
        this.closeImmediately();

        if (!Utils.Type.isNumber(duration) || duration <= 0) {
            duration = Math.max(this.duration, 1);
        }
        this._closeTimeoutId = setTimeout(this.close.bind(this), duration * 1000);

        var node = this.node;
        if (node && node.isValid) {
            this.contentLabel.string = message;
            node.stopAllActions();
            node.active = true;
            node.scale = 0.3;
            node.runAction(cc.spawn([cc.scaleTo(0.1, 1), cc.fadeIn(0.1)]));
        }
    },

    close: function close() {
        var node = this.node,
            animation = cc.spawn([cc.scaleTo(0.1, 0.3), cc.fadeOut(0.1)]);

        if (node && node.isValid) {
            node.stopAllActions();
            node.runAction(cc.sequence([animation, cc.callFunc(this._hide.bind(this))]));
        }
    },

    closeImmediately: function closeImmediately() {
        if (this._closeTimeoutId) {
            clearTimeout(this._closeTimeoutId);
            this._closeTimeoutId = null;
        }
        this._hide();
    },

    _show: function _show() {
        if (this.node && this.node.isValid) {
            this.node.active = true;
        }
    },

    _hide: function _hide() {
        if (this.node && this.node.isValid) {
            this.node.active = false;
        }
    }
});

cc._RFpop();
},{"CommonConstant":"CommonConstant","Utils":"Utils"}],"XiToConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '82b01qldCtB25+cEi83pkDR', 'XiToConstant');
// scripts\games\xito\XiToConstant.js

var Utils = require('Utils');

module.exports = {
    GameType: {
        FIVE_CARDS: {
            ID: 0,
            NUMBER_OF_CARDS: 5
        },
        SEVEN_CARDS: {
            ID: 1,
            NUMBER_OF_CARDS: 7
        },

        findById: function findById(gameTypeId) {
            return Utils.Object.findObject(this, 'ID', gameTypeId);
        }
    },

    Action: {
        BET: 1,
        RAISE: 2,
        ALL_IN: 3,
        ALL_HAND: 31,
        CALL: 4,
        CHECK: 5,
        FOLD: 6,
        CHANGE_STATE: 7,
        CHANGE_TURN: 8,
        BUY_PRIVATE_MONEY: 9,
        BUY_PRIVATE_MONEY_REQUIRED: 10,
        END_TURN: 11,
        BET_1_2: 12,
        BET_1_4: 13,
        BET_X2: 14,
        CHOOSE_PUBLIC_CARD: 15
    },

    GameState: {
        NONE: 0,
        WAITING_FOR_PLAYER: 1,
        WAITING_FOR_NEW_GAME: 2,
        DEALING: 3,
        FINALIZING: 6,
        FINISH: 7,
        ROUND: 8
    },

    GameStatePoker: {
        PREFLOP: 8,
        FLOP: 9,
        TURN: 10,
        RIVER: 11
    },

    PlayerState: {
        NONE: 0,
        IN_TURN: 1,
        WAITING_FOR_TURN: 2,
        FOLDED: 3,
        ALL_IN: 4,
        OFF_MONEY: 5
    },

    Event: {
        START_TIME: 'in_game.xito.start_time',
        USER_BET: 'in_game.xito.user_bet',
        CHANGE_STATE: 'in_game.xito.change_state',
        CHANGE_TURN: 'in_game.xito.change_turn',
        UPDATE_MONEY: 'in_game.xito.update_money',
        SHOW_CARD_OPEN: 'in_game.xito.show_card_open',
        DRAW_CARD: 'in_game.xito.draw_card',
        FINISH_GAME: 'in_game.xito.finish_game',
        UPDATE_GAME: 'in_game.xito.update_game',
        REFRESH_GAME: 'in_game.xito.refresh_game',
        SHOW_BUY_CHIP: 'in_game.poker.show_buy_chip',
        HIDE_BUY_CHIP_BUTTON: 'in_game.poker.hide_buy_chip_button'
    },

    TimeoutId: {
        SHOW_COMMUNITY_CARDS: 'TIMEOUT_SHOW_COMMUNITY_CARDS'
    },

    Effect: {
        TO: 0,
        THEO: 1,
        NHUONG_TO: 2,
        UP_BO: 3,
        CHOI_TAT_TAY: 4,
        TO_12: 5,
        TO_14: 6,
        TO_X2: 7,
        TO_TAT_CA: 8,
        DANG_DOI: 9

    }

};

cc._RFpop();
},{"Utils":"Utils"}],"XiToGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'b69d8NNQt9NmJap/m07pSpB', 'XiToGameManager');
// scripts\games\xito\XiToGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    XiToConstant = require('XiToConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    XiToGameManager;

XiToGameManager = Utils.Class({
    $$extends: BaseGameManager,

    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this._setGameState(XiToConstant.GameState.NONE);

        // command từ smartfox server
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.WAITING_DEAL_CARD.ID, this.onWaittingDealCard, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.NEW_MATCH.ID, this.restartGame, this);

        // các action của game play
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.BET, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.ALL_IN, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.CALL, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.CHECK, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.FOLD, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.BET_1_2, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.BET_1_4, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.BET_X2, this.onPlayerBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.CHANGE_STATE, this.onChangeStateGame, this);
        this.eventDispatchers.playCmd.addEventListener(XiToConstant.Action.CHANGE_TURN, this.onChangeTurn, this);

        this.gameType = 7;
    },

    // ============================================================
    // Send API
    // ============================================================
    bet: function bet(betting) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(betting)
        });
    },

    choosePublicCard: function choosePublicCard(cardId) {
        this.send({
            command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
            action: NetworkManager.SmartFox.type.byte(XiToConstant.Action.CHOOSE_PUBLIC_CARD),
            card: NetworkManager.SmartFox.type.byte(cardId)
        });
    },

    // ============================================================
    // Receive API
    // ============================================================
    onUpdateGame: function onUpdateGame(params) {
        this.gameType = params.data.gameType === 0 ? 5 : 7;
        this.currency = params.data.currency;
        this.roomBetting = params.data.betting;
        this._setGameState(params.data.gameState);
        // this.onRefreshWaitting(params);

        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.UPDATE_GAME, params);
        var time = params.data.time;
        if (time) {
            var dt = 0;
            if (params.__execInfo__) {
                dt = params.__execInfo__.dt;
            }
            time -= dt;
        }
        this.onUpdateHand(time);
    },

    onUpdateHand: function onUpdateHand(timeChooseOpenCard) {
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.DRAW_CARD, timeChooseOpenCard);
    },

    onPlayerBetting: function onPlayerBetting(params) {
        this._setGameState(params.allData.gameState);
        // this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.USER_BET, [params.data.userName, params.data.money, params.action, params.allData.totalBetting, params.allData.callBetting]);
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.USER_BET, params);
    },

    onWaittingDealCard: function onWaittingDealCard(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.START_TIME, params.data.time);
    },

    onChangeStateGame: function onChangeStateGame(params) {
        this.currentRound = params.allData.currentRound;
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.CHANGE_STATE, params);
        var time = params.data.time;
        if (time) {
            var dt = 0;
            if (params.__execInfo__) {
                dt = params.__execInfo__.dt;
            }
            time -= dt;
        }
        this.onUpdateHand(time);
    },

    onChangeTurn: function onChangeTurn(params) {
        this._setGameState(params.allData.gameState);
        var newObject = {
            data: {
                userName: params.data.userName,
                time: params.data.time,
                allowedActions: params.data.allowedActions,
                minBetting: params.data.actionMoneyList,
                maxBetting: null
            }
        };
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.CHANGE_TURN, newObject);
    },

    onFinishGame: function onFinishGame(params) {
        this._setGameState(params.allData.gameState);
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.FINISH_GAME, params);
    },

    restartGame: function restartGame() {
        this.eventDispatchers.local.dispatchEvent(XiToConstant.Event.REFRESH_GAME);
    },

    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
        }
    }
});

// ============================================================
// Action API
// ============================================================

module.exports = XiToGameManager;

cc._RFpop();
},{"BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils","XiToConstant":"XiToConstant"}],"XiToOptionModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, '85a28sWso9Eg4/wVJrypnnw', 'XiToOptionModal');
// scripts\components\games\xito\XiToOptionModal.js

var BaseGameOptionModal = require('BaseGameOptionModal'),
    XiToConstant = require('XiToConstant'),
    NetworkManager = require('NetworkManager');

cc.Class({
    'extends': BaseGameOptionModal,

    properties: {},

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    _playXCardsGameType: function _playXCardsGameType(gameTypeId) {
        this.gameConfigs = this.gameConfigs || {};
        this.gameConfigs.gameType = NetworkManager.SmartFox.type.byte(gameTypeId);
        this.enterGame();
    },

    playFiveCardsGameType: function playFiveCardsGameType() {
        this._playXCardsGameType(XiToConstant.GameType.FIVE_CARDS.ID);
    },

    playSevenCardsGameType: function playSevenCardsGameType() {
        this._playXCardsGameType(XiToConstant.GameType.SEVEN_CARDS.ID);
    }
});

cc._RFpop();
},{"BaseGameOptionModal":"BaseGameOptionModal","NetworkManager":"NetworkManager","XiToConstant":"XiToConstant"}],"XoSoInfoModal":[function(require,module,exports){
"use strict";
cc._RFpush(module, 'bd956jpHHpJpJ0Z0rvFxPxv', 'XoSoInfoModal');
// scripts\components\games\xo_so\XoSoInfoModal.js

var NetworkManager = require('NetworkManager'),
    CommonConstant = require('CommonConstant'),
    GameConstant = require('GameConstant'),
    AuthUser = require('AuthUser'),
    Utils = require('Utils'),
    Url = require('Url');

cc.Class({
    'extends': cc.Component,

    properties: {
        dateLabel: cc.Label,
        xoSoResultContainer: cc.Node,

        xoSoBetLogPrefab: cc.Prefab,
        xoSoBetLogsContainer: cc.Node,

        helpLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.currentDate = new Date();
        this.currentAction = this.fetchXoSoResult;
        this.updateDate();
    },

    setNextDay: function setNextDay() {
        this.currentDate.setDate(this.currentDate.getDate() + 1);
        this.updateDate();
    },

    setPreviousDay: function setPreviousDay() {
        this.currentDate.setDate(this.currentDate.getDate() - 1);
        this.updateDate();
    },

    updateDate: function updateDate() {
        this.dateLabel.string = 'Ngày ' + Utils.Date.format(this.currentDate, 'dd/mm/yyyy');
        this.currentAction();
    },

    onTabClick: function onTabClick(tabNode) {
        this.currentAction = this['fetch' + tabNode.name];
        this.currentAction();
    },

    fetchXoSoResult: function fetchXoSoResult() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.XOSO_RESULT, {
            date: Utils.Date.format(this.currentDate, 'yyyy-mm-dd')
        }, {
            cache: 300
        }).success(function (resp) {
            var result = resp.data,
                resultNodes = that.xoSoResultContainer.children;
            for (var i = 0; i < resultNodes.length; i += 1) {
                resultNodes[i].getChildByName('lblResult').getComponent(cc.Label).string = (result[i] || []).join(' - ');
            }
        });
    },

    fetchLichSu: function fetchLichSu() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.XOSO_USER_BET_LIST, {
            username: AuthUser.username,
            accesstoken: AuthUser.accesstoken,
            date: Utils.Date.format(this.currentDate, 'yyyy-mm-dd')
        }, {}).success(function (resp) {
            var betLogs = resp.data,
                betLogNode,
                component,
                currency,
                winAmount;
            that.xoSoBetLogsContainer.removeAllChildren();
            for (var i = 0; i < betLogs.length; i += 1) {
                betLogNode = cc.instantiate(that.xoSoBetLogPrefab);
                component = betLogNode.getComponent('RowTable');

                currency = CommonConstant.CurrencyType.findByName(betLogs[i].currency).DISPLAY_NAME;
                if (betLogs[i].win_amount > 0) {
                    winAmount = Utils.Number.format(betLogs[i].win_amount) + ' ' + currency;
                } else {
                    winAmount = ' ';
                }
                component.updateData(betLogs[i].created_time.replace(' ', '\n'), betLogs[i].bet_name, betLogs[i].numbers.join(' - '), Utils.Number.format(betLogs[i].amount) + ' ' + currency, winAmount);
                that.xoSoBetLogsContainer.addChild(betLogNode);
            }
        });
    },

    fetchHelp: function fetchHelp() {
        var that = this;
        NetworkManager.Http.fetch('GET', Url.Http.GAME_HELP, {
            game_id: GameConstant.XO_SO.ID
        }, {
            cache: 3000
        }).success(function (resp) {
            if (resp.data) {
                that.helpLabel.string = resp.data.content;
            }
        });
    }

});
// called every frame, uncomment this function to activate update callback
// update: function (dt) {

// },

cc._RFpop();
},{"AuthUser":"AuthUser","CommonConstant":"CommonConstant","GameConstant":"GameConstant","NetworkManager":"NetworkManager","Url":"Url","Utils":"Utils"}],"XoSoItem":[function(require,module,exports){
"use strict";
cc._RFpush(module, '6a5bf00aRpGGLRZhqSL0Sa3', 'XoSoItem');
// scripts\components\games\xo_so\XoSoItem.js

cc.Class({
    "extends": cc.Component,

    properties: {
        nameLabel: cc.Label,
        ratioLabel: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {},

    updateData: function updateData(item) {
        this.nameLabel.string = item.name;
        this.ratioLabel.string = item.ratio;
    }
});

cc._RFpop();
},{}],"XocDiaConstant":[function(require,module,exports){
"use strict";
cc._RFpush(module, '36b0d4YeYVFo6mZ10ZXllzt', 'XocDiaConstant');
// scripts\games\xoc_dia\XocDiaConstant.js

var Utils = require('Utils');

module.exports = {
    Action: {
        BETTING: 1,
        CANCEL_BET: 2,
        TURN_MASTER: 3,
        MASTER_SELL_POT: 4,
        CHANGE_STATE: 5,
        UPDATE_POTS: 9,
        PING: 10
    },
    GameState: {
        NONE: 0,
        EFFECT: 1,
        PLAYER_BETTING: 2,
        MASTER_CANEL_BET: 3,
        FINISH: 4,
        FINALIZING: 5
    },
    ChipColor: {
        BLUE: {
            ID: 0,
            NAME: 'blue'
        },

        PURPLE: {
            ID: 1,
            NAME: 'purple'
        },

        GREEN: {
            ID: 2,
            NAME: 'green'
        },

        RED: {
            ID: 3,
            NAME: 'red'
        },

        findById: function findById(potId) {
            potId = parseInt(potId, 10);
            return Utils.Object.findObject(this, 'ID', potId);
        }
    },
    Event: {
        CHANGE_STATE: 'in_game.tai_xiu.change_state',
        EFFECT_STATE: 'in_game.tai_xiu.change_state.effect',
        PLAYER_BETTING_STATE: 'in_game.xoc_dia.change_state.player_betting',
        UPDATE_POTS: 'in_game.tai_xiu.update_pots',
        BETTING_SUCCESS: 'in_game.xoc_dia.betting_success',
        SHAKE_BOW_DICE: 'in_game.xoc_dia.shake',
        CANCEL_BET: 'in_game.xoc_dia.cancel_bet',
        FINISH: 'in_game.xoc_dia.finish',
        SELECT_CHIP: 'in_game.xoc_dia.select_chip',
        ADD_LIST_BETTING: 'in_game.xoc_dia.add_list_betting',
        ADD_BANKER: 'in_game.xoc_dia.add_banker',
        SET_RATIO: 'in_game.xoc_dia.set_ratio',
        BETTING_UPDATEGAME: 'in_game.xoc_dia.betting_updategame',
        MASTER_CANEL_BET: 'in_game.xoc_dia.master_cancel_bet',
        MASTER_CANEL_BET_RECEIVE: 'in_game.xoc_dia.master_cancel_bet_receive'
    }
};

cc._RFpop();
},{"Utils":"Utils"}],"XocDiaGameManager":[function(require,module,exports){
"use strict";
cc._RFpush(module, '4d8260kbFFCR7f0pbILt1fD', 'XocDiaGameManager');
// scripts\games\xoc_dia\XocDiaGameManager.js

var BaseGameManager = require('BaseGameManager'),
    SmartFoxConstant = require('SmartFoxConstant'),
    XocDiaConstant = require('XocDiaConstant'),
    NetworkManager = require('NetworkManager'),
    Utils = require('Utils'),
    AuthUser = require('AuthUser'),
    XocDiaGameManager;

XocDiaGameManager = Utils.Class({
    $$extends: BaseGameManager,
    $$constructor: function $$constructor(game, roomId) {
        this.$super.constructor.call(this, game, roomId);

        this.currentBet = [];
        this.history = [];
        this.isMaster = false;
        this.bettingList = [];

        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.UPDATE_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.REFRESH_GAME.ID, this.onUpdateGame, this);
        this.eventDispatchers.anyCmd.addEventListener(SmartFoxConstant.Command.FINISH_GAME.ID, this.onFinishGame, this);

        this.eventDispatchers.playCmd.addEventListener(XocDiaConstant.Action.BETTING, this.onBettingSuccess, this);
        this.eventDispatchers.playCmd.addEventListener(XocDiaConstant.Action.CHANGE_STATE, this.onChangeState, this);
        this.eventDispatchers.playCmd.addEventListener(XocDiaConstant.Action.CANCEL_BET, this.onCancelBetting, this);
        this.eventDispatchers.playCmd.addEventListener(XocDiaConstant.Action.MASTER_SELL_POT, this.onMasterCancelBet, this);
    },
    // Send API
    //
    sellBetCancelBet: function sellBetCancelBet(pot) {
        if (this.isMaster) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(XocDiaConstant.Action.MASTER_SELL_POT),
                pot: NetworkManager.SmartFox.type.byte(pot)
            });
        }
    },

    sendBet: function sendBet(pot, moneyBet) {
        if (!this.isMaster && moneyBet > 0) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(XocDiaConstant.Action.BETTING),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(pot),
                money: NetworkManager.SmartFox.type.long(moneyBet)
            });
        }
    },

    sendReBet: function sendReBet() {
        for (var i = 0; i < this.history.length; i += 2) {
            this.sendBet(this.history[i], this.history[i + 1]);
        }
    },

    sendDoubleBet: function sendDoubleBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.sendBet(this.currentBet[i], this.currentBet[i + 1]);
        }
    },

    sendCancelBet: function sendCancelBet() {
        for (var i = 0; i < this.currentBet.length; i += 2) {
            this.send({
                command: NetworkManager.SmartFox.type.byte(SmartFoxConstant.Command.PLAY.ID),
                action: NetworkManager.SmartFox.type.byte(XocDiaConstant.Action.CANCEL_BET),
                userName: NetworkManager.SmartFox.type.utfString(AuthUser.username),
                pot: NetworkManager.SmartFox.type.byte(this.currentBet[i])
            });
        }
    },

    // End Send API
    //
    //
    //
    onMasterCancelBet: function onMasterCancelBet(params) {
        //{action: 4, command: 20, pot: 1, username: "test6"}
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.MASTER_CANEL_BET_RECEIVE, params.pot);
    },

    countDowTime: function countDowTime(params) {
        return this._formatTime((params - Date.now()) / 1000);
    },

    onFinishGame: function onFinishGame(params) {
        //{time: 5000, players: Array[2], command: 30, dices: Array[4], potWin: Array[1]…}
        this._setGameState(XocDiaConstant.GameState.FINALIZING);
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.FINISH, params);
        if (this.currentBet.length > 0) {
            this.history = this.currentBet;
            this.currentBet = [];
        }
    },

    onUpdateGame: function onUpdateGame(params) {
        this.bettingList = params.bettingValues;
        this._updateListBetting(params.bettingValues);
        this._updateRatio(params.potInfo);
        this.onChangeState(params);
        if (this.gameState !== XocDiaConstant.GameState.FINISH) {
            this._bettingUpdateGame(params.pots);
        }
    },

    _bettingUpdateGame: function _bettingUpdateGame(params) {
        for (var i = 0; i < params.length; i += 1) {
            this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.BETTING_UPDATEGAME, params[i]);
        }
    },
    onBettingSuccess: function onBettingSuccess(params) {
        //{money: 15000, action: 1, command: 20, pot: 5, username: "ngohoangtrung85044"}
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.BETTING_SUCCESS, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet.push(params.pot, params.money);
        }
    },

    onCancelBetting: function onCancelBetting(params) {
        //{action: 2, command: 20, pot: 4, username: "test6"}
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.CANCEL_BET, params);
        if (this.isCurrentPlayer(params.username)) {
            this.currentBet = [];
        }
    },
    onChangeState: function onChangeState(params) {
        this._setGameState(params.gameState);
        switch (params.gameState) {
            case XocDiaConstant.GameState.EFFECT:
                this.onEfectShake(params);
                break;
            case XocDiaConstant.GameState.PLAYER_BETTING:
                this.onPlayerBetting(params);
                break;
            case XocDiaConstant.GameState.MASTER_CANEL_BET:
                this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.MASTER_CANEL_BET, params);
                break;
            default:
                break;
        }
    },

    _setGameState: function _setGameState(newGameState) {
        if (this.gameState !== newGameState) {
            this.gameState = newGameState;
            this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.CHANGE_STATE);
        }
    },

    onPlayerBetting: function onPlayerBetting(params) {
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.PLAYER_BETTING_STATE, params);
    },
    onEfectShake: function onEfectShake(params) {
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.SHAKE_BOW_DICE, params);
    },
    _updateRatio: function _updateRatio(params) {
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.SET_RATIO, params);
    },
    _updateListBetting: function _updateListBetting(params) {
        this.eventDispatchers.local.dispatchEvent(XocDiaConstant.Event.ADD_LIST_BETTING, params);
    },

    _formatTime: function _formatTime(elapsedTime) {
        if (elapsedTime >= 0) {
            elapsedTime = Math.floor(elapsedTime);
            var mins = Math.floor(elapsedTime / 60),
                seconds = elapsedTime % 60;
            return Utils.Number.fillZero(mins, 2) + ':' + Utils.Number.fillZero(seconds, 2);
        }
        return '00:00';
    }

});

module.exports = XocDiaGameManager;

cc._RFpop();
},{"AuthUser":"AuthUser","BaseGameManager":"BaseGameManager","NetworkManager":"NetworkManager","SmartFoxConstant":"SmartFoxConstant","Utils":"Utils","XocDiaConstant":"XocDiaConstant"}]},{},["ToggleCurrency","FacebookInteract","AnimationManager","LichSuDoi","RunningMessage","TabView","EffectThangTrang","SanThuongGameManager","Loading","PlayerUIMauBinh","PlayerUITLMN","HistoryTableMiniPoker","ItemEvent","MessageBox","PlayerUI","WarningMessage","TinhNang","ColumnInfoMiniPoker","ItemTopWinGame","PhomGameManager","RowTable","Collapse","MauBinhConstant","PlatformImplement","LiengConstant","CardRank","PokerGameManager","Event","PokerConstant","SysConfig","ButtonMaterial","BauCuaBuyPot","GameplayTaiXiu","TopTableMiniPoker","Boot","SmartFoxWebImplement","CardLayoutMauBinh","PlayerUIPhomCurrent","BaseGameManager","ItemTextMiniPoker","NetworkManager","SamConstant","ItemDaiLy","XocDiaConstant","BaseGameplay","GameConstant","DoiThe","UiManager","HotEvent","HopquaInfor","MinigameQuickIcon","SamGameManager","RunningMessageStore","MiniPokerGameManager","TinhNangManager","GameplayXocDia","GameManagerConstant","GameplayXoSo","ConfirmModal","Url","GameplayXiTo","Modal","GameplayPoker","Chip","GameManager","TaiXiuGameManager","ItemTopUser","XocDiaGameManager","SanThuongConstant","AuthUser","HistoryTableTaiXiu","EventDispatcher","NapIap","GameItem","GameplayRoulette","MauBinhGameManager","EventDispatcherConstant","TopPanelOutGame","MinigamePopup","MessageBoxCache","VienBi","GameItemDataWrapper","CardSuit","AudioList","TLMNConstant","CommonConstant","XoSoItem","PhomOptionModal","SortCardLayoutMauBinh","Profile","MultiScreen","NapTinNhan","InviteCode","PlayerUIXiTo","ItemThe","TabChangePassword","ToggleButton","EffectAvatar","Utils","XiToConstant","TabSupport","GameplaySanThuong","XiToOptionModal","GameplaySam","SmartFoxConstant","TLMNGameManager","DropDown","AudioManager","TabVatPham","PlayerConstant","Carousel","SlotInfor","SFS2X","BaseGameOptionModal","PotInforSanThuong","RulePotSanThuong","Slider","RoulettePotInfor","Settings","ItemVatPham","PlayerUIPhom","TaiXiuConstant","SmartFox","TopUsers","GameHelpModal","ItemMessage","IplayHttp","GameplayTLMN","HistorySanThuong","PhomUtils","BauCuaGameManager","Pagination","GiftCode","ItemTinNhan","TopPanelInGame","ItemInapp","GameplayBauCua","XiToGameManager","CardUI","Hall","XoSoInfoModal","TabActivateAccount","TabInformation","GameplayMauBinh","NapThe","Splash","DaiLy","ChangeSpriteAnimation","LiengGameManager","MultiSelect","BauCuaConstant","CardUIPhom","HotEventTrigger","Card","PhomConstant","RouletteConstant","FacebookLike","RowInforSanThuong","GameplayMiniPoker","ChiMauBinh","Lobby","TopTableTaiXiu","HelpMiniPoker","ButtonScaler","NapXu","UrlImage","TopPanelOutGameWrapper","MiniPokerConstant","BaseMinigameGameplay","BaseMainGameplay","GameplayLieng","RouletteGameManager","Player","GameplayPhom"]);
